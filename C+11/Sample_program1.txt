/*
	Below is the sample program for the C++11 features.
	Source Code Location: https://github.com/ViswanathanRamasamy/Cpp_Sample_Programs
	Author Name: Viswanathan Ramasamy
	Email id: rviswawt@gmail.com
*/

C++11
=====
some mistake what i have done:
#include <cstdint> =>int16_t
array of character from array<char> to print (cout<<array.data();
delete can be on the global function
false value is false
fork is used when executeing the exe

pass the inavlid argument expection?
inavlid_argument not invalid arguments

How to find whether the element is find in the set?
if (mySet.find(valueToFind) != mySet.end()) 

====================================
=======================================================================================
reference can be an variable or function
function returning the reference, double reference , pass by value, const reference
examplw with string

lvalue and rvalue are not the same. lvalue is an expression whose address can be taken
lvalue uses one &
rvalue uses &&
int a;
a =1; //a is l value

lvalue needn't be the variable all the time.

int x;
int& getRef () 
{
        return x;
}
 
getRef() = 4;

rvalue: An expression is an rvalue if it results in a temporary object.
int x;
int getVal ()
{
    return x;
}
getVal();

Here, getVal() is an rvalue--the value being returned is not a reference to x, it's just a temporary value.

string getName ()
{
    return "Alex";
}
getName();
Here, getName returns a string that is constructed inside the function. You can assign the result of getName to a variable:

string name = getName();
But you're assigning from a temporary object, not from some value that has a fixed location.

Prior to C++11, if you had a temporary object, you could use a "regular" or "lvalue reference" to bind it, but only if it was const:
const string& name = getName(); // ok
string& name = getName(); // NOT ok

const string&& name = getName(); // ok
string&& name = getName(); // also ok - praise be!
==================================================================================================================
const lvalue reference can used to extend the lifetime of the temporary object with in that block.
void g() {
  const C& refC = createC();
  f();
}  // ~C() called only here, after f(), when refC goes out of scope.

===============================================================================================================
We cannot create the normal lvalue reference for the local variable
include <iostream>

int GetInt() {
    int x = 1;
    return x;
}

int main() {
    int& x = GetInt(); // compiler error if it is not const change it ie const int& x = GetInt();
    std::cout << x << std::endl;

    return 0;
}
======================================================================================================
creating the reference and changing the reference value?
different ways to create double reference?
can we change the value of the double reference ?


int value = 42;
int& ref = value; // Creating a reference to the 'value' variable
ref = 100;     

int&& rvalueRef = 42; // Creating an rvalue reference to a temporary value


int && rvalueRef = (x+1); // rvalueRef is rvalue reference //(x+1) is temporary value

int && rvalueRef = (x); //error

int x =10;
int && rvalueRef = (x + 1); //allowed
rvalueRef = 100;
int *ptr = &rvalueRef; //here you are taking the address of the rvalue and not the temporary object.
std::cout << *ptr; //100

=====================================================================================================
int getData()
{
    return 9;
}

getData() is a rvalue. So, only rvalue reference can refer to it. If lvalue reference will try to refer to it then will result in compile error i.e. 
int & lvalueRef3 = getData(); // Compile error - lvalue Reference Can't point to rvalue

Although const lvalue reference can refer to temporary object returned by getData() but as its a const reference, so we can not modify this temporary.

const int & lvalueRef3 = getData(); // OK but its const
But a rvalue reference can refer to rvalue without const i.e.

int && rvalueRef2 = getData();

We can not modify the rvalue of builtin data type i.e.

(x+7) = 7; // Compile error - Can not Modify rvalue
int getData();
Here getData() is a rvalue of buildin data type int and if we try to modify it then it will result in compile error i.e

getData() = 9; // Compile Error - Can not modify rvalue

rvalue of User Defined data type is not Immutable

=============================================================================================================
we cannot take the address of the temporary object?
rvalue of User Defined Data type can be modified. But it can be modified in same expression using its own member functions only. 

get the increment for the temporary object?

#include <iostream>
class Person {
    int mAge;
public:
    Person() {
        mAge = 10;
    }
    void incrementAge()
    {
        mAge = mAge + 1;
    }
};
Person getPerson()
{
    return Person();
}
int main() {
//Now getPerson() is a rvalue and we can not take its address i.e
//    Person * personPtr = &getPerson();
//Here we have modified a rvalue of Person Class Type with its member function in the same expression.
    getPerson().incrementAge();
    return 0;
}
===========================
passing temporary object to the function?
=>as the && to a function and then incrementing?

#include <iostream>

class MyClass {
public:
    int value;

    MyClass(int v) : value(v) {}
};

void modifyObject(MyClass&& obj) {
    obj.value = 100;  // Modifying the underlying object
    std::cout << "Inside modifyObject: " << obj.value << std::endl; //100
}

int main() {
    modifyObject(MyClass(42));  // Passing an rvalue of user-defined type

    return 0;
}
=================================================================================
we cannot get the address of the rvalue?
lvalue +1 will give the rvalue?

lvalue is anything whose address is accessible. It means we can take address of lvalue using & operator. 
Rvalue is anything that is not lvalue. It means we cannot take address of rvalue and it also don’t persist beyond the single expression.
int a = 7; // a is lvalue & 7 is rvalue
int b = (a + 2); // b is lvalue & (a+2) is rvalue
int c = (a + b) ; // c is lvalue & (a+b) is rvalue
int * ptr = &a; // Possible to take address of lvalue
//int * ptr3 = &(a + 1);  // Compile Error. Can not take address of rvalue
=================================================================================
we cannot get the address of the temporary data but we can get the address of the rvalue variable
int getData()
{
    int data = 0;
    return data;
}
Here, the value retutned by getData() is temporary i.e. it will not persist beyond the expression where it is called. Therefore it will get copied. Therefore, we can not take the address of temporary value returned by getData() i.e.

int * ptr = &getData(); // Compile error - Cannot take address of rvalue
Therefore, getData() is a rvalue and we cannot take the address of rvalue.
==========================================================================================]\
Turns out that the temporary lifetime extension rule applies only to direct references to temporary objects, 
not to references obtained indirectly via a member function.
#include <iostream>
#include <string>

struct Container {
    std::string s;

    Container() {
        s = "Init";
        std::cout << "Constructed" << std::endl;
    }

    ~Container() {
        s = "UNSAFE";
        std::cout << "Destructed" << std::endl;
    }

    const std::string& GetS() const {
        return s;
    }
};

int main() {
    const std::string& s = Container().GetS();
    std::cout << s << std::endl;

    return 0;
}
Constructed
Destructed
UNSAFE
======================================
#include <iostream>
#include <string>

struct Container {
    std::string s;

    Container() {
        s = "Init";
        std::cout << "Constructed" << std::endl;
    }

    ~Container() {
        s = "UNSAFE";
        std::cout << "Destructed" << std::endl;
    }

    const std::string& GetS() const {
        return s;
    }
};

int main() {
    const std::string& s = Container().s;
    std::cout << s << std::endl;

    return 0;
}
It does a similar thing except line 23 takes a direct reference to the member variable. Is this safe?

In this case, the answer is YES!. The output is:

Constructed
Init
Destructed
i.e. the destruction of the temporary |Container()| is held off until |const std::string& s| can be safely destructed.
==============================================
const pointer
const reference
copy between vectors?

char * const p = &ch1; //address stored in p cannot be changed
const reference :
- const references allow you to specify that the data referred to won't be changed. A const reference is actually a 
reference to const. A reference is inherently const, so when we say const reference, it is not a reference that can not be changed, 
rather it’s a reference to const. 
String& a = String("test");         // Error since modifying the temporary object

std::vector<MyClass> A;
std::vector<MyClass> B;
....
A = B; // will take more copy so A=std::move(B) or A.swap(B); B.clear();
B.clear();
=======================================
vector reserve limit the capacity
When a vector is created, its capacity is typically set to some initial value (which can be specified in the constructor), and its size is initially
 zero. As elements are added to the vector using the `push_back()` member function, the vector's size increases. If the size of the 
 vector reaches its capacity, the vector may need to be reallocated to a larger block of memory to accommodate additional elements.
 This can be an expensive  operation, as it involves copying all of the existing elements to the new memory block.
====================================================================================
swaping between the vectors using move
declaring 2 vector in single ine:
int main1()
{
	vector <int> A, B;
	for (int i = 0; i < 5; i++)
	{
		A.push_back(i);
	}
	
	B = std::move(A);

	cout << B.size() << " " << A.size(); // 5 0
	return 0;
}
========================
modify the elements in the vector?

int main1()
{
	vector <int> A, B;
	for (int i = 0; i < 5; i++)
	{
		A.push_back(i);
	}
	for (auto s : A)
	{
		cout << s << "  "; // 0 1 2 3 4
		s++; //local variable
	}

	for (auto &s : A)
	{
		cout << s << "  "; // 0 1 2 3 4
		s= s+10;
	}
	cout << endl;

	for (const auto& s : A)  // we cannot modify the vector using the s since it is constant
	{
		cout << s << "  "; // 10 11 12 13 14
	}

	return 0;
}
=============================
string A("abc") or A{"abc"}
example for calling copy constructor using push_back?

#include <iostream>
#include <vector>

using namespace std;

class moveable
{
	public:
		moveable(int d)
		{
			data = new int(d);
			cout << "Inside the constructor " <<* data << endl;
		}
		
		moveable(const moveable &others):moveable(*others.data)
		{
			cout <<"Inside the copy constructor " << *data << endl;
		}
		
		
		~moveable()
		{
			if (data == nullptr)
			{
				cout << "Inside the destructor pointer is NULL ";
			}
			else
			{
				cout << "Inside the destructor " <<* data << endl;
				delete data;
			}
		}
	private:
	  int *data;
};

int main()
{
	vector <moveable> v;
	v.push_back(moveable(10)); // or v.push_back(moveable{ 10 });
	v.push_back(moveable(100));
	return 0;
}

//
Inside the constructor 10
Inside the constructor 10
Inside the copy constructor 10
Inside the destructor 10

Inside the constructor 100
Inside the constructor 100
Inside the copy constructor 100

Inside the constructor 10
Inside the copy constructor 10
Inside the destructor 10

Inside the destructor 100
//vector
Inside the destructor 10
Inside the destructor 100

===========================
from redeference i can move?
template <typename T>
template <class T>

template<class T>
void myswapMove(T& a, T& b)
{
	T tmp{ std::move(a) }; // invokes move constructor
	a = std::move(b); // invokes move assignment
	b = std::move(tmp); // invokes move assignment
}

int main1()
{
	std::string x{ "abc" };
	std::string y{ "de" };

	std::cout << "x: " << x << '\n';
	std::cout << "y: " << y << '\n';

	myswapMove<string>(x, y); //or myswapMove(x, y)

	std::cout << "x: " << x << '\n';
	std::cout << "y: " << y << '\n';

	return 0;
}
===================================
template<class T2, class T1>
void myswapMove(T2& a, T1& b)
{
	T tmp{ std::move(a) }; // invokes move constructor
	a = std::move(b); // invokes move assignment
	b = std::move(tmp); // invokes move assignment
}

int main1()
{
	std::string x{ "abc" };
	std::string y{ "de" };

	std::cout << "x: " << x << '\n';
	std::cout << "y: " << y << '\n';

	myswapMove<string,string>(x, y);

	std::cout << "x: " << x << '\n';
	std::cout << "y: " << y << '\n';

	return 0;
}
==========================================
the copy constructor is called several times and increases the overhead and decreases the computational power of the code.
 To avoid this overhead and make the code more efficient we use move constructors.
 Work of move constructor looks a bit like default member-wise copy constructor but in this case, it nulls out the pointer 
 of the temporary object preventing more than one object to point to same memory location.

========================================
#include <stdexcept>
void f() noexcept; // the function f() does not throw
void (*fp)() noexcept(false); // fp points to a function that may throw
// typedef int (*pf)() noexcept; // error
===========================================
#include <iostream>

// Example function that takes a function pointer with no parameters and noexcept specifier
void g(void (*pfa)() noexcept) {
    std::cout << "Inside function g()" << std::endl;
    pfa();  // Call the provided function pointer
}

// Example function that can be passed as an argument to g()
void myFunction() noexcept {
    std::cout << "Inside myFunction()" << std::endl;
}

int main() {
    g(myFunction);  // Pass myFunction as an argument to g()
    return 0;
}

=========================================================
inavlid_argument throw?
constructor throwing the expection when the noexcept?


class MyClass {
public:
    MyClass(int value) noexcept(true): data(value) { //Here we suppose not to throw the exception since noexcept(true) or noexcept ;//warning will be generated by the compilere 
	//since the constructor is not suppose to throw the exception but it throws
        if (value < 0) {
            throw std::invalid_argument("Invalid argument: value must be non-negative.");
        }

        std::cout << "Constructor called with value: " << value << std::endl;
    }

private:
    int data;
};

int main1() {
    try {
        MyClass obj(-1);
    }
    catch (const std::exception& e) {
        std::cout << "Exception caught: " << e.what() << std::endl;
    }

    return 0;
}
if the constructor throws the exception:
std::terminate will be called, terminating the program without executing the exception handling code in the catch block.
=================================================================================================
class containing the double reference constructor?
remenmber to set the null or reset the value for the argumnet passed to the move constructor?

#include <iostream>
#include <vector>

using namespace std;

class moveable
{
	public:
		moveable(int d)
		{
			data = new int(d);
			cout << "Inside the constructor " <<* data << endl;
		}
		
		moveable(const moveable &others):moveable(*others.data)
		{
			cout <<"Inside the copy constructor " << *data << endl;
		}
		
		moveable(moveable &&others):data(others.data)
		{
			
			cout <<"Inside the movable constructor " << *data << endl;
			others.data = nullptr;
		}	
		
		~moveable()
		{
			if (data == nullptr)
			{
				cout << "Inside the destructor pointer is NULL " <<endl;
			}
			else
			{
				cout << "Inside the destructor " <<* data << endl;
				delete data;
			}
		}
	private:
	  int *data;
};

int main1()
{
	vector <moveable> v;
	v.push_back(moveable{10}); //or v.push_back(moveable(10));
	v.push_back(std::move(moveable(100))); // v.push_back((moveable(100))); //since moveable(100) will give the temporary object
	return 0;
}

Inside the constructor 10
Inside the movable constructor 10
Inside the destructor pointer is NULL
Inside the constructor 100
Inside the movable constructor 100
Inside the constructor 10
Inside the copy constructor 10
Inside the destructor 10
Inside the destructor pointer is NULL
Inside the destructor 10
Inside the destructor 100
========================================
moving the normal object as the double reference to the class?

#include <iostream>
#include <vector>

using namespace std;

class moveable
{
	public:
		moveable(int d)
		{
			data = new int(d);
			cout << "Inside the constructor " <<* data << endl;
		}
		
		moveable(const moveable &others):moveable(*others.data)
		{
			cout <<"Inside the copy constructor " << *data << endl;
		}
		
		moveable(moveable &&others):data(others.data) //moveable(moveable &&others) rvalue reference
		{
			
			cout <<"Inside the move constructor " << *data << endl;
			others.data = nullptr;
		}	
		
		~moveable()
		{
			if (data == nullptr)
			{
				cout << "Inside the destructor pointer is NULL " <<endl;
			}
			else
			{
				cout << "Inside the destructor " <<* data << endl;
				delete data;
			}
		}
	private:
	  int *data;
};

int main()
{
	vector <moveable> v;
	moveable a{10};
	moveable b{100};
	v.push_back(std::move(a)); // if you are not using move here it will call the copy constructor
	v.push_back(std::move(b));
	return 0;
}
//////
Inside the constructor 10
Inside the constructor 100

Inside the move constructor 10
Inside the move constructor 100

Inside the constructor 10
Inside the copy constructor 10
Inside the destructor 10
//local object
Inside the destructor pointer is NULL 
Inside the destructor pointer is NULL 
//vector
Inside the destructor 10
Inside the destructor 100
===================================================
normal pass the object instead move will call the copy constructor?
temporary object passed in the push_back will call the move constructor? 

int main()
{
	vector <moveable> v;
	moveable a{10};
	moveable b{100};
	v.push_back((a));
	v.push_back((b));
	return 0;
}

Inside the constructor 10
Inside the copy constructor 10
Inside the constructor 100
Inside the copy constructor 100
Inside the constructor 10
Inside the copy constructor 10
Inside the destructor 10
Inside the destructor 100
Inside the destructor 10
Inside the destructor 10
Inside the destructor 100
===============================
loop over the string  for each character?

std::vector<std::string> vecString;
// Printing content of the vector
    for (const auto& s : vecString) {
        std::cout << s << '\n';
    }

======================================
i cannot take the address of the temporary object, but you can take the address of the address of the && variable
we can assign && to & but not vicer versa without move

int a = 10;
 
    // Declaring lvalue reference
    // (i.e variable a)
    int& lref = a;
 
    // Declaring rvalue reference
    int&& rref = 20;
 
    // Print the values
    cout << "lref = " << lref << endl;
    cout << "rref = " << rref << endl;
 
    // Value of both a
    // and lref is changed
    lref = 30;
 
    // Value of rref is changed
    rref = 40;
    int &&ref = a; //error
===================================
reserve , resize, size  and capacity 
#include <iostream>
#include <vector>

int main() {
    std::vector<int> myVector;

    // Reserve memory for 5 elements (capacity will be at least 10)
    myVector.reserve(5);

    // Add 5 elements to the vector
    for (int i = 0; i < 5; ++i) {
        myVector.push_back(i);
    }

    std::cout << "Size: " << myVector.size() << std::endl;     // Output: 5
    std::cout << "Capacity: " << myVector.capacity() << std::endl; // Output: 5

    // Add more elements to the vector
    for (int i = 5; i < 15; ++i) {
        myVector.push_back(i);
    }

    std::cout << "Size: " << myVector.size() << std::endl;     // Output: 15
    std::cout << "Capacity: " << myVector.capacity() << std::endl; // Output: 20 (may vary by implementation)

    // Resize the vector to contain only 10 elements
    myVector.resize(10);

    std::cout << "Size: " << myVector.size() << std::endl;     // Output: 10
    std::cout << "Capacity: " << myVector.capacity() << std::endl; // Output: 20 (capacity doesn't change)

    return 0;
}
====================================================================================================

================================================
insert the element in the vector from the 6th position onwards?
vector iterator begin and end initialization in single line.

#include "pch.h"
#include <iostream>
#include <vector>

using namespace std;

#include <iostream>
#include <vector>

using namespace std;

vector <int> function(vector <int> param)
{
	vector <int> v;
	v.reserve(5); // minimum it can store 5 elements without going for the  ie capacity of the vector is 5;
	//reallocation
	for (auto b = v.begin(), e = v.end(); b != e; b++)
	{
		cout << *b; // it will not print anything
	}
	cout << endl;
	for (auto b = param.begin(), e = param.end(); b != e; b++)
	{
		// here the reallocation of the memory happens since the total number of element
		//exceeds 5
		v.push_back(2 * *b);
	}
	return (v);
}
int main1()
{
	vector <int> v1(5), v2(5);
	for (int i = 0; i < 5; i++)
	{
		v1.push_back(i); //0 0 0 0 0 0 1 2 3 4 // here 10 elements
	}
	v2 = function(v1);
	cout << endl;
	for (auto b = v2.begin(), e = v2.end(); b != e; b++)
	{
		cout << "  " << *b; //0 0 0 0 0 0 2 4 6 8
	}
	return 0;
}
====================================================
// Move assignment operator.
MemoryBlock& operator=(MemoryBlock&& other) noexcept
{
   std::cout << "In operator=(MemoryBlock&&). length = "
             << other._length << "." << std::endl;

   if (this != &other)
   {
      // Free the existing resource.
      delete[] _data;

      // Copy the data pointer and its length from the
      // source object.
      _data = other._data;
      _length = other._length;

      // Release the data pointer from the source object so that
      // the destructor does not free the memory multiple times.
      other._data = nullptr;
      other._length = 0;
   }
   return *this;
}
===============================
#include <iostream>
#include <vector>

using namespace std;

class moveable
{
public:
	moveable(int d)
	{
		data = new int(d);
		cout << "Inside the constructor " << *data << endl;
	}

	moveable(const moveable& others) :moveable(*others.data)
	{
		cout << "Inside the copy constructor " << *data << endl;
	}

	// Move assignment operator.
	moveable& operator=(moveable&& other) noexcept
	{
		std::cout << "In operator=(moveable&&)" <<endl;

		if (this != &other)
		{
			// Free the existing resource.
			delete[] data;

			// Copy the data pointer and its length from the
			// source object.
			data = other.data;
			

			// Release the data pointer from the source object so that
			// the destructor does not free the memory multiple times.
			other.data = nullptr;
		
		}
		return *this;
	}

	moveable(moveable&& others) :data(nullptr) //moveable(moveable &&others) rvalue reference
	{

		cout << "Inside the move constructor " << *others.data << endl;
		*this = std::move(others); // this will calll the move assignment operator.
	}

	~moveable()
	{
		if (data == nullptr)
		{
			cout << "Inside the destructor pointer is NULL " << endl;
		}
		else
		{
			cout << "Inside the destructor " << *data << endl;
			delete data;
		}
	}
private:
	int* data;
};

int main1()
{
	vector <moveable> v;
	moveable a{ 10 };
	moveable b{ 100 };
	v.push_back(std::move(a)); // if you are not using move here it will call the copy constructor
	v.push_back(std::move(b));
	return 0;
}

Inside the constructor 10
Inside the constructor 100
Inside the move constructor 10
In operator=(moveable&&)
Inside the move constructor 100
In operator=(moveable&&)
Inside the constructor 10
Inside the copy constructor 10
Inside the destructor 10
Inside the destructor pointer is NULL
Inside the destructor pointer is NULL
Inside the destructor 10
Inside the destructor 100
========================================================
what is alternate way to use move?
if the A(A&& other)  is not there program will not give error for move or static_cast, it will call the copy constructor:
#include <iostream>
#include <vector>

class A {
public:
    A(int val) : value(val) {}
    A(const A& other) : value(other.value) {
        std::cout << "Copy constructor called" << std::endl;
    }
    A(A&& other) : value(other.value) {
        std::cout << "Move constructor called" << std::endl;
    }

private:
    int value;
};

int main() {
    std::vector<A> v;
    A aObj(25);       // lvalue

    // push_back(const T&) - calls copy constructor
    v.push_back(aObj);

    // push_back(T&&) - calls move constructor
    v.push_back(static_cast<A&&>(aObj));  // Using cast

    // push_back(T&&) - calls move constructor
    v.push_back(std::move(aObj));         // Using std::move

    return 0;
}

=====================
#include <iostream>
#include <string>

int main() {
    std::string myString = "Hello, world!";
    
    char lastCharacter = myString.back();
    
    std::cout << "Last character: " << lastCharacter << std::endl; // Output: !

    return 0;
}

===========================================================
copy the normal string to vector pushback and what will happen after move to the vector?
std::vector<std::string> v;
std::string str = "example";
v.push_back(std::move(str)); // str is now valid but unspecified
str.back(); // undefined behavior if size() == 0: back() has a precondition !empty()
=====================
all references referring the same variable address?

int main1()
{
	int a = 10;
	int& b = a;
	//int&& c = a; //error
	//int&& c = b; //error
	int&& c = std::move(a);
	int& d = c;

	cout << &a << " " << &b << "  " << &c << " " << &d <<endl; // all refers to the same address
	cout << a << " " << b << "  " << c << " " << d; // 10 10 10 10 10 
	return 0; 
}
========================
no except using sizeof
template<class T> 
T f() noexcept(sizeof(T) < 4); 
//This is a template function f() that takes no arguments and returns a value of the template type T. It uses noexcept to specify that the
// function won't throw exceptions if the size of the type T is less than 4 bytes.

int main() {
    decltype(f<void>()) *p; // f is called unevaluated, but noexcept-spec is needed, p is void pointer
}
============================
noexcept based on the int constructor?

//noexcept(false) is the default behaviour for the function (exception is allowed to throw
//noexcept(true) or noexcept ==> exception is not allowed
// whether foo is declared noexcept depends on if the expression
// T() will throw any exceptions
template <class T>
  void foo() noexcept(noexcept(T())) {} // noexcept(T()) here if the Int() is marked as true if int() doesnot throw the exception
 
void bar() noexcept(true) {}
void baz() noexcept { throw 42; }  // noexcept is the same as noexcept(true)
 
int main() 
{
    foo<int>();  // noexcept(noexcept(int())) => noexcept(true), so this is fine
 
    bar();  // fine
    baz();  // compiles, but at runtime this calls std::terminate
}
============================
string move to another string

. std::move is a utility function that converts an lvalue into an rvalue reference
std::string source = "Hello, world!";

// Move the content of `source` into `destination`
std::string destination = std::move(source);
===========================================================================================================
In C++, the presence of a user-defined destructor prevents the compiler from generating 
an implicit move constructor or move assignment operator.
============================================================================================
move constructor called with the keyword move?
	// t2.cpp
#include <iostream>
#include <string>

using namespace std;

class A
{
public:
    // default constructor
    A() : s("default") { cout << "default constructor A\n"; }

    // copy constructor
    A(const A& o) : s(o.s) { cout << "copy constructor A - move failed!\n";}

    // move constructor
    A(A&& o) : s(move(o.s)) { cout << "move constructor A(A&&) called\n"; }

    string printObj() { return s; }
private:
    string s;
};

A temp(A a) {
    return a;
}

class B : public A
{};

int main()
{
    // calls default constructor
    B b1;

    // calls implicit move constructor sine there is no b desctructor
    B b2 = std::move(b1);

    return 0;
}
Since we haven't declared move constructor for B, when we do:

 B b2 = std::move(b1);
the implicit move constructor B::(B&&) will be used. It calls A's move constructor A::(A&&). The output looks like this:

$ g++ t2.cpp -o t2 -std=c++11
$ ./t2
default constructor A
move constructor A(A&&) called
===========================
move constructor called without the keyword move?

class A
{
public:
    // default constructor
    A() : s("default") {}

    // copy constructor
    A(const A& o) : s(o.s) { cout << "move failed!\n"; }

    // move constructor
    A(A&& o) : s(move(o.s)) {
        cout << "movr called \n";
    }

    string printObj() { return s; }
private:
    string s;
};

A temp(A a) {
    cout << "inside temp \n";
    return a;
}

int main1()
{
    // move-construct from rvalue temporary
    A a1 = temp(A());

    // move-construct from lvalue 
    cout << "before move() : a1 = " << a1.printObj() << endl;
    A a2 = move(a1);
    cout << "after move() : a1 = " << a1.printObj() << endl;
    cout << "after move() : a2 = " << a2.printObj() << endl;

    return 0;
}

inside temp
movr called
before move() : a1 = default
movr called
after move() : a1 =
after move() : a2 = default
=================================
// t3.cpp
#include <iostream>
#include <string>

using namespace std;
class A
{
public:
    // default constructor
    A() : s("default") { cout << "default constructor A\n"; }

    // copy constructor
    A(const A& o) : s(o.s) { cout << "copy constructor A - move failed!\n";}

    // move constructor
    A(A&& o) : s(move(o.s)) { cout << "move constructor A(A&&) called\n"; }

    string printObj() { return s; }
private:
    string s;
};

A temp(A a) {
    return a;
}

class B : public A
{};

class C : public B 
{
public:
    // this destructor prevents implicit move ctor C::(C&&)
    ~C() {};
};
Since we have our own destructor for C, the move() won't call C::(C&&), instead it uses copy constructor as 
shown in the output below:

default constructor A
copy constructor A - move failed!
=====================
if we comment out the destructor 
default constructor A
move constructor A(A&&) called
======================================
forcing the default move inside the class which has the destructor
// t4.cpp
#include <iostream>
#include <string>

using namespace std;
class A
{
public:
    // default constructor
    A() : s("default") { cout << "default constructor A\n"; }

    // copy constructor
    A(const A& o) : s(o.s) { cout << "copy constructor A - move failed!\n";}

    // move constructor
    A(A&& o) : s(move(o.s)) { cout << "move constructor A(A&&) called\n"; }

    string printObj() { return s; }
private:
    string s;
};

A temp(A a) {
    return a;
}

class B : public A
{};

class C : public B
{
public:
    // this destructor prevents implicit move ctor C::(C&&)
    //~C() {};
};

class D : public A
{
public:
    // default constructor
    D() {}

    // destructor would prevent implicit move constructor D::(D&&)
    ~D() {};

    // forced use of move constructor
    D(D&&) = default;
};

int main()
{
    D d1;
    D d2 = std::move(d1);

    return 0;
}
default constructor A
move constructor A(A&&) called
========================================
std::string source = "Hello";
std::string destination = std::move(source);
Here, source is an lvalue, and std::move converts it into an rvalue reference, enabling the move 
constructor or move assignment operator to be invoked
==================================================================
rememebr you cannot create the double reference to the lvalue unless you use move?
int i = 10
i has the location , 10 is value so 10 is rvalue and i is lvalue
we cannot assign something to rvalue
10  = i;
int a = i;
a and i both are lvalues;

int func()
{
return 10;
}

int i = func(); 
func() is rvalue since it return 10 which has no location ie temporary value
func() = 10 //error

string n1="abc"
string n2="def";
string n3 = n1+n2;

Here n1,n2,n3 is the l value and abc,def,n1+n2 are rvalue; n1+n2 create the temporary value and assign to n3.

if you want to assign the rvalue to the lvalue refeence we need the const 

string &n4=n1+n2; //error
const string &n4=n1+n2; //ok

we cannot pass the lvalue to the rvalue reference (accepts only temporary object) like
string &&n5=n1; //error
string &&n5=n1+n2;//ok
===============================================
class sample
{
  public:
    sample() 
    {
	}
	
    sample(char* _data, int _len): len(_len)
	{
	    cout << "inside the parameter const " << endl;
	    data=new char[len];
		memcpy(data,_data, len);
	}
	
	sample(const sample &others): len(others.len)
	{
	   cout << "inside the copy constructor " << endl;
	    data=new char[len];
		memcpy(data,others.data,len);
	}
	
	~sample()
	{
	   cout << "inside the destructor " << endl;
	   if (data != NULL)
	   {
	      delete []data;
	   }
	}
private:
   char *data;
   int len;
};

class entity
{
   public:
    entity(sample _s):s(_s) //call the copy constructor
    {
	    cout << "inside the entity constructor " << endl;
	}
	/*
	    entity(sample _s)
    {
	    cout << "inside the entity constructor " << endl;
	    s= (_s); //this will call the assignement operator
	}
	*/
	public:
		sample s;  
};

int main()
{
   entity (sample("viswa",5));
   return 0;
}
==============================
inside the parameter const 
inside the copy constructor 
inside the entity constructor 
inside the destructor 
inside the destructor
===================================
no need of & in entity(sample &_s):s(_s)
class sample
{
  public:
    sample() 
    {
	}
	
    sample(char* _data, int _len): len(_len)
	{
	    cout << "inside the parameter const " << endl;
	    data=new char[len];
		memcpy(data,_data, len);
	}
	
	sample(const sample &others): len(others.len)
	{
	   cout << "inside the copy constructor " << endl;
	    data=new char[len];
		memcpy(data,others.data,len);
	}
	
	sample(sample &&others) noexcept
	{
	     cout << "inside the sample move constructor " << endl;
	     data = others.data;
	     others.data = NULL;
	     others.len = 0;
	}
	
	~sample()
	{
	   cout << "inside the destructor " << endl;
	   if (data != NULL)
	   {
	      delete []data;
	   }
	}
private:
   char *data;
   int len;
};

class entity
{
   public:
    entity(sample &_s):s(_s) //call the copy constructor
    {
	    cout << "inside the entity constructor " << endl;
	}
	
	entity(sample &&_s):s(_s) //call the copy constructor
    {
	    cout << "inside the entity move constructor " << endl;
	}
	/*
	    entity(sample _s):s(_s) 
    {
	    cout << "inside the entity constructor " << endl;
	    s= (_s); //this will call the assignement operator
	}
	*/
	public:
		sample s;  
};

int main()
{
   entity ((sample("viswa",5)));
   return 0;
}
=================
inside the parameter const 
inside the copy constructor 
inside the entity move constructor 
inside the destructor 
inside the destructor 
=================================================
#include <iostream>
#include <cstring>

int main() {
    const char source[] = "Hello, World!";
    char destination[20]; // Make sure the destination array is large enough to hold the copied data

    // Using memcpy to copy data from source to destination
    memcpy(destination, source, strlen(source) + 1);

    // Printing the copied data
    std::cout << "Source: " << source << std::endl;
    std::cout << "Destination: " << destination << std::endl;

    return 0;
}
In this corrected code, strlen(source) + 1 is used as the length to copy. This ensures that the null-terminator at the end of the C-style string is also copied to the destination array. 
This null-terminator is necessary to indicate the end of the string in C-style strings.
-===============================================================
#include <iostream>
#include <cstring>

int main() {
    const char source[] = "Hello, World!";
    char destination[20]; // Make sure the destination array is large enough to hold the copied data

    // Using memcpy to copy data from source to destination
    memcpy(destination, source, sizeof(source));

    // Printing the copied data
    std::cout << "Source: " << source << std::endl;
    std::cout << "Destination: " << destination << std::endl;

    return 0;
}

=====================================================
// Online C++ compiler to run C++ program online
#include <iostream>
#include <stack>
#include <string.h>

using namespace std;

#include <iostream>

class sample
{
  public:
    sample() 
    {
	}
	
    sample(char* _data, int _len): len(_len)
	{
	    cout << "inside the parameter const " << endl;
	    data=new char[len+1];
		memcpy(data,_data, len+1);
	}
	
	sample(const sample &others): len(others.len)
	{
	   cout << "inside the copy constructor " << endl;
	    data=new char[len+1];
		memcpy(data,others.data,len+1);
	}
	
	sample(sample &&others) noexcept
	{
	     cout << "inside the sample move constructor " << endl;
	     data = others.data;
	     others.data = NULL;
	     others.len = 0;
	}
	
	~sample()
	{
	   cout << "inside the destructor " << endl;
	   if (data != NULL)
	   {
	      delete []data;
	   }
	}
private:
   char *data;
   int len;
};

class entity
{
   public:
    entity(sample &_s):s(_s) //call the copy constructor
    {
	    cout << "inside the entity constructor " << endl;
	}
	
	entity(sample &&_s):s(std::move(_s)) //call the move constructor of the sample
    {
	    cout << "inside the entity move constructor " << endl;
	}
	public:
		sample s;  
};

int main()
{
   entity (std::move(sample("viswa",5))); //or entity ((sample("viswa",5)));
   return 0;
}
================
inside the parameter const 
inside the sample move constructor 
inside the entity move constructor 
inside the destructor 
inside the destructor 
==========================================
noexcept:
Mark a function as noexcept only if all the functions that it calls, either directly or indirectly, are also noexcept or const.
 The compiler doesn't necessarily check every code path for exceptions that might bubble up to a noexcept function. 
 If an exception does exit the outer scope of a function marked noexcept, std::terminate is invoked immediately,
 and there's no guarantee that destructors of any in-scope objects will be invoked.
 ============================
 
 decltype vs type id:
 decltype vs typeid

Decltype gives the type information at compile time while typeid gives at runtime.
So, if we have a base class reference (or pointer) referring to (or pointing to) a derived class object, 
the decltype would give type as base class reference (or pointer, but typeid would give the derived type reference (or pointer).

 #include <iostream>

class Base {
public:
    virtual void someFunction() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void someFunction() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    
    decltype(*basePtr) derivedObj = *basePtr; //base reference to the derived object
    derivedObj.someFunction();  // Outputs "Derived class"
    
    delete basePtr;
    
    return 0;
}
================================================================================
creating pointer reference using the decltype?

#include <iostream>

int main() {
    int x = 42;
    int* ptr = &x;  // Pointer to int

    // Create a pointer reference using decltype
    decltype(ptr)& ptrRef = ptr;

    // Modify the value through the pointer reference
    *ptrRef = 99;

    std::cout << "x: " << x << std::endl;       // Output: x: 99
    std::cout << "*ptr: " << *ptr << std::endl; // Output: *ptr: 99

    return 0;
}

=========================================================================
typeid for the float, double, pointer, pointer to pointer
int main()
{
    // auto a; this line will give error
    // because 'a' is not initialized at
    // the time of declaration
    // a=33;
 
    // see here x ,y,ptr are
    // initialised at the time of
    // declaration hence there is
    // no error in them
    auto x = 4;
    auto y = 3.37;
      auto z = 3.37f;
      auto c = 'a';
    auto ptr = &x;
      auto pptr = &ptr; //pointer to a pointer
    cout << typeid(x).name() << endl //i
         << typeid(y).name() << endl //d
         << typeid(z).name() << endl //f
         << typeid(c).name() << endl //c
         << typeid(ptr).name() << endl //pi
           << typeid(pptr).name() << endl; //ppi
 
    return 0;
}
================================
#include <iostream>

auto add(int a, int b) {
    return a + b;
}

int main() {
    auto result = add(3, 4);
    std::cout << "Result: " << result << std::endl;
    
    return 0;
}
In the above example, the add function uses auto as the return type. The actual return type of the function is deduced 
by the compiler based on the expression a + b. Since both a and b are int types, the expression evaluates to an int, 
and thus the return type of add is deduced as int.

In the main function, the return value of add(3, 4) is assigned to the result variable, which is also declared using 
auto. The compiler deduces the type of result as int based on the return type deduction of the add function.
==============================================
=========================================================
decltype of the variable based on the return type of the function.

decltype Keyword: It inspects the declared type of an entity or the type of an expression. ‘auto’ lets you declare 
a variable with a particular type whereas decltype  lets you extract the type from the variable so decltype is sort 
of an operator that evaluates the type of passed expression

// C++ program to demonstrate use of decltype
#include <bits/stdc++.h>
using namespace std;
 
int fun1() { return 10; }
char fun2() { return 'g'; }
 
int main()
{
    // Data type of x is same as return type of fun1()
    // and type of y is same as return type of fun2()
    decltype(fun1()) x;
    decltype(fun2()) y;
 
    cout << typeid(x).name() << endl; //i
    cout << typeid(y).name() << endl; //c
 
    return 0;
}
=======================
decltype for the already declared variable:

// Driver Code
int main()
{
    int x = 5;
 
    // j will be of type int : data type of x
    decltype(x) j = x + 5;
 
    cout << typeid(j).name(); //i
 
    return 0;
}
===================================================================
here :
std::type_info& typeInfo = typeid(*basePtr); // This will result in error since the copy constructor is private
const std::type_info & typeInfo = typeid(*basePtr);

#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual void printType() {
        std::cout << "Base" << std::endl;
    }
};

class Derived : public Base {
public:
    void printType() override {
        std::cout << "Derived" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived;

    // Using typeid to get type information
    const std::type_info& typeInfo = typeid(*basePtr);
    std::cout << "Object's type: " << typeInfo.name() << std::endl;

    // Using type_info to compare types
    if (typeInfo == typeid(Base)) {
        std::cout << "Object is of type Base" << std::endl;
    } else if (typeInfo == typeid(Derived)) {
        std::cout << "Object is of type Derived" << std::endl;
    } else {
        std::cout << "Object's type is unknown" << std::endl;
    }

    delete basePtr;

    return 0;
}

=====================================================================
class MyClass {
public:
    void print() const {
        // Print something
    }
};

int main() {
    const MyClass obj;
    MyClass &ref = obj; // Error: Binding non-const reference to a const object
    ref.print();
    return 0;
}

=====================================================================
decltype to determine the return of the function?

// C++ program to demonstrate use of decltype in functions
#include <bits/stdc++.h>
using namespace std;
 
// A generic function which finds minimum of two values
// return type is type of variable which is minimum
template <class A, class B>
auto findMin(A a, B b) -> decltype(a < b ? a : b)
{
    return (a < b) ? a : b;
}
 
// driver function to test various inference
int main()
{
    // This call returns 3.44 of double type
    cout << findMin(4, 3.44) << endl;
 
    // This call returns 3 of double type
    cout << findMin(5.4, 3) << endl;
 
    return 0;
}
Output
3.44
3
==============================================
difference in the decltype and typeid for the (int*)
auto type for the "hello"
decltype using reference

auto z = "Hello, world!";  // z is deduced as const char*
auto keyword:

auto is used for automatic type deduction of variables.
It allows the compiler to determine the type of a variable based on its initializer expression.
The type deduction occurs at compile time.

double foo();
int main()
{
   int x = 10;
    decltype(x) y;  // y is deduced as int
    
    
    decltype(foo()) z;  // z is deduced as double
    
    int* ptr = nullptr;
    decltype(*ptr) value = x;  // value is deduced as int&
    
    cout << typeid(*ptr).name() <<endl; //i
    value =100;
    cout << x; //100
}
=================================
uniform initialization:
Consistency: The uniform initialization syntax provides a consistent way to initialize objects regardless of their type. 
This improves code readability and reduces the need to remember different initialization methods for different types.
// uninitialized built-in type
int i;    

// initialized built-in type
int j=10; 

// initialized built-in type
int k(10);

// Aggregate initialization
int a[]={1, 2, 3, 4} 

// default constructor
X x1; 

// Parameterized constructor
X x2(1); 

// Parameterized constructor with single argument
X x3=3; 

// copy-constructor
X x4=x3;
========
int i{};     // initialized built-in type, equals to int i{0};

int j{10}; // initialized built-in type

int a[]{1, 2, 3, 4} // Aggregate initialization

X x1{}; // default constructor

X x2{1}; // Parameterized constructor;

X x4{x3}; // copy-constructor
================
uniform initialization for the dynamic array?
// C++ program to demonstrate initialization
// of dynamic array in C++ using uniform initialization
#include <bits/stdc++.h>
using namespace std;
int main()
{
    // declaring a dynamic array
    // and initializing using braces
    int* pi = new int[5]{ 1, 2, 3, 4, 5 };
 
    // printing the contents of the array
    for (int i = 0; i < 5; i++)
        cout << *(pi + i) << " ";
}
===============
uniform initialization for array inside the class constructor

// C++ program to initialize
//  an array data member of a class
// with uniform initialization
#include <iostream>
using namespace std;
 
class A
{
    int arr[3];
 
public:
    // initializing array using
    // uniform initialization
    A(int x, int y, int z)
        : arr{ x, y, z } {};
 
    void show()
    {
        // printing the contents of the array
        for (int i = 0; i < 3; i++)
            cout << *(arr + i) <<" ";
    }
};
 
// Driver Code
int main()
{
    // New object created and the numbers
    // to initialize the array with, are passed
    // into it as arguments
    A a(1, 2, 3);
    a.show(); / 1 2 3
    return 0;
}
===============
uniform initialization of the object from the function return value to the class object.

// C++ program to implicitly
// initialize an object to return
#include <iostream>
using namespace std;
 
// declaring a class 'A'
class A {
    // a and b are data members
    int a;
    int b;
 
    // constructor
public:
    A(int x, int y)
        : a(x)
        , b(y)
    {
    }
    void show() { cout << a << " " << b; }
};
 
A f(int a, int b)
{
    // The compiler automatically
    // deduces that the constructor
    // of the class A needs to be called
    // and the function parameters of f are
    // needed to be passed here
    return { a, b };
}
 
// Driver Code
int main()
{
    A x = f(1, 2);
    x.show(); //1 2
    return 0;
}
================
uniform initialization of the object to the function argument to form the class object.
// C++ program to demonstrate how to
// initialize a function parameter
// using Uniform Initialization
 
#include <iostream>
using namespace std;
 
// declaring a class 'A'
class A {
 
    // a and b are data members
    int a;
    int b;
 
public:
    A(int x, int y)
        : a(x)
        , b(y)
    {
    }
    void show() { cout << a << " " << b; }
};
 
void f(A x) { x.show(); }
 
// Driver Code
int main()
{
 
    // calling function and initializing it's argument
    // using brace initialization
    f({ 1, 2 }); //1 2
    return 0;
}
============
double initialization:
int x = 3.14;                    // Traditional initialization - narrowing conversion
int y{3.14};                     // Uniform initialization - compilation
================================================

std::vector<int> numbers{1, 2, 3};              // Uniform initialization of vector
std::tuple<int, std::string, double> tpl{42, "Hello", 3.14};  // Uniform initialization of tuple

struct Point {
    int x;
    int y;
};

Point p{10, 20};                                // Uniform initializat
=============================
int main() {
    int num1 = 42;       // Traditional initialization
    int num2{42};        // Uniform initialization
    
    std::string message = "Hello";   // Traditional initialization
    std::string message2{"Hello"};    // Uniform initialization
    
    std::vector<int> numbers = {1, 2, 3};  // Traditional initialization
    std::vector<int> numbers2{1, 2, 3};    // Uniform initialization
    
    return 0;
}
===========================================
#include <iostream>
#include <vector>
#include <map>

int main() {
    // Initializing a vector using initializer
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // Iterating over the vector using range-based for loop
    for (const auto& num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // Initializing a map using initializer list
    std::map<int, std::string> months = {
        {1, "January"},
        {2, "February"},
        {3, "March"},
        {4, "April"},
        {5, "May"}
    };
    
    // Iterating over the map and printing key-value pairs
    for (const auto& month : months) {
        std::cout << month.first << ": " << month.second << std::endl;
    }
    
    return 0;
}
Output:

makefile

1 2 3 4 5 
1: January
2: February
3: March
4: April
5: May
================================
nitializer List:
An initializer list is a syntax introduced in C++11 that allows you to initialize objects, including containers, 
using a list of values enclosed in curly braces {}. It is primarily used for initializing containers like arrays,
 vectors, maps, and other aggregate types.

Example:

cpp

std::vector<int> numbers = {1, 2, 3, 4, 5};
std::map<std::string, int> ages = {{"Alice", 25}, {"Bob", 30}, {"Charlie", 35}};
In the above example, we use initializer lists to initialize a std::vector and a std::map with a list of values.

Uniform Initialization:
Uniform initialization is a broader concept introduced in C++11 that provides a consistent syntax for 
initializing objects of various types. It allows you to initialize objects using either parentheses () or curly braces {}.

Example:

cpp

int x(42);                       // Traditional initialization
std::string str{"Hello"};        // Uniform initialization
std::vector<int> numbers{1, 2, 3};   // Uniform initialization
In the above example, we use both traditional initialization with parentheses and uniform initialization with curly braces. 
The uniform initialization syntax using curly braces provides a more consistent and concise way to initialize objects.

The key difference between initializer lists and uniform initialization is as follows:

Initializer lists are specifically used to initialize containers and aggregate types using a list of values enclosed
 in curly braces {}. They provide a convenient way to initialize containers with multiple elements.

Uniform initialization is a general syntax that provides a consistent way to initialize objects of various types, 
including fundamental types, user-defined types, and containers. It allows you to use either parentheses () or curly braces {} 
for initialization.

While initializer lists are a specific use case of uniform initialization for initializing containers, uniform initialization has 
a broader scope and can be used for initializing various types of objects in a consistent and readable manner.
=========================================================================
typedef example?

// Original type name
typedef int MyInteger;

int main() {
    MyInteger num = 42;  // Using the typedef alias
======================================
nullptr is defined which header file

nullptr:pointer to NULL
typedef nullptr_t defined in the header <cstddef>. 
NULL is a macro defined in older versions of C and C++ to represent a null pointer. It is usually defined as 0 or (void*)0.
ype Safety: nullptr is a keyword of type nullptr_t, specifically designed to represent null pointers. It provides better 
type safety because it cannot be implicitly converted to other pointer types. On the other hand, NULL is typically defined as 
an integer value (0 or (void*)0), which can lead to potential ambiguities and type conversion issues.

Overloaded Functions: nullptr helps in disambiguating overloaded functions. When overloaded functions have parameters of 
pointer types, using nullptr can help the compiler select the correct overload. NULL may not provide the same level of
 type safety and disambiguation.
#include <iostream>

void foo(int* ptr) {
    if (ptr == nullptr) {
        std::cout << "Pointer is null." << std::endl;
    } else {
        std::cout << "Pointer is not null." << std::endl;
    }
}

int main() {
    int* ptr1 = nullptr;  // Initialize pointer with nullptr
    int* ptr2 = 0;  // Another pointer initialized with nullptr
    
    foo(ptr1);  // Passing nullptr to the function
    foo(ptr2);  // Passing nullptr to the function
    
    return 0;
}
====
Pointer is null.
Pointer is null.
nullptr is a keyword that can be used at all places where NULL is expected. 
Like NULL, nullptr is implicitly convertible and comparable to any pointer type. 
Unlike NULL, it is not implicitly convertible or comparable to integral types.
// This program does NOT compile
#include<stdio.h>
int main()
{
   int x = nullptr; //compiler error
   int x1 = NULL; // no error
}
================
assigning nullptr to int ?
overloading function for null?

// C++ program to demonstrate problem with NULL
#include <bits/stdc++.h>
using namespace std;
 
// function with integer argument
void fun(int N)   { cout << "fun(int)"; return;}
 
// Overloaded function with char pointer argument
void fun(char* s)  { cout << "fun(char *)"; return;}
 
int main()
{
    // Ideally, it should have called fun(char *),
    // but it causes compiler error.
    fun(NULL);  //ambigiour error
}
===============================

void foo(int* ptr) {
    std::cout << "Function with int* pointer." << std::endl;
}

void foo(char* ptr) {
    std::cout << "Function with char* pointer." << std::endl;
}

int main() {
    foo(nullptr);     // Calls foo(int* ptr)
    //foo(NULL);        // Calls foo(int* ptr) or foo(char* ptr) - ambiguous (compilation warning)
    
    return 0;
}
================
The range-based for loop is a feature introduced in C++11 that simplifies the process of iterating over elements in a range, such as an array, container, or any type that supports the begin and end functions. It provides a more concise and readable syntax compared to traditional loops using iterators or indices.

The syntax of the range-based for loop is as follows:

cpp

for (declaration : range) {
    // Loop body
}
==========
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    // Iterate over the elements of the vector using the range-based for loop
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
//1 2 3 4 5
===============
std::nullptr_t is used as the type of the nullptr value, which is then compared against a pointer
 variable to check for a null pointer.
new data types indroduecd in c++11:
auto, decltype, and long long, nullptr
======================================================================================
 literal refers to a fixed value that is written directly into the source code of a program, representing a constant value of a 
 particular data type.
 
userdefined literal:C++11 allow you to define custom ways to create literals for your user-defined types.

int integerLiteral = 42;
    double floatingPointLiteral = 3.14;
    char characterLiteral = 'A';
	
#include <iostream>

// User-defined literal for converting temperatures from Celsius to Fahrenheit
constexpr double operator"" _CelsiusToFahrenheit(long double celsius) {
    return static_cast<double>(celsius * 9.0 / 5.0) + 32.0;
}

int main() {
    // Using the user-defined literal to convert temperatures
    double freezingPoint = 0.0_CelsiusToFahrenheit;
    double boilingPoint = 100.0_CelsiusToFahrenheit;

    std::cout << "Freezing point in Fahrenheit: " << freezingPoint << std::endl;
    std::cout << "Boiling point in Fahrenheit: " << boilingPoint << std::endl;

    return 0;
}

========================================================
#include <iostream>

class Distance {
public:
    explicit Distance(double meters) : meters(meters) {}

    double getMeters() const {
        return meters;
    }

private:
    double meters;
};

// User-defined literal operator for meters
Distance operator"" _m(long double value) {
    return Distance(static_cast<double>(value));
}

int main() {
    // Using the user-defined literal to create Distance objects
    Distance d1 = 5.3_m;
    Distance d2 = 10.7_m;

    std::cout << "Distance 1: " << d1.getMeters() << " meters" << std::endl;
    std::cout << "Distance 2: " << d2.getMeters() << " meters" << std::endl;

    return 0;
}
========================================================
nullptr declaration type?
::value

#include <iostream>
#include <type_traits>

typedef std::nullptr_t NullPtrType;

int main() {
    NullPtrType myNullPtr = nullptr;
    
    // Checking the type of myNullPtr using type traits
    if (std::is_same<decltype(myNullPtr), std::nullptr_t>::value) {
        std::cout << "myNullPtr has type std::nullptr_t" << std::endl;
    } else {
        std::cout << "myNullPtr has a different type" << std::endl;
    }
    
    return 0;
}
In this example, we define a type alias NullPtrType using typedef to represent std::nullptr_t. We then declare a 
variable myNullPtr of type NullPtrType and initialize it with nullptr.

Next, we use the std::is_same type trait from the <type_traits> header to check if the type of myNullPtr is 
std::nullptr_t. If the type is std::nullptr_t, we print the corresponding message.

When you run this program, it should output:

myNullPtr has type std::nullptr_t
By using typedef with std::nullptr_t, you can create your own alias for the std::nullptr_t type, which can be 
useful in certain scenarios where you want to provide a more descriptive name for null pointers in your code.
==========================================
delegating constructors:
However, C++11 introduced a feature called "delegating constructors," which allows a constructor to invoke another constructor of 
the same class to perform common initialization logic. This feature helps reduce code duplication and improve code maintainability. 
Let me provide an example of delegating constructors:

cpp

#include <iostream>

class MyClass {
    int value1;
    int value2;

public:
    MyClass() : MyClass(0) {
        std::cout << "Default constructor called." << std::endl;
    }

    MyClass(int value) : MyClass(value, 0) {
        std::cout << "Single-argument constructor called." << std::endl;
    }

    MyClass(int value1, int value2) : value1(value1), value2(value2) {
        std::cout << "Two-argument constructor called." << std::endl;
    }

    void PrintValues() {
        std::cout << "Value1: " << value1 << ", Value2: " << value2 << std::endl;
    }
};

int main() {
    MyClass obj1;          // Calls the default constructor
    MyClass obj2(42);      // Calls the single-argument constructor
    MyClass obj3(10, 20);  // Calls the two-argument constructor

    obj1.PrintValues();    // Output: Value1: 0, Value2: 0
    obj2.PrintValues();    // Output: Value1: 42, Value2: 0
    obj3.PrintValues();    // Output: Value1: 10, Value2: 20

    return 0;
}
Default constructor called.
Single-argument constructor called.
Two-argument constructor called.
Value1: 0, Value2: 0
Value1: 42, Value2: 0
Value1: 10, Value2: 20
==========================================
Delegating constructors in C++ provide a way to reuse common initialization logic among different constructors 
within a class. They offer several benefits:

Code Reuse: Delegating constructors allow you to avoid code duplication by consolidating common initialization 
logic in a single constructor. Instead of repeating the same initialization code in multiple constructors, you 
can delegate the task to a single constructor.

n C++11, the default and delete keywords were introduced to provide more control over the default behavior of certain class member functions and to explicitly disable certain operations. Let's look at each keyword and their respective use cases with examples:

default keyword:
The default keyword is used to explicitly request the compiler to generate the default implementation of a special member function (constructor, destructor, or assignment operator) if the class qualifies for it. It is especially useful when you want to define some custom special member functions but still want the default behavior for others.

Example:

cpp

class MyClass {
public:
    // Default constructor
    MyClass() = default;

    // Copy constructor
    MyClass(const MyClass& other) = default;

    // Move constructor
    MyClass(MyClass&& other) = default;

    // Destructor
    ~MyClass() = default;

    // Assignment operator
    MyClass& operator=(const MyClass& other) = default;
};
In this example, the default keyword is used to explicitly request the compiler to generate the default 
implementations of the special member functions for the class MyClass.
 This allows you to have custom behavior for some functions while utilizing the default behavior for others.

delete keyword:
The delete keyword is used to explicitly disable the automatic generation of certain member functions.
 It prevents the compiler from automatically generating the function and results in a compilation error 
 if someone attempts to use it.

Example:

cpp

class NonCopyable {
public:
    // Default constructor
    NonCopyable() = default;

    // Delete copy constructor
    NonCopyable(const NonCopyable&) = delete;

    // Delete copy assignment operator
    NonCopyable& operator=(const NonCopyable&) = delete;
};
In this example, the delete keyword is used to explicitly delete the copy constructor and copy assignment 
operator for the class NonCopyable. This prevents instances of NonCopyable from being copied, and any attempt to do so
 will result in a compilation error.

Initialization Consistency: Delegating constructors ensure that the common initialization code is executed consistently
 across different constructors. This helps maintain the integrity of the object's state by ensuring that all constructors
 perform the necessary initialization steps.
==================================================
class MyClass {
public:
    // Default constructor explicitly defined
    MyClass() = default;

    // Deleted copy constructor to prevent copying
    MyClass(const MyClass&) = delete;

    // Default destructor explicitly defined
    ~MyClass() = default;

    // Deleted assignment operator to prevent assignment
    MyClass& operator=(const MyClass&) = delete;
};

int main() {
    MyClass obj1;          // Default constructor called

    // MyClass obj2(obj1); // Compilation error - Copy constructor is deleted

    // obj1 = obj2;        // Compilation error - Assignment operator is deleted

    return 0;
}

prevent the assignement operator:
By deleting the assignment operator, we ensure that each instance of UniqueResource manages its resource independently 
and avoids unintended sharing or resource leaks.
============================================
class MyClass {
private:
    // Private constructor
    MyClass() {
        // Constructor implementation
    }

public:
    // Factory method to create instances
    static MyClass* createInstance() {
        return new MyClass();
    }

    // Destructor explicitly deleted
    ~MyClass() = delete;
};

int main() {
    MyClass* obj = MyClass::createInstance();  // Creating instance using factory method

    // Use obj...

    // Attempting to delete  and create the object will result in a compilation error
	// Myclass oh1;
    // delete obj;

    return 0;
}

=================================================
tuple:
tuple definition and accessing individual elements?

A tuple is an object that can hold a number of elements. The elements can be of different data types. 
#include <iostream>
#include <tuple>

int main() {
    // Create a tuple with three elements
    std::tuple<int, std::string, double> myTuple(42, "Hello", 3.14);

    // Access elements of the tuple using std::get
    int value1 = std::get<0>(myTuple);
    std::string value2 = std::get<1>(myTuple);
    double value3 = std::get<2>(myTuple);

    // Print the values
    std::cout << value1 << ", " << value2 << ", " << value3 << std::endl;

    return 0;
}
============================
42, Hello, 3.14
================================================
changing the value in the tuple?

int main()
{
    // Declaring tuple
    tuple <char, int, float> geek;
 
    // Assigning values to tuple using make_tuple()
    geek = make_tuple('a', 10, 15.5);
 
    // Printing initial tuple values using get()
    cout << "The initial values of tuple are : ";
    cout << get<0>(geek) << " " << get<1>(geek);
    cout << " " << get<2>(geek) << endl;
 
    // Use of get() to change values of tuple
    get<0>(geek) = 'b';
    get<2>(geek) =  20.5;
 
     // Printing modified tuple values
    cout << "The modified values of tuple are : ";
    cout << get<0>(geek) << " " << get<1>(geek);
    cout << " " << get<2>(geek) << endl;
 
    return 0;
}
======
finding the size of  the tuple?
tuple_size<>
tuple_cat()

The initial values of tuple are : a 10 15.5
The modified values of tuple are : b 10 20.5
cout << tuple_size<decltype(geek)>::value << endl; ==> 3
 cout << tuple_size< tuple <char,int,float>>::value << endl; ==> 3
 =================
 tie to unpack the desired elements?
 
 tie() :- The work of tie() is to unpack the tuple values into separate variables. 
 // C++ code to demonstrate working of tie()
#include<iostream>
#include<tuple> // for tie() and tuple
using namespace std;
int main()
{  
    // Initializing variables for unpacking
    int i_val;
    char ch_val;
    float f_val;  
     
    // Initializing tuple
    tuple <int,char,float> tup1(20,'g',17.5);
 
    // Use of tie() without ignore
    tie(i_val,ch_val,f_val) = tup1;
     
    // Displaying unpacked tuple elements
    // without ignore
    cout << "The unpacked tuple values (without ignore) are : ";
    cout << i_val << " " << ch_val << " " << f_val;
    cout << endl;
     
    // Use of tie() with ignore
    // ignores char value
    tie(i_val,ignore,f_val) = tup1;
     
    // Displaying unpacked tuple elements
    // with ignore
    cout << "The unpacked tuple values (with ignore) are : ";
    cout << i_val  << " " << f_val;
    cout << endl;
 
    return 0;
 
}
Output:

The unpacked tuple values (without ignore) are : 20 g 17.5
The unpacked tuple values (with ignore) are : 20 17.5
=============
tuple_cat can cat more than 2 tuple also
replace auto 

tuple_cat() :- This function concatenates two tuples and returns a new tuple. 
// C++ code to demonstrate working of tuple_cat()
#include<iostream>
#include<tuple> // for tuple_cat() and tuple
using namespace std;
int main()
{
    // Initializing 1st tuple
    tuple <int,char,float> tup1(20,'g',17.5);
 
    // Initializing 2nd tuple
    tuple <int,char,float> tup2(30,'f',10.5);
     
    // Concatenating 2 tuples to return a new tuple
    auto tup3 = tuple_cat(tup1,tup2); tuple<int,char,float, int,char,float > tup3 = tuple_cat(tup1,tup2);
     
    // Displaying new tuple elements
    cout << "The new tuple elements in order are : ";
    cout << get<0>(tup3) << " " << get<1>(tup3) << " ";
    cout << get<2>(tup3) << " " << get<3>(tup3) << " ";
    cout << get<4>(tup3) << " " << get<5>(tup3) << endl;
 
    return 0;
}
Output:

The new tuple elements in order are : 20 g 17.5 30 f 10.5
=========================
structure vs tuple:
ructures are more suitable for representing structured data with meaningful member names and behavior, 
while tuples are convenient for temporary grouping of heterogeneous values without requiring explicit type definitions 
or behavior customization.
=======================================
tuple initialization after the declaration?
tuple inside the set and passing it to the function and print the values?

/ C++ program to demonstrate the 
// implementation of set of
// tuples
#include <bits/stdc++.h>
using namespace std;
  
// Function to print set contents
void print(set<tuple<int, int, 
                     int> >& setOfTuples)
{
  for (auto x : setOfTuples) 
  {
    tuple<int, int, int> tp = x;
    cout << get<0>(tp) << 
            ' ' << get<1>(tp) << 
            ' ' << get<2>(tp) << '\n';
  }
}
  
// Driver code
int main()
{
  // Declaring a set of tuples
  set<tuple<int, int, 
            int> > setOfTuples;
  
  // Initializing tuples
  tuple<int, int, 
        int> tuple1;
  tuple1 = make_tuple(1, 2, 3);
  
  tuple<int, int, 
        int> tuple2;
  tuple2 = make_tuple(2, 3, 5);
  
  tuple<int, int, 
        int> tuple3;
  tuple3 = make_tuple(2, 3, 4);
  
  tuple<int, int, 
        int> tuple4;
  tuple4 = make_tuple(2, 1, 4);
  
  tuple<int, int, 
        int> tuple5;
  tuple5 = make_tuple(5, 8, 14);
  
  // Inserting into set
  setOfTuples.insert(tuple1);
  setOfTuples.insert(tuple2);
  setOfTuples.insert(tuple3);
  setOfTuples.insert(tuple4);
  setOfTuples.insert(tuple5);
  
  // Calling print function
  print(setOfTuples);
  
  return 0;
}
Output
1 2 3
2 1 4
2 3 4
2 3 5
5 8 14
===================================================
std::tie(std::get<0>(lhs), std::get<1>(lhs), std::get<2>(lhs)) : create the tuple 
you can also compare like lhs < rhs ;//remmeber the comparision on the right hand tuple element may not be the same tuple in the left hand
side element
tuple own comparision in set?

#include <iostream>
#include <set>
#include <tuple>
#include <string>

// Define a tuple comparison function for ordering in the set
struct TupleCompare {
    bool operator()(const std::tuple<std::string, int, int>& lhs,
                    const std::tuple<std::string, int, int>& rhs) const {
        return std::tie(std::get<0>(lhs), std::get<1>(lhs), std::get<2>(lhs)) <
               std::tie(std::get<0>(rhs), std::get<1>(rhs), std::get<2>(rhs)); // you can also compare like lhs < rhs ; 
    }
};

int main() {
    // Define a set of tuples (student records)
    std::set<std::tuple<std::string, int, int>, TupleCompare> studentSet; //set will not allow you take the tuple which has the same value

    // Add student records to the set
    studentSet.insert(std::make_tuple("Alice", 20, 101));
    studentSet.insert(std::make_tuple("Bob", 22, 102));
    studentSet.insert(std::make_tuple("Carol", 21, 103));
    studentSet.insert(std::make_tuple("David", 19, 104));

    // Iterate through the set and print student records
    for (const auto& student : studentSet) {
        std::cout << "Name: " << std::get<0>(student)
                  << ", Age: " << std::get<1>(student)
                  << ", ID: " << std::get<2>(student) << std::endl;
    }

    return 0;
}

=====================================================
By default, tuples are arranged in non – descending order in the set and follows the below logic:
In the set, if the first value of two tuples is equal then the second value of tuples is compared and 
if it is also equal then the third value is compared. But it is always possible to pass a comparator to a set.
// C++ program to demonstrate the 
// implementation of set of tuples 
// by using custom comparator
#include <bits/stdc++.h>
using namespace std;
  
// Comparator for arranging elements 
// in non-ascending order We can 
// always modify the comparator as 
// per the requirement
struct cmp 
{
  bool operator()(const tuple<int, int, 
                              int>& x,
                  const tuple<int, int, 
                              int>& y)
  {
  
    if (get<0>(x) == get<0>(y))
    {
      if (get<1>(x) == get<1>(y))
        return get<2>(x) > get<2>(y);
      return get<1>(x) > get<1>(y);
    }
  
    return get<0>(x) > get<0>(y);
  }
};
  
// Function to print set elements
void print(set<tuple<int, int, 
                     int>, cmp>& setOfTuples)
{
  for (auto x : setOfTuples) 
  {
    tuple<int, int, int> tp = x;
    cout << get<0>(tp) << 
            ' ' << get<1>(tp) << 
            ' ' << get<2>(tp) << '\n';
  }
}
  
// Driver code
int main()
{
  // Declaring a set of tuples
  set<tuple<int, int, 
            int>, cmp> setOfTuples;
  
  // Initializing tuples
  tuple<int, int, 
        int> tuple1;
  tuple1 = make_tuple(1, 2, 3);
  
  tuple<int, int, 
        int> tuple2;
  tuple2 = make_tuple(2, 3, 5);
  
  tuple<int, int, 
        int> tuple3;
  tuple3 = make_tuple(2, 3, 4);
  
  tuple<int, int, 
        int> tuple4;
  tuple4 = make_tuple(2, 1, 4);
  
  tuple<int, int, 
        int> tuple5;
  tuple5 = make_tuple(5, 8, 14);
  
  // Inserting into set
  setOfTuples.insert(tuple1);
  setOfTuples.insert(tuple2);
  setOfTuples.insert(tuple3);
  setOfTuples.insert(tuple4);
  setOfTuples.insert(tuple5);
  
  // Calling print function
  print(setOfTuples);
  
  return 0;
}
Output
5 8 14
2 3 5
2 3 4
2 1 4
1 2 3
==================
header file required for pair?

std::move in map
element is pair here
===
#include <iostream>
#include <map>
#include <utility>

int main() {
    std::map<int, std::string> sourceMap;

    // Insert some elements into the source map
    sourceMap.insert({1, "One"});
    sourceMap.insert({2, "Two"});
    sourceMap.insert({3, "Three"});

    // Create a new map and move the elements from the source map
    std::map<int, std::string> destinationMap;
    for (auto&& element : sourceMap) {
        destinationMap.insert(std::move(element));
    }

    // Print the elements in the destination map
    for (const auto& pair : destinationMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    // The source map is now empty
    std::cout << "Source map size: " << sourceMap.size() << std::endl; //size is still 3 better to clear the mymap.clear after doing the move

    return 0;
}
----------------
for (auto& element : sourceMap) {
    destinationMap.insert(element);  // No need for std::move if copying is fine
}
==========================
move from the function returning the map

#include <iostream>
#include <map>
#include <utility>

std::map<int, std::string> createMap() {
    std::map<int, std::string> myMap;
    myMap.insert({1, "One"});
    myMap.insert({2, "Two"});
    myMap.insert({3, "Three"});

    return std::move(myMap);
}

int main() {
    std::map<int, std::string> resultMap = createMap(); //std::map<int, std::string> &&resultMap = createMap();

    // Print the elements in the returned map
    for (const auto& pair : resultMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}

============================
#include <iostream>

using namespace std;

#include <iostream>

class Singleton {
private:
    static Singleton* instance; // Private static member to hold the instance
    
    // Private constructor to prevent direct instantiation
    Singleton() {}
    
public:
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }
    
	~Singleton() {
		std::cout << "Singleton destroyed." << std::endl;
		// Perform cleanup operations here if needed
	}
    // Other member functions and variables
};

Singleton* Singleton::instance = nullptr; // Initialize the static member

int main() {
    Singleton* singletonObj1 = Singleton::getInstance();
    Singleton* singletonObj2 = Singleton::getInstance();
    delete singletonObj2;
    //delete singletonObj1; //double free
    // singletonObj1 and singletonObj2 will be the same instance
    // as only one instance of Singleton is created
    
    return 0;
}
=========================================
when the base class constructor is in the private section we ccannot have the derived class object.
lass Singleton {
private:
    static Singleton* instance; // Private static member to hold the instance
    

        Singleton() {}
public:
    // Private constructor to prevent direct instantiation

    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }

    
    // Other member functions and variables
};

Singleton* Singleton::instance = nullptr; // Initialize the static member

class DerivedSingleton : public Singleton {
    // Additional member functions and variables specific to DerivedSingleton
};

int main() {
    Singleton* singletonObj = Singleton::getInstance();
    DerivedSingleton obj; // error since the base class constructor is in the private

    return 0;
}
=====================================

class SingletonBase {
protected:
    SingletonBase() {}

public:
    static SingletonBase* getInstance() {
        static SingletonBase instance;
        return &instance;
    }

    virtual void someFunction() {
        std::cout << "Base Singleton class" << std::endl;
    }
};

class SingletonDerived : public SingletonBase {
private:
    SingletonDerived() {}

public:
    static SingletonDerived* getInstance() {
        static SingletonDerived instance;
        return &instance;
    }

    void someFunction() override {
        std::cout << "Derived Singleton class" << std::endl;
    }
	// SingletonBase bj; error
};
//it is not necessary to declare the static member outside the class as it local to the unction.
int main() {
    // SingletonBase bj; //error
    SingletonBase* baseObj1 = SingletonBase::getInstance();
    SingletonBase* baseObj2 = SingletonBase::getInstance();
    SingletonDerived* derivedObj1 = SingletonDerived::getInstance();
    SingletonDerived* derivedObj2 = SingletonDerived::getInstance();

    if (baseObj1 == baseObj2) {
        std::cout << "Both base objects are the same instance" << std::endl;
    }

    if (derivedObj1 == derivedObj2) {
        std::cout << "Both derived objects are the same instance" << std::endl;
    }

    baseObj1->someFunction();    // Output: "Base Singleton class"
    derivedObj1->someFunction(); // Output: "Derived Singleton class"

    return 0;
}
====
Both base objects are the same instance
Both derived objects are the same instance
Base Singleton class
Derived Singleton class
==========================================
accessing the protected function in base class?

#include <iostream>

class Base {
protected:
    Base() {
        std::cout << "Base constructor" << std::endl;
    }
    void viswa() {}
};

class Derived : public Base {
public:
    Derived():Base() {
        viswa(); //no error
        //Base(); //error.
        std::cout << "Derived constructor" << std::endl;
    }
};


int main() {
    // Base b; //error
    Derived d_in_main; //no error
    return 0;
}

===========================================
singleton design pattern to protect it from multiple threads.
header file required
mutex class initialization
type of the mutex?
how to avaoid the wastage of mutex lock?

#include <iostream>
#include <mutex>

class Singleton {
private:
    static Singleton* instance;
    static std::mutex mutex;

    Singleton() {}

public:
    static Singleton* getInstance() {
        if (instance == nullptr) {
            std::lock_guard<std::mutex> lock(mutex);  // Lock the mutex

            if (instance == nullptr) {
                instance = new Singleton();
            }
        }
        return instance;
    }

    // Other member functions and variables
};

Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mutex; 
//std::mutex Singleton::mutex(); //not allowed compiled will consider this line as function decalaration

int main() {
    Singleton* singletonObj1 = Singleton::getInstance();
    Singleton* singletonObj2 = Singleton::getInstance();

    if (singletonObj1 == singletonObj2) {
        std::cout << "Both objects are the same instance" << std::endl;
    }

    return 0;
}
======================
<arpa/inet.h> //also you will will working with ip address like ip validation , sockets
ntohl
htonl
htons
ntohs
========================
find the number of ones set
int popcount(unsigned int num) {
    int count = 0;
    while (num) {
        num &= (num - 1);  // Clear the least significant bit set
        count++;
    }
    return count;
}
========================
// Function with __fastcall calling convention
__fastcall int AddNumbers(int a, int b) { //forcing the register to store into the argument
    return a + b;
}
=================================
sizeof(void) will give the error.
=================================
g++ -std=c++11 your_file.cpp -o output_name
==================================
C++98: The original ISO/IEC 14882:1998 standard.
C++03: The minor update to C++98, reflecting the year of its publication.
=========================================
// Callee Function: addNumbers
int addNumbers(int a, int b) {
    return a + b;
}

int main()
{
//caller
addNumbers(1,2)
}
=============================
calling conversation:
// Function with cdecl calling convention
// caller is responsible 
extern "C" int __cdecl AddNumbersCdecl(int a, int b) { //left to right
    return a + b;
}

//calle responsible for cleaning
// Function with stdcall calling convention
extern "C" int __stdcall AddNumbersStdCall(int a, int b) { //left to right
    return a + b;
}


stdcall
cdecl
fastcall
thicall-- non static function
======================================
mutex declaration inside the class?

class MyClass {
private:
    std::mutex mtx;

public:
    MyClass() : mtx() { //calling defaulte mutex initialization
        // Other constructor code
    }
};
===============
std::thread t1(sharedFunction); //not as std::thread t1(&sharedFunction);
============================
mutex declaration in the main?

#include <iostream>
#include <mutex>

int main() {
    std::mutex mtx; // Correctly declares and initializes the mutex

    // Your code here

    return 0;
}
==========================
MyClass(): y(10), x(y + 10) { //x= 10; y =20;
{
}
#include <intrin.h>  // Include this header for __popcnt
unsigned int num = 15;  // Binary representation: 1111
int count = __popcnt(num);
=======================
unsigned int num = 15;  // Binary representation: 1111
int count = __builtin_popcount(num);
================================
nm -g my_executable //list the global symbol
nm -C -f my_executable //Display all symbols, demangle C++ names, and show the filename:

C++ 11 introduced lambda expressions to allow inline functions which can be used for short snippets of code that are
 not going to be reused and therefore do not require a name. In their simplest form a lambda expression can be defined 
 as follows: 

[ capture clause ] (parameters) -> return-type  
{   
   definition of method   
} 
=====================
global variable and  global/local static variable are stored in bss (uninitialized)
global variable and  global/local static variable are stored in data segment (initialized)
local initialized or unitialized variable are stored in stack.
==================================
//     We can also access function by storing this into variable
auto square = [](int i)
{
	return i * i;
};

cout << "Square of 5 is : " << square(5) << endl; //25
===
int i =5;
[](int i) //not necessary to store the lamda function into the variable.
{
	return i * i; //25
};

=============================
unique:
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = {1, 2, 2, 3, 4, 4, 5, 5, 5, 6};
    
    // Use std::unique to reorder elements and remove duplicates
    std::vector<int>::iterator newEnd = std::unique(numbers.begin(), numbers.end()); // newend will point to 5 5 5 6
       // Erase the duplicate elements from the vector
    numbers.erase(newEnd, numbers.end()); //remove the element 5 5 6

    // Print the unique elements
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}

======================================
using lamda
first the first element that matches the condtition in vector?
total number of element matches the condition
store only the uniquw
sort 

// C++ program to demonstrate lambda expression in C++
#include <bits/stdc++.h>
using namespace std;
 
// Function to print vector
void printVector(vector<int> v)
{
    // lambda expression to print vector
    for_each(v.begin(), v.end(), [](int i)
    {
        std::cout << i << " ";
    });
    cout << endl;
}
 
int main()
{
    vector<int> v {4, 1, 3, 5, 2, 3, 1, 7};
 
    printVector(v);
 
    // below snippet find first number greater than 4
    // find_if searches for an element for which
    // function(third argument) returns true
    vector<int>:: iterator p = find_if(v.begin(), v.end(), [](int i)
    {
        return i > 4;
    });
    cout << "First number greater than 4 is : " << *p << endl;
 
 
    // function to sort vector, lambda expression is for sorting in
    // non-increasing order Compiler can make out return type as
    // bool, but shown here just for explanation
    sort(v.begin(), v.end(), [](const int& a, const int& b) -> bool
    {
        return a > b;
    });
 
    printVector(v);
 
    // function to count numbers greater than or equal to 5
    int count_5 = count_if(v.begin(), v.end(), [](int a)
    {
        return (a >= 5);
    });
    cout << "The number of elements greater than or equal to 5 is : "
         << count_5 << endl;
 
    // function for removing duplicate element (after sorting all
    // duplicate comes together)
    p = unique(v.begin(), v.end(), [](int a, int b)
    {
        return a == b;
    });
==================================================================
lamda function to sort the vector?
lamda function to print all the lements?

	#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = {5, 2, 7, 4, 1, 9};

    // Using a lambda expression to sort the numbers in ascending order
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) {
        return a < b;
    });

    // Using a lambda expression to print each number
    std::cout << "Sorted numbers: ";
    std::for_each(numbers.begin(), numbers.end(), [](int num) {
        std::cout << num << " ";
    });
    std::cout << std::endl;

    return 0;
}
===========
Sorted numbers: 1 2 4 5 7 9 
===============\
lamda to multiply the numbers?
how to specify the return type in lamda function?


In C++11, you can specify the return type of a lambda expression using the trailing return type syntax.
//Explicitly declaring the return type
#include <iostream>

int main() {
    // Lambda expression with return type int
    auto multiply = [](int a, int b) -> int { //it will also work auto multiply = [](int a, int b) {
        return a * b;
    };

    int result = multiply(5, 3);
    std::cout << "Result: " << result << std::endl;

    return 0;
}
//15
================
constexpression for function:
In C++11, a constexpr expression is used to define a constant expression, which is evaluated at compile-time. 
It allows you to specify that a value or function can be evaluated and used in a constant expression context. 
#include <iostream>

constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}

int main() {
    constexpr int value = 5;
    constexpr int result = factorial(value);

    std::cout << "Factorial of " << value << " is: " << result << std::endl;

    return 0;
}
=====
Factorial of 5 is: 120
=====================
constexpr for class object 
how the class member variable?


#include <iostream>

class MyClass {
public:
    constexpr MyClass(int value) : constantValue(value) {}

    constexpr int getConstantValue() const {
        return constantValue;
    }

private:
    const int constantValue;
};

int main() {
    constexpr MyClass myObject(42);

    std::cout << "Constant value: " << myObject.getConstantValue() << std::endl; //42

    return 0;
}
=======
===================================================================================
Static: By declaring the variable as static, it becomes associated with the class rather than with individual 
instances of the class. It means that there is only one instance of the variable shared among all objects of the class.
 This allows accessing the variable without creating an instance of the class.

Constexpr: By declaring the variable as constexpr, it indicates that the variable is a constant expression and can be
 evaluated at compile-time. The value of a constexpr variable must be known at compile-time and cannot be changed.

Combining static and constexpr allows the variable to be a compile-time constant that is shared among all instances 
of the class.
=====================================================================================
#include <iostream>

class MyClass {
public:
    static constexpr int constantValue = 42; // if the variable is constexpr we an initialize 
	//const variable can also be initialized like above
	//static const or static constexpr variable needn't be declared outside the class
	// only static variable can be constexpr

    static int getValue() {
        return constantValue;
    }
};

int main() {
    std::cout << "Constant value: " << MyClass::getValue() << std::endl;

    return 0;
}
=============
In C++11 and later versions, member variables can be initialized directly inside the class declaration if they are const or
 static const integral types. This feature is known as "in-class member initialization" or "non-static data member initialization."

The motivation behind allowing member variable initialization inside the class declaration is to provide a convenient and 
concise way to specify default values for member variables. It allows you to initialize the member variables directly at their 
declaration,
 without the need for a separate constructor or initialization list.
 
 #include <iostream>

class MyClass {
public:
    int x = 42;  // In-class member initialization //only static member cannot be initialized like this ie static int a = 10;

    void printValue() {
        std::cout << "Value of x: " << x << std::endl;
    }
};

int main() {
    MyClass obj;
    obj.printValue();

    return 0;
}
===========
override example
override with default example?
class derived from 2 base class and having the override?

he override keyword in C++ is used to explicitly indicate that a member function in a derived class is intended
 to override a virtual function from its base class. It helps improve code readability and serves as a form of documentation.
 
 class Base {
public:
    virtual void printMessage() { 
        //if this function is not there in the base then the override keyword will complain
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void printMessage() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Derived derived;
    Base* basePtr = &derived;

    basePtr->printMessage();

    return 0;
}
=====
Derived class
=========================
 class Base {
public:
    virtual void printMessage(int y=12) { 
        //if this function is not there in the base then the override keyword will complain
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void printMessage(int q=100) override {
        std::cout << "Derived class" << std::endl;
    }
};
===============================================
#include <iostream>

class Base {
public:
    virtual void printMessage1() { 
        //if this function is not there in the base then the override keyword will complain
        std::cout << "Base class" << std::endl;
    }
};

class Base1 {
public:
    virtual void printMessage() { 
        //if this function is not there in the base then the override keyword will complain
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base, public Base1 { 
    //function should be available in any one of the base class
public:
    void printMessage() override {
        std::cout << "Derived class" << std::endl;
    }
};


int main() {
    Derived derived;
    Base* basePtr = &derived;

    basePtr->printMessage1();

    return 0;
}
===base class=====================================
===================================================
g++ -std=c++11 -o output.out source.cpp ==> c+11 compilation
==================================================
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

void print_square(int i)
{
    cout << i * i << endl;
}

int main()
{
    vector<int> v = {1, 2, 3, 4, 5}; // Populate the vector with values

    for_each(v.begin(), v.end(), print_square);

    return 0;
}
//1 4 9 16 25
==================================
he final keyword in C++ is used to indicate that a class, member function, or virtual function cannot be overridden or
 inherited by derived classes. 
It provides a way to enforce the immutability or non-inheritability of certain elements in your code.
#include <iostream>

class Base {
public:
    virtual void printMessage() {
        std::cout << "Base class" << std::endl;
    }

    virtual void someFunction() final {
        std::cout << "Base::someFunction" << std::endl;
    }
};

class Derived : public Base {
public:
    void printMessage() override {
        std::cout << "Derived class" << std::endl;
    }

    // Trying to override Base::someFunction will cause a compilation error
    // void someFunction() override { } // Uncommenting this line will result in an error
};

int main() {
    Derived derived;
    Base* basePtr = &derived;

    basePtr->printMessage();
    basePtr->someFunction();

    return 0;
}
===================
overloading the template function with normal function

#include <iostream>

// Template function without arguments
template <typename T> //this line is not must
void myFunction() {
    std::cout << "Template function without arguments" << std::endl;
}

// Template function with arguments
template <typename T>
void myFunction(T value) {
    std::cout << "Template function with argument: " << value << std::endl;
}

int main() {
    myFunction();         // Calls the version without arguments
    myFunction(42);       // Calls the version with argument

    return 0;
}

========================================
fibanacis series:
int main()
{
    int n = 0;
    cout << "Enter the number of terms: ";
    cin >> n;

    if (n < 0) {
        cout << "Invalid input. Number of terms should be non-negative." << endl;
        return 1;
    }

    cout << "Fibonacci series up to " << n << " terms: ";

    if (n >= 1)
        cout << "0 ";

    int a = 0, b = 1;
    for (int i = 1; i < n; i++)
    {
        cout << b << " ";

        int sum = a + b;
        a = b;
        b = sum;
    }

    return 0;
}
5
0  1 2 3 5

time complexity 0(5)
space complexity o(1)
 You are correct that there are additional variables used in the program, namely i, n, a, b, and sum, in addition to the input value n. 
 So, the space complexity should be O(1), not O(5).
======================
in the below program the space and time complexity is O(n) and not 0(10000)naming syn
include <iostream>
#include <vector>
using namespace std;

void createVector(int n) {
    vector<int> v;
    for (int i = 0; i < n; i++) {
        v.push_back(i);
    }
}

int main() {
    int n = 10000;
    createVector(n);
    return 0;
}
=========================
notation for class and function
return type for setter

class name should be capital letter
function first letter should be small
include <iostream>
using namespace std;

class Rectangle
{
private:
    double length = 0, width = 0;

public:
    bool setMeasurements(double _length, double _width)
    {
        bool status = false;
        if (_length <= 0 || _width <= 0)
        {
            cout << "Wrong input." << endl;
            return status;
        }
        length = _length;
        width = _width;
        status = true;
        return status;
    }

    double getPerimeter()
    {
        return 2 * (width + length);
    }

    double getArea()
    {
        return width * length;
    }
};

int main()
{
    Rectangle obj;
    if (obj.setMeasurements(10, 10))
    {
        cout << "Perimeter: " << obj.getPerimeter() << endl;
        cout << "Area: " << obj.getArea() << endl;
    }
    return 0;
}
================================
write the content to the file and read it backk;

#include <iostream>
#include <fstream>
#include <string>
using namespace std;
int main(){
   fstream newfile;
   newfile.open("tpoint.txt",ios::out);  // open a file to perform write operation using file object
   if(newfile.is_open()) //checking whether the file is open {
      newfile<<"Tutorials point \n"; //inserting text
      newfile.close(); //close the file object
   }
   newfile.open("tpoint.txt",ios::in); //open a file to perform read operation using file object
   if (newfile.is_open()){ //checking whether the file is open
      string tp;
      while(getline(newfile, tp)){ //read data from file object and put it into string.
         cout << tp << "\n"; //print the data of the string
      }
      newfile.close(); //close the file object.
   }
}
====================
header file required istringstream hash map, cerr?

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <unordered_map>

int main()
{
    std::ifstream inputFile("input.txt");
    if (!inputFile)
    {
        std::cerr << "Failed to open input file." << std::endl;
        return 1;
    }

    std::unordered_map<std::string, int> wordCount;

    std::string line;
    while (std::getline(inputFile, line))
    {
        std::istringstream iss(line);
        std::string word;
        while (iss >> word)
        {
            ++wordCount[word];
        }
    }

    for (const auto& pair : wordCount)
    {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
=============
For each line, it uses an istringstream to tokenize the line into individual words. It then increments the count for each word 
in the wordCount map.
===============================
write data to a file:
include <fstream>
using namespace std;

int main() {
    ofstream outputFile;
    outputFile.open("filename.txt");

    if (!outputFile) {
        cout << "Failed to open the file." << endl;
        return 1;
    }

    string data = "Hello, World!";
    outputFile << data;

    outputFile.close();
    return 0;
}
=================================
read data:
#include <fstream>
using namespace std;

int main() {
    ifstream inputFile;
    inputFile.open("filename.txt");

    if (!inputFile) {
        cout << "Failed to open the file." << endl;
        return 1;
    }

    int num;
    while (inputFile >> num) {
        cout << num << " ";
    }

    inputFile.close();
    return 0;
}
====================
different way to open the file?

append the file:

#include <fstream>
using namespace std;

int main() {
    ofstream outputFile;
    outputFile.open("example.cpp", ios::out | ios::app);

    if (!outputFile) {
        cout << "Failed to open the file." << endl;
        return 1;
    }

    outputFile << "// New code added." << endl;
    outputFile << "int main() {" << endl;
    outputFile << "\tcout << \"Hello, World!\" << endl;" << endl;
    outputFile << "\treturn 0;" << endl;
    outputFile << "}" << endl;

    outputFile.close();
    return 0;
}
========================
find and replace the workd in the file:
#include <iostream>
#include <fstream>
#include <string>

void findAndReplace(std::string& line, const std::string& findWord, const std::string& replaceWord) {
    size_t pos = line.find(findWord);
    while (pos != std::string::npos) {
        line.replace(pos, findWord.length(), replaceWord);
        pos = line.find(findWord, pos + replaceWord.length());
    }
}

int main() {
    std::string inputFilename = "input.txt";
    std::string outputFilename = "output.txt";
    std::string findWord = "old";
    std::string replaceWord = "new";

    std::ifstream inputFile(inputFilename);
    if (!inputFile) {
        std::cout << "Failed to open the input file." << std::endl;
        return 1;
    }

    std::ofstream outputFile(outputFilename);
    if (!outputFile) {
        std::cout << "Failed to create the output file." << std::endl;
        return 1;
    }

    std::string line;
    while (std::getline(inputFile, line)) {
        findAndReplace(line, findWord, replaceWord);
        outputFile << line << std::endl;
    }

    inputFile.close();
    outputFile.close();

    std::cout << "Find and replace completed. Output file: " << outputFilename << std::endl;

    return 0;
}
=====================================================
string length and size: will return the number of character
size(): This method returns the number of characters in the string. It's equivalent to the length() method. 
The terms "size" and "length" are used interchangeably for strings.
std::string myString = "Hello, World!";
int size = myString.size();  // Returns 13
==================================================
this line replae only the first line content
hi viswa.im good
how are you?
hi
output: 
hi viswa.im good
hi viswanathan. im good.
proram ends.
========
void findAndReplace(std::string& line, const std::string& findWord, const std::string& replaceWord) {
    size_t pos = line.find(findWord);
    while (pos != std::string::npos) {
        line.replace(pos, findWord.length(), replaceWord);
        pos = line.find(findWord, pos + replaceWord.length());
    }
}

int main() {
    std::string filename = "file.txt";
    std::string findWord = "viswa";
    std::string replaceWord = "viswanathan";

    std::fstream file(filename, std::ios::in | std::ios::out);
    if (!file) {
        std::cout << "Failed to open the file." << std::endl;
        return 1;
    }

    std::string line;
    while (std::getline(file, line)) {
        findAndReplace(line, findWord, replaceWord);
        file << line << std::endl;
    }

    file.close();

    std::cout << "Find and replace completed in the same file." << std::endl;

    return 0;
}
====
when you want to read and write into the same file in the middle of the content use 2 file. one ffo reading and one for writing.

====================================
TDD stands for Test-Driven Development. It is a software development practice where tests are written before the actual implementation 
code. The development process in TDD typically follows these steps:

Write a test: Start by writing a test that describes the desired behavior of a small piece of code.
Run the test: Execute the test and ensure that it fails, indicating that the desired behavior is not yet implemented.
Write the implementation: Create the simplest possible code that makes the test pass.
Run all tests: Execute all the tests, including the one you just wrote, to ensure that the new code did not break any existing functionality.
Refactor: Clean up the code, improving its design without changing its behavior.
Repeat: Go back to step 1 and continue the cycle by writing the next test for the next piece of functionality.
Here's an example of TDD in C++ using a simple "Calculator" class that performs addition:

cpp

// calculator.h
class Calculator {
public:
    int add(int a, int b);
};

// calculator.cpp
int Calculator::add(int a, int b) {
    return a + b;
}

// test_calculator.cpp
#include "calculator.h"
#include <cassert>

int main() {
    Calculator calculator;

    // Test 1: Addition of positive numbers
    assert(calculator.add(2, 3) == 5);

    // Test 2: Addition of negative numbers
    assert(calculator.add(-2, -3) == -5);

    // Test 3: Addition of zero
    assert(calculator.add(0, 5) == 5);

    // Test 4: Addition of positive and negative numbers
    assert(calculator.add(10, -5) == 5);

    // All tests passed
    return 0;
}
=====================
reverse the string
Time complexity o(n) and o(1)
#include <iostream>
#include <string>

std::string reverseString(const std::string& str) {
    std::string reversed;
    for (int i = str.length() - 1; i >= 0; i--) {
        reversed += str[i];
    }
    return reversed;
}

int main() {
    std::string input = "Hello, World!";
    std::string reversed = reverseString(input);
    std::cout << reversed << std::endl;
    return 0;
}
================================
Find the Maximum Number: Write a function that takes an array of integers and returns the maximum number.//or you can use stl max_element()
cpp

#include <iostream>
#include <vector>
#include <algorithm>

int findMax(const std::vector<int>& numbers) {
    int maxNumber = numbers[0];
    for (int i = 1; i < numbers.size(); i++) {
        if (numbers[i] > maxNumber) {
            maxNumber = numbers[i];
        }
    }
    return maxNumber;
}

int main() {
    std::vector<int> numbers = {5, 9, 2, 11, 3, 8};
    int max = findMax(numbers);
    std::cout << "Maximum number: " << max << std::endl;
    return 0;
}
====================================================
Check for Palindrome: Write a function that takes a string as input and returns true if it is a palindrome (reads the same forwards 
and backwards), and false otherwise.cpp

#include <iostream>
#include <string>
#include <algorithm>

bool isPalindrome(const std::string& str) {
    std::string reversed = str;
    std::reverse(reversed.begin(), reversed.end());
    return str == reversed;
}

int main() {
    std::string input = "madam";
    bool palindrome = isPalindrome(input);
    std::cout << std::boolalpha << palindrome << std::endl;
    return 0;
}

User
why space complexity is O(n) here
ChatGPT
Apologies for the confusion. The space complexity of the "reverseString" program is actually O(1), not O(n).

In the program, a new string, "reversed," is constructed by appending characters one by one. However, the space used for the "reversed" 
string does not depend on the size of the input string. Instead, it depends on the constant amount of additional space required to store
the reversed string while iterating over the input string.

Since the space used remains constant regardless of the input size, the space complexity is considered O(1), or constant space complexity.

======================
palindrome : time complexity is 0(n) and space complexity o(1)
#include <iostream>
#include <string>
#include <algorithm>

bool isPalindrome(const std::string& str) {
    std::string reversed = str;
    std::reverse(reversed.begin(), reversed.end());
    return str == reversed;
}

int main() {
    std::string input = "madam";
    bool palindrome = isPalindrome(input);
    std::cout << std::boolalpha << palindrome << std::endl;
    return 0;
}
in polindrome program the time complexity needs to o(n/2)+o(n)
o(n/2) for reversing the string
o(n) comparision. 
ChatGPT
You are correct, my apologies for the oversight. The correct time complexity for the palindrome program should be O(n/2) + O(n), 
which simplifies to O(n).

The program first uses the std::reverse function to create a reversed version of the input string. Since it 
only needs to iterate over half of the characters, the time complexity for this step is O(n/2).

Then, the program compares each character of the original string with the corresponding character in the reversed string.
 This comparison requires iterating over 
each character once, resulting in a time complexity of O(n).

When we consider both steps, the dominant factor is the O(n) comparison. The O(n/2) term becomes insignificant 
compared to O(n) in terms of complexity, so we can simplify the overall time complexity to O(n).
===========================================
array iterator

#include <iostream>
#include <array>

int main() {
    std::array<int, 5> myArray = {1, 2, 3, 4, 5};

    // Using iterators returned by begin() and end() to iterate through the array
    for (std::array<int, 5>::iterator it = myArray.begin(); it != myArray.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}

============================================
include <iostream>
#include <vector>

int findSecondLargest(const std::vector<int>& numbers) {
    int largest = INT_MIN;
    int secondLargest = INT_MIN;

    for (int i = 0; i < numbers.size(); i++) {
        if (numbers[i] > largest) {
            secondLargest = largest;
            largest = numbers[i];
        } else if (numbers[i] > secondLargest && numbers[i] < largest) {
            secondLargest = numbers[i];
        }
    }

    return secondLargest;
}

int main() {
    std::vector<int> numbers = {5, 9, 2, 11, 3, 8};
    int secondLargest = findSecondLargest(numbers);
    std::cout << "Second largest number: " << secondLargest << std::endl;
    return 0;
}
The time complexity of this approach is O(n) since it requires iterating through the entire array once. The space complexity 
is O(1) since it only uses a constant amount of additional space to store the largest and second-largest numbers.
===================
variadic template introduced in c++?
Variadic templates allow the creation of functions or classes that can accept a variable number of template arguments.
Certainly! Variadic templates in C++ allow you to create functions or classes that can accept a variable number of template arguments.
 Here's an example demonstrating the usage of variadic templates:

cpp

#include <iostream>

// Base case for the recursive variadic template function
void printValues() {
    std::cout << "All values printed." << std::endl;
}

// Recursive variadic template function to print multiple values
template<typename T, typename... Args>
void printValues(T value, Args... args) {
    std::cout << value << std::endl;
    printValues(args...); // Recursive call with remaining arguments
}

int main() {
    printValues(1, 2.5, "Hello", 'c');

    return 0;
}

===
1
2.5
Hello
c
All values printed
==========================================
convert number to string and viceversa to_string(int/float)
std::stoi, std::stol, std::stoll (for integers):
std::string str = "42";
    int num = std::stoi(str);  // Convert string to integer to_string
==============================
// Template class specialization
template <>
class MyTemplateClass<std::string> {

normal template class should not have
template <typename T>
class MyTemplateClass<T> 
==================================
verdiac template class in constructor? to print all the elements?

base case, as it doesn't need template arguments
<T, Args...> this needed when we have the class with <typename... Args>

#include <iostream>

// Base case for the recursive variadic template class
//base case, as it doesn't need template arguments
template <typename... Args>
class VariadicClass {};

// Recursive variadic template class with specialized versions
template <typename T, typename... Args>
class VariadicClass<T, Args...> {
public:
    VariadicClass(T value, Args... args) {
        std::cout << "Value: " << value << std::endl;
        VariadicClass<Args...>(args...); // Recursive call with remaining arguments
    }
};

int main() {
    VariadicClass<int, double, const char*> obj(42, 3.14, "Hello");

    return 0;
}
===
Value: 42
Value: 3.14
Value: Hello
==============================================
number of template instatiation?
Tuple<int, double, std::string>
Tuple<double, std::string>
Tuplestd::string
Tuple<> is required as the las call will be Tuple< > next
Tuple<> does not contribute to additional instances, as it doesn't hold any data and is meant to 
serve as a termination point for the recursion.

#include <iostream>
#include <string>

template <typename T, typename... Types>
class Tuple {
private:
    T value;
    Tuple<Types...> next;

public:
    Tuple(T val, Types... args) : value(val), next(args...) {}

    T getValue() const {
        return value;
    }

    void printValues() const {
        std::cout << value << std::endl;
        next.printValues();
    }
};

// Base case for the recursive variadic template class
template <>
class Tuple<> {
public:
    void printValues() const {}
};

int main() {
    Tuple<int, double, std::string> tuple(42, 3.14, "Hello");
    std::cout << tuple.getValue() << std::endl; // 42
    tuple.printValues();

    return 0;
}

===============================================
#include <iostream>

// Base case for the recursive variadic template class
template <typename... Types>
class Tuple {};

// Recursive variadic template class with specialized versions
template <typename T, typename... Types>
class Tuple<T, Types...> : public Tuple<Types...> {
private:
    T value;

public:
    Tuple(T val, Types... args) : Tuple<Types...>(args...), value(val) {}

    T getValue() const {
        return value;
    }

    void printValues() const {
        std::cout << value << std::endl;
        Tuple<Types...>::printValues();
    }
};

// Base case specialization for the printValues() function
template <>
class Tuple<> {
public:
    void printValues() const {}
};

int main() {
    Tuple<int, double, std::string> tuple(42, 3.14, "Hello");
    cout << tuple.getValue() <<std::endl; //42
    tuple.printValues();

    return 0;
}
=================================
42
42
3.14
Hello
====================================
different ways to insert theelement into the apir?

#include <iostream>
#include <utility>

int main() {
    std::pair<int, double> myPair = std::make_pair(42, 3.14);
    // or
    // std::pair<int, double> myPair(42, 3.14);
    
    std::cout << "First: " << myPair.first << ", Second: " << myPair.second << std::endl;
    
    return 0;
}
==================================
no there is no way to check with the pair is initialized?
std::pair does not have begin() and end() member functions like those used with containers (e.g., std::vector, std::map). 
Pairs are simple data structures that hold two values, and they don't provide iterator-based access like containers do.

pair is uses template structure which has two variable for different data type determined by the template argument.
we can initialize the variable inside teh structure. in-class member initialization.
template <typename t1, typename t2>
struct s 
{
   t1 key;
   t2 value;
}
using custom flag;
#include <iostream>
#include <utility>

struct InitializedPair {
    std::pair<int, double> data;
    bool initialized = false;
};

int main() {
    InitializedPair myInitializedPair;
    // ...
    if (myInitializedPair.initialized) {
        std::cout << "Pair is properly initialized." << std::endl;
    } else {
        std::cout << "Pair is not initialized." << std::endl;
    }
    
    return 0;
}
============
C++17 way of checking?

#include <iostream>
#include <utility>
#include <optional>

int main() {
    std::optional<std::pair<int, double>> myOptionalPair;
	// Assign a value to the optional pair
    myOptionalPair = std::make_pair(42, 3.14);
    // ...
    if (myOptionalPair) { //(myOptionalPair.has_value())
        std::cout << "Pair is properly initialized." << std::endl;
    } else {
        std::cout << "Pair is not initialized." << std::endl;
    }
    
    return 0;
}
==============================================
#include <stdio.h>
#include <stdint.h>

int main() {
    uint32_t value = 42;
    uint32_t *ptr = &value;

    printf("Value: %u\n", *ptr);

    return 0;
}
=================================================

#include <iostream>
#include <utility>

struct InitializedPair {
    std::pair<int, double> data;
    bool initialized = false;
};

int main() {
    InitializedPair myInitializedPair;
    // ...
    if (myInitializedPair.initialized) {
        std::cout << "Pair is properly initialized." << std::endl;
    } else {
        std::cout << "Pair is not initialized." << std::endl;
    }
    
    return 0;
}

=================================================
template taking the function pointer as the first argument
#include <iostream>

template <typename Func, typename... Args>
auto invokeFunction(Func funcPtr, Args... args) -> decltype(funcPtr(args...)) {
    return funcPtr(args...);
}

int main() {
    int result = invokeFunction(add, 2, 3);

    std::cout << "Result: " << result << std::endl; // Output: 5

    return 0;
}

====================================================
template taking the return type as the first argument?

#include <iostream>

// Base case for the recursive variadic template function
template<typename ReturnType, typename... Args>
ReturnType invokeFunction(ReturnType(*funcPtr)(Args...), Args... args) {
    return funcPtr(args...);
}

// Example function to be invoked
int add(int a, int b) {
    return a + b;
}

int main() {
    int result = invokeFunction(add, 2, 3);

    std::cout << "Result: " << result << std::endl; // Output: 5

    return 0;
}
In this example, we define a variadic template function called invokeFunction. The base case handles the situation when no more arguments are
 provided, and it directly invokes the function pointer funcPtr with the given arguments.

The recursive case takes the function pointer funcPtr, the first argument arg, and a variadic pack of arguments Args.... It recursively calls 
invokeFunction with the remaining arguments, effectively forwarding the arguments to the function pointer.

In the main() function, we define an add function that takes two integers and returns their sum. Then, we use the invokeFunction template function to invoke the add function with arguments 2 and 3.

The resulting sum is stored in the result variable, which is then printed to the console.

When you run the code, it will output:

makefile

Result: 5
This example demonstrates how a variadic template function can be used to invoke a function with a flexible number 
of arguments. It allows you to call functions dynamically by passing in the function pointer and the required arguments.
=======================================================================
template to add the numbers without the function
template<typename T>
T adder(T v) {
  return v;
}

template<typename T, typename... Args>
T adder(T first, Args... args) {
  return first + adder(args...);
}

int main() {
    std::cout << adder(1, 2);

    return 0;
}

1+2
====
int adder() {
  return 0;
}

template<typename T, typename... Args>
T adder(T first, Args... args) {
  return first + adder(args...);
}

int main() {
    std::cout << adder(1, 2);

    return 0;
}

1+2+adder()
============================================================================================================
initializing the set during the declaration:
loop over the set?
difference between set and unordered_set?


In C++, both std::unordered_set and std::set (commonly referred to as ordered set) are containers used to store unique elements.
std::unordered_set use hash table
std::set uses the red and black tree:It provides efficient search, insertion, and deletion operations
 with a complexity of O(log n).
#include <iostream>
#include <unordered_set>
#include <set>

int main() {
    // Example using unordered_set
    std::unordered_set<int> unorderedSet = {5, 3, 1, 4, 2};

    std::cout << "Elements in unordered_set: ";
    for (const auto& element : unorderedSet) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    // Output: Elements in unordered_set: 1 2 3 4 5 (order may vary)

    // Example using set
    std::set<int> orderedSet = {5, 3, 1, 4, 2};

    std::cout << "Elements in ordered_set: ";
    for (const auto& element : orderedSet) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    // Output: Elements in ordered_set: 1 2 3 4 5 (always sorted)

    return 0;
}====

insert into the set using only one element?

#include <iostream>
#include <unordered_set>
#include <algorithm>
int main() {
    // Creating an Unoredered_set of type string
    std::unordered_set<std::string> setOfStrs;
    // Insert strings to the set
    setOfStrs.insert("First");
    setOfStrs.insert("second");
    setOfStrs.insert("third");
    // Try to Insert a duplicate string in set
    setOfStrs.insert("second"); //duplicate element will not be addded
    // Iterate Over the Unordered Set and display it
    for (std::string s : setOfStrs)
        std::cout << s << std::endl;
}
Output:

third
second
First
==============================
initializing the set with array:

// Array of int
int arr[] = {2,4,6,1,3,6,8,3,2};
// Create an unoredered set and initialize it with the array
// Set will contain only unique elements
std::unordered_set<int> setOfNum(arr, arr + sizeof(arr)/sizeof(int));
Above set will contain only unique elements from array and store them in arbitrary order.
============================
initializing the set with array of elements:
// Create an unoredered set and initialize it initializer_list
std::unordered_set<int> setOfNum2({1,2,3,1,3,4,2});
===============================
initializing the set with vector:
std::vector<int> vec({14,5,6,7});
// Create an unoredered set and initialize it with vector
std::unordered_set<int> setOfNum3(vec.begin(), vec.end());
===============================
How to check whether the insertion is successful or failed in set?
insertion from vector, array of elements, single element?
iterate over the set?

#include <iostream>
#include <unordered_set>
#include <algorithm>
int main() {
    // Creating an unoredered_set of int
    std::unordered_set<int> setOfNum;
    // Inserting few elements in set
    setOfNum.insert(2);
    setOfNum.insert(6);
    setOfNum.insert(1);
    // Declare a pair of iterator and bool flag
    std::pair<std::unordered_set<int>::iterator, bool> result;
    // Try to insert a Duplicate Element, it will return a
    // a pair of iterator and bool
    result = setOfNum.insert(6);
    // Check if element inserted or not
    if (result.second == false)
        std::cout << "Failed to Insert 6" << std::endl;
    // Try to insert a another Element, it will return a
    // a pair of iterator and bool
    result = setOfNum.insert(7);
    if (result.second)
        std::cout << "Successfully Inserted 7" << std::endl;
    // Iterate over the set and display contents
    for (int val : setOfNum)
        std::cout << val << ", ";
    std::cout << std::endl;
	
    //Create an another vector of ints
    std::vector<int> vec( { 3, 4, 1, 2, 9, 1, 3, 4, 5, 6 });
    // Insert the contents of a vector in existing unoordered set
    setOfNum.insert(vec.begin(), vec.end());
    // Iterate over the set and display contents
    for (int val : setOfNum)
        std::cout << val << ", ";
    std::cout << std::endl;
	
    // Insert an initializer_list in existing  unordered set
    setOfNum.insert( { 2, 3, 6, 2, 15, 17, 11 });
    // Iterate over the set and display contents
    for (int val : setOfNum)
        std::cout << val << ", ";
    std::cout << std::endl;
}
Output:

Failed to Insert 6
Successfully Inserted 7
7, 1, 6, 2, 
5, 9, 4, 3, 2, 6, 1, 7, 
11, 17, 15, 5, 9, 4, 3, 2, 6, 1, 7,
===============================================
to find the element in the set?
important in iterator?
const_iterator can point to another find also?

#include <iostream>
#include <unordered_set>
#include <algorithm>
int main() {
    // Create an unordered set and initialize it initializer_list
    std::unordered_set<int> setOfNum( { 1, 2, 3, 1, 3, 4, 2 });
    std::unordered_set<int>::const_iterator it = setOfNum.find(4);
    if (it != setOfNum.end()) {
        std::cout << "4 exist in the set" << std::endl;
    }
    it = setOfNum.find(9);
    if (it == setOfNum.end()) {
        std::cout << "9 dont exist in the set" << std::endl;
    }
}
In the above example we tried to search for the 2 elements in set, one was present and other was not.

Ouput:

4 exist in the set
9 dont exist in the set
=====================================
loop over the elements of the vector and modifying the value of the elements in vector?
using const_iterator?

include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    // Using iterator to modify elements
    for (std::vector<int>::iterator it = numbers.begin(); it != numbers.end(); ++it) {
        *it *= 2;  // Modify the element
    }

    std::cout << "Modified elements using iterator: ";
    for (const auto& num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    // Output: Modified elements using iterator: 2 4 6 8 10

    // Using const_iterator for read-only access
    std::cout << "Elements using const_iterator: ";
    for (std::vector<int>::const_iterator cit = numbers.cbegin(); cit != numbers.cend(); ++cit) {
        // *cit *= 2;  // Compilation error: Cannot modify the element using const_iterator
        std::cout << *cit << " ";
    }
    std::cout << std::endl;
    // Output: Elements using const_iterator: 2 4 6 8 10

    return 0;
}

==============================
unordered_set using class object?
finding the object in inordered_set?

#include <iostream>
#include <unordered_set>
#include <string>

// Custom user-defined type
class Person {
public:
    std::string name;
    int age;

    Person(const std::string& n, int a) : name(n), age(a) {}

    // Define the equality operator for comparing Person objects
    bool operator==(const Person& other) const {
        return (name == other.name) && (age == other.age);
    }
};

// Custom hash function for Person objects
struct PersonHash {
    std::size_t operator()(const Person& p) const {
        // Combine the hash values of name and age
        return std::hash<std::string>()(p.name) ^ std::hash<int>()(p.age);
    }
};

int main() {
    // Create an unordered_set of Person objects using the custom hash and equality functions
    std::unordered_set<Person, PersonHash> people;

    // Add Person objects to the unordered_set
    people.insert(Person("Alice", 25));
    people.insert(Person("Bob", 30));
    people.insert(Person("Charlie", 20));

    // Check if a Person object is in the unordered_set
    Person searchPerson("Bob", 30);
    auto it = people.find(searchPerson);
    if (it != people.end()) {
        std::cout << "Person found: " << it->name << ", " << it->age << std::endl;
    } else {
        std::cout << "Person not found" << std::endl;
    }

    return 0;
}
///person found bob 30
==================
unordered map also uses hash
uordered_map will not allow the duplicate
inserting into theunordered_map and loop over it

#include <iostream>
#include <unordered_map>
#include <string>
int main()
{
    // Create an empty unordered_map
    std::unordered_map<std::string, int> wordMap;
    // Insert Few elements in map
    wordMap.insert( { "First", 1 });
    wordMap.insert(    { "Second", 2 });
    wordMap.insert(    { "Third", 3 });
    // Overwrite value of an element
    wordMap["Third"] = 8;
	wordMap.insert(    { "Second", 21 }); //this element will not be inserted
    // Iterate Over the unordered_map and display elements
    for (std::pair<std::string, int> element : wordMap)
        std::cout << element.first << " :: " << element.second << std::endl;
    return 0;
}
Output:

Third :: 8
Second :: 2
First :: 1

=============
3 different way of inserting into the map:

#include <iostream>
#include <unordered_map>
#include <string>
int main()
{
    // Initialize an unordered_map through initializer_list
    std::unordered_map<std::string, int> wordMap(
    {
    { "First", 1 },
    { "Second", 2 },
    { "Third", 3 } 
	});
	
    // Iterate over an unordered_map and display elements
    for (std::pair<std::string, int> element : wordMap)
        std::cout << element.first << " :: " << element.second << std::endl;
    std::cout << "*******************" << std::endl;
    // Initialize an unordered_map through another range of elements of type std::pair
    std::unordered_map<std::string, int> wordMap_2(wordMap.begin(),
            wordMap.end());
			
    // Iterate over an unordered_map and display elements
    for (std::pair<std::string, int> element : wordMap_2)
        std::cout << element.first << " :: " << element.second << std::endl;
    std::cout << "*******************" << std::endl;
    // Initialize an unordered_map through other unordered_map
    std::unordered_map<std::string, int> wordMap_3(wordMap);
	
    // Iterate over an unordered_map and display elements
    for (std::pair<std::string, int> element : wordMap_3)
        std::cout << element.first << " :: " << element.second << std::endl;
    return 0;
}
============================
Third :: 3
Second :: 2
First :: 1
*******************
First :: 1
Second :: 2
Third :: 3
*******************
Third :: 3
Second :: 2
First :: 1
=====================================
//iterator needs to use pointer ->
find whether the key present in map without using for loop?

include <iostream>
#include <unordered_map>
#include <string>
int main() {
    // Initialize an unordered_map through initializer_list
    std::unordered_map<std::string, int> wordMap( {
        { "First", 1 }, { "Second",    2 }, { "Third", 3 }
                                                });
    // Declare an iterator to unordered_map
    std::unordered_map<std::string, int>::iterator it;
    // Find if an element with key "First" exists or not.
    // find() returns an iterator
    it = wordMap.find("First");
    // Check if iterator points to end of map
    if (it != wordMap.end())
    {
        std::cout << "Element Found - ";
        std::cout << it->first << "::" << it->second << std::endl;
    }
    else
    {
        std::cout << "Element Not Found" << std::endl;
    }
    return 0;
}
Ouput:

Element Found - First::1
===============================================
inserting the element into the map using insert?
check whether the insert is success or not?
print the key and value from the pair <iterator and bool>
typedef for iterator?

#include <iostream>
#include <unordered_map>
#include <string>
int
main()
{
// Creating an empty unordered_map
std::unordered_map<std::string, int> wordMap;
// Inserting elements through an initializer_list
wordMap.insert({ {"First", 1}, {"Second", 2}, {"Third", 3} } );
typedef std::unordered_map<std::string, int>::iterator UOMIterator;
// Pair of Map Iterator and bool value
std::pair< UOMIterator , bool> result;
// Inserting an element through pair
result = wordMap.insert(std::make_pair<std::string, int>("Second", 6)); // or result = wordMap.insert({"Second", 6});
if(result.second == false)
std::cout<<"Element 'Second' not inserted again"<<std::endl;
  // Inserting an element through value_type
  result = wordMap.insert({"Fourth", 4});
    if(result.second == false)
    {
        std::cout<<"Element 'Fourth' not inserted again"<<std::endl;
    }
    else
    {
      // Element inserted sucessfully, so first value in pair
      // is the iterator of newly inserted element
      std::cout<<"Element Inserted : ";
      std::cout<<result.first->first<<"::"<<result.first->second<<std::endl;
    }
  for (std::pair<std::string, int> element : wordMap)
      std::cout << element.first << " :: " << element.second << std::endl;
  return 0;
}
Output:

Element 'Second' not inserted again
Element Inserted : Fourth::4
Fourth :: 4
Third :: 3
Second :: 2
First :: 1
========================================
delete the element in the map using key:
how to confirm the element is deleted?

#include <iostream>
#include <unordered_map>
#include <string>
int main() {
// Initialize an unordered_map through initializer_list
    std::unordered_map<std::string, int> wordMap( { { "First", 1 }, { "Second",
            2 }, { "Third", 3 }, { "Fourth", 4 }, { "Fifth", 5 } });
//Erase element by key
    if (wordMap.erase("Second") == 1) //return the number of element erased.
        std::cout << "Element Deleted" << std::endl;
    return 0;
}
Output

Element Deleted
====================================
delete the element in the map using iterator:
{{{}}) => () is not required;

#include <iostream>
#include <unordered_map>
#include <string>
int main() {
    // Initialize an unordered_map through initializer_list
    std::unordered_map<std::string, int> wordMap( { { "First", 1 }, { "Second",
            2 }, { "Third", 3 }, { "Fourth", 4 }, { "Fifth", 5 } });
    // Iterator pointing to first element of unordered_map
    std::unordered_map<std::string, int>::iterator it = wordMap.find("Fourth");
    // Erase the element pointed by iterator it
    if (it != wordMap.end())
        wordMap.erase(it);
    // Dsiplay the map contents
    for (std::pair<std::string, int> element : wordMap)
        std::cout << element.first << " :: " << element.second << std::endl;
    return 0;
}
Ouput:

Fifth :: 5
First :: 1
Second :: 2
Third :: 3
In the above output entry with key “Fourth” is not present because that’s deleted.

Erasing an element by value from an unordered_map
Unordered_map store values in a key value pair and erase() function of unordered_map can take either iterator or key.

So, to delete an element by value we need to, iterate over all the elements in map and search for element whose value matches the given value. Then  we will use its iterator to delete that element.

Let’s see an example, it searches for an element with value 2 and then deletes that element i.e.
==========================================================
delete the element using value:
unordered_map 

#include <iostream>
#include <unordered_map>
#include <string>
int main() {
    // Initialize an unordered_map through initializer_list
    std::unordered_map<std::string, int> wordMap( { { "First", 1 }, { "Second",
            2 }, { "Third", 3 }, { "Fourth", 4 }, { "Fifth", 5 } });
    // Iterator pointing to first element of unordered_map
    std::unordered_map<std::string, int>::iterator it = wordMap.begin();
    // Search for an element with value 2
    while(it != wordMap.end())
    {
        if(it->second == 2)
            break;
        it++;
    }
    // Erase the element pointed by iterator it
    if (it != wordMap.end())
        wordMap.erase(it);
    // Display the map contents
    for (std::pair<std::string, int> element : wordMap)
        std::cout << element.first << " :: " << element.second << std::endl;
    return 0;
}
Output:

Fifth :: 5
First :: 1
Fourth :: 4
Third :: 3
==========================

Threads:
==================================================================XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX=====================================
Thread objects can be created like this,

std::thread thObj(<CALLBACK>);
New Thread will start just after the creation of new object and will execute the passed callback in parallel to thread that has started it.
Moreover, any thread can wait for another to exit by calling join() function on that thread’s object.

Lets look at an example where main thread will create a separate thread. After creating this new thread, main thread will print some data on 
console and then wait for newly created thread to exit.

Lets implement above using three different callback mechanism,

Creating a thread using Function Pointer
#include <iostream>
#include <thread>
 
void thread_function()
{
    for(int i = 0; i < 10000; i++);
        std::cout<<"thread function Executing"<<std::endl;
}
 
int main()  
{
    
    std::thread threadObj(thread_function);
    for(int i = 0; i < 10000; i++);
        std::cout<<"Display From MainThread"<<std::endl;
    threadObj.join();    
    std::cout<<"Exit of Main function"<<std::endl;
    return 0;
}
======================================

Creating a thread using Function Objects
#include <iostream>
#include <thread>
class DisplayThread
{
public:
    void operator()()     
    {
        for(int i = 0; i < 5; i++)
            std::cout<<"Display Thread Executing"<<std::endl;
    }
};
 
int main()  
{
    std::thread threadObj( (DisplayThread()) ); //note () is required else it will consider as the function declaration
    for(int i = 0; i < 5; i++)
        std::cout<<"Display From Main Thread "<<std::endl;
    std::cout<<"Waiting For Thread to complete"<<std::endl;
    threadObj.join();
    std::cout<<"Exiting from Main Thread"<<std::endl;
    return 0;
}

Display From Main Thread 
Display From Main Thread 
Display From Main Thread 
Display From Main Thread 
Display From Main Thread 
Waiting For Thread to complete
Display Thread Executing
Display Thread Executing
Display Thread Executing
Display Thread Executing
Display Thread Executing
Exiting from Main Thread


===================================
create the thread as pointer:

#include <iostream>
#include <thread>

// Function to be executed in a separate thread
void printMessage(const std::string& message) {
    std::cout << "Thread ID: " << std::this_thread::get_id() << " - " << message << std::endl;
}

int main() {
    // Create a new thread using dynamic memory allocation
    std::thread* threadPtr = new std::thread(printMessage, "Hello from the thread!");

    // Main thread continues execution
    std::cout << "Main Thread ID: " << std::this_thread::get_id() << std::endl;
    std::cout << "Doing some work in the main thread..." << std::endl;

    // Wait for the spawned thread to finish
    threadPtr->join();

    // Clean up the dynamically allocated thread object
    delete threadPtr;

    return 0;
}
==============================================
f you delete a std::thread object before joining it or detaching it, the program behavior is undefined. Deleting the std::thread object 
without properly handling its execution status can lead to various potential issues, including crashes, resource leaks, or unpredictable behavior.
#include <iostream>
#include <thread>

void printMessage(const std::string& message) {
    std::cout << "Thread ID: " << std::this_thread::get_id() << " - " << message << std::endl;
}

int main() {
     std::thread* threadPtr = new std::thread(printMessage, "Hello from the thread!");


    delete threadPtr; // Deleting the std::thread object without joining it

    return 0;
}

===============================================================================
Creating a thread using Lambda functions
[](){}
if the there is no argument. Not must to have ()
[]{}

#include <iostream>
#include <thread>
int main()  
{
    int x = 9;
    std::thread threadObj([]{
            for(int i = 0; i < 10000; i++)
                std::cout<<"Display Thread Executing"<<std::endl;
            });
            
    for(int i = 0; i < 10000; i++)
        std::cout<<"Display From Main Thread"<<std::endl;
        
    threadObj.join();
    std::cout<<"Exiting from Main Thread"<<std::endl;
    return 0;
}
===============================================
To get the identifier for the current thread use,

std::this_thread::get_id()
If std::thread object does not have an associated thread then get_id() will return a default constructed std::thread::id object i.e. not any thread

std::thread::id is a Object, it can be compared and printed on console too. Let’s look at an example,

#include <iostream>
#include <thread>
void thread_function()
{
    std::cout<<"Inside Thread :: ID  = "<<std::this_thread::get_id()<<std::endl;    
}
int main()  
{
    std::thread threadObj1(thread_function);
    std::thread threadObj2(thread_function);
 
    if(threadObj1.get_id() != threadObj2.get_id())
        std::cout<<"Both Threads have different IDs"<<std::endl;
 
        std::cout<<"From Main Thread :: ID of Thread 1 = "<<threadObj1.get_id()<<std::endl;    
    std::cout<<"From Main Thread :: ID of Thread 2 = "<<threadObj2.get_id()<<std::endl;    
 
    threadObj1.join();    
    threadObj2.join();    
    return 0;
}
=============================================================================
note () : std::thread threadObj( (WorkerThread()) );
std::thread threadObj( WorkerThread() ); //it will not work since this line will be considered as function declaration
std::thread threadObj( WorkerThread); or std::thread threadObj( (WorkerThread) ); //error

Joining Threads with std::thread::join()
Once a thread is started then another thread can wait for this new thread to finish. For this another need need to call join() function on 
the std::thread object

#include <iostream>
#include <thread>
#include <algorithm>
class WorkerThread
{
public:
    void operator()()     
    {
        std::cout<<"Worker Thread "<<std::endl;
    }
};
int main()  
{
    std::thread threadObj( (WorkerThread()) ); //note ( is expected before workthread and ()
    // Program will terminate as we have't called either join or detach with the std::thread object.
    // Hence std::thread's object destructor will terminate the program
    return 0;
}
=======================
Therefore, before calling join() or detach() we should check if thread is join-able every time i.e.

    std::thread threadObj( (WorkerThread()) );
    if(threadObj.joinable())
    {
        std::cout<<"Detaching Thread "<<std::endl;
        threadObj.detach();
    }
    if(threadObj.joinable())    
    {
        std::cout<<"Detaching Thread "<<std::endl;
        threadObj.detach();
    }
    
    std::thread threadObj2( (WorkerThread()) );
    if(threadObj2.joinable())
    {
        std::cout<<"Joining Thread "<<std::endl;
        threadObj2.join();
    }
    if(threadObj2.joinable())    
    {
        std::cout<<"Joining Thread "<<std::endl;
        threadObj2.join();
    }
================================


====================================
hen the thread is detached and the main thread exits does the program ends above?
ChatGPT
Yes, when a detached thread is running independently and the main thread exits, the program will typically terminate. However, it's 
important to note that the behavior can vary depending on 
the operating system and the runtime environment.

When the main thread exits while there are still detached threads running, the C++ runtime library usually terminates the program. 
This termination typically involves stopping all threads, 
including the detached ones, and releasing any associated resources. The operating system may also reclaim any resources allocated to the program.

It's important to ensure that detached threads have completed their tasks before the main thread exits to avoid premature termination and potential resource leaks. If you rely on the 
completion of detached threads, you should use appropriate synchronization mechanisms such as condition variables, futures, or other synchronization primitives to coordinate the execution 
and termination of threads.

In general, it's good practice to join or detach all threads explicitly and manage their lifecycles appropriately to ensure the desired behavior of your program.
===========================================================

#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;

void modifyValue(int* ptr) {
    std::lock_guard<std::mutex> lock(mtx);
    *ptr = 19;
}

int main() {
    int i = 10;
    std::thread t(modifyValue, &i);
    t.join(); //since it is join you will always get the output 19. if you use just join you will get only 10

    std::cout << "Value of i: " << i << std::endl;

    return 0;
} 
====================
void modifyValue(int* ptr) {
    *ptr = 19;
}

int main() {
    int i = 10;
    std::thread t(modifyValue, &i);
    t.detach();

    // Add a delay to allow the detached thread to execute
    std::this_thread::sleep_for(std::chrono::milliseconds(100));

    std::cout << "Value of i: " << i << std::endl; //19

    return 0;
}

=========
std::chrono::milliseconds dura( 2000 );
std::this_thread::sleep_for( dura );
std::chrono::milliseconds dura(2000) creates a duration object representing a time interval of 2000 milliseconds.
std::this_thread::sleep_for(dura) puts the current thread to sleep for the specified duration.
=========================================
Don’t pass addresses of variables from local stack to thread’s callback function. Because it might be possible that local variable in Thread 1 goes out of scope but Thread 2 is still trying to access it through it’s address.
In such scenario accessing invalid address can cause unexpected behaviour.
For example,

#include <iostream>
#include <thread>
void newThreadCallback(int * p)
{
    std::cout<<"Inside Thread :  "" : p = "<<p<<std::endl;
    std::chrono::milliseconds dura( 1000 );
    std::this_thread::sleep_for( dura );
    *p = 19;
}
void startNewThread()
{
    int i = 10;
    std::cout<<"Inside Main Thread :  "" : i = "<<i<<std::endl;
    std::thread t(newThreadCallback,&i);
    t.detach();
    std::cout<<"Inside Main Thread :  "" : i = "<<i<<std::endl;
}
int main()
{
    startNewThread();
    std::chrono::milliseconds dura( 2000 );
    std::this_thread::sleep_for( dura );
    return 0;
}
=============================
 int * p = new int(); //intialize the memory to zero
  int * p = new int; // the memory content will be not zero.
Similarly be careful while passing pointer to memory located on heap to thread. Because it might be possible that some thread deletes that memory before new thread tries to access it.
In such scenario accessing invalid address can cause unexpected behaviour.
For example,
#include <iostream>
#include <thread>
void newThreadCallback(int * p)
{
    std::cout<<"Inside Thread :  "" : p = "<<p<<std::endl;
    std::chrono::milliseconds dura( 1000 );
    std::this_thread::sleep_for( dura );
    *p = 19;
}
void startNewThread()
{
    int * p = new int();
    *p = 10;
    std::cout<<"Inside Main Thread :  "" : *p = "<<*p<<std::endl;
    std::thread t(newThreadCallback,p);
    t.detach();
    delete p;
    p = NULL;
}
int main()
{
    startNewThread();
    std::chrono::milliseconds dura( 2000 );
    std::this_thread::sleep_for( dura );
    return 0;
}
===========================================
thread calling a function with argument?
#include <thread>
std::thread threadObj(threadCallback, x);.

=============================================================
//error the thread cannot take the reference?

void threadCallback(int &x) // error can (int x) ot (const int &x1) and then copy to the local variable x=x1
{
    x++;
    std::cout<<"Inside Thread x = "<<x<<std::endl;
}
int main()
{
    int x = 9;
    std::cout<<"In Main Thread : Before Thread Start x = "<<x<<std::endl;
    std::thread threadObj(threadCallback, x);
    threadObj.join();
    std::cout<<"In Main Thread : After Thread Joins x = "<<x<<std::endl;
    return 0;
}

Inside Thread x = 10
In Main Thread : After Thread Joins x = 9
=================================================================================================
The std::thread constructor expects the arguments to be passed by value, not by reference. 
In your code, you are passing x by value. 
To pass it by reference, you need to use std::ref from the <functional>

void threadCallback(int& x)
{
    x++;
    std::cout << "Inside Thread x = " << x << std::endl;
}

int main()
{
    int x = 9;
    std::cout << "In Main Thread: Before Thread Start x = " << x << std::endl;
    std::thread threadObj(threadCallback, std::ref(x));
    threadObj.join();
    std::cout << "In Main Thread: After Thread Joins x = " << x << std::endl;
    return 0;
}

In Main Thread: Before Thread Start x = 9
Inside Thread x = 10
In Main Thread: After Thread Joins x = 10
=============================================================
reference as the const and modifying the value?
taking the reference in the const_cast?

void threadCallback(int const & x)
{
    int & y = const_cast<int &>(x);
    y++;
    std::cout<<"Inside Thread x = "<<x<<std::endl;
}
int main()
{
    int x = 9;
    std::cout<<"In Main Thread : Before Thread Start x = "<<x<<std::endl;
    std::thread threadObj(threadCallback,std::ref(x));
    threadObj.join();
    std::cout<<"In Main Thread : After Thread Joins x = "<<x<<std::endl;
    return 0;
}
Its output is

In Main Thread : Before Thread Start x = 9
Inside Thread x = 10
In Main Thread : After Thread Joins x = 10
===================================
passing the class member function to the thread function:
& is must &MyClass::threadCallback
class MyClass {
public:
    void threadCallback(int& x) {
        x++;
        std::cout << "Inside Thread x = " << x << std::endl;
    }
};

int main() {
    int x = 9;
    std::cout << "In Main Thread: Before Thread Start x = " << x << std::endl;
    MyClass obj;
    std::thread threadObj(&MyClass::threadCallback, &obj, std::ref(x));
    threadObj.join();
    std::cout << "In Main Thread: After Thread Joins x = " << x << std::endl;
    return 0;
}

================================
race condition problem: output of thebelow program is not 5000
createing the thread using vector?
joining all the thread in vector?


class Wallet
{
    int mMoney;
public:
    Wallet() :mMoney(0){}
    int getMoney() { return mMoney; }
    void addMoney(int money)
    {
       for(int i = 0; i < money; ++i)
       {
          mMoney++;
       }
    }
};
int testMultithreadedWallet()
{
   Wallet walletObject;
   std::vector<std::thread> threads;
   for(int i = 0; i < 5; ++i){
        threads.push_back(std::thread(&Wallet::addMoney, &walletObject, 1000));
   }

   for(int i = 0; i < threads.size() ; i++)
   {
       threads.at(i).join();
   }
   return walletObject.getMoney();
}

int main()
{

  int val = 0;
  for(int k = 0; k < 1000; k++)
  {
     if((val = testMultithreadedWallet()) != 5000)
     {
       std::cout << "Error at count = "<<k<<" Money in Wallet = "<<val << std::endl;
     }
  }
  return 0;
}
======================
to fix the baove problem:
#include<iostream>
#include<thread>
#include<vector>
#include<mutex>
class Wallet
{
    int mMoney;
    std::mutex mutex;
public:
    Wallet() :mMoney(0){}
    int getMoney()   {     return mMoney; }
    void addMoney(int money)
    {
        mutex.lock();
        for(int i = 0; i < money; ++i)
        {
            mMoney++;
        }
        mutex.unlock();
    }
};
================================================
std::lock_guard 
std::lock_guard is a class template, which implements the RAII for mutex.
It wraps the mutex inside it’s object and locks the attached mutex in its constructor. 
When it’s destructor is called it releases the mutex.

Let’s see the code,

class Wallet
{
    int mMoney;
    std::mutex mutex;
public:
    Wallet() :mMoney(0){}
    int getMoney()   {     return mMoney; }
    void addMoney(int money)
    {
        std::lock_guard<std::mutex> lockGuard(mutex);
        // In constructor it locks the mutex
        for(int i = 0; i < money; ++i)
        {
            // If some exception occurs at this
            // poin then destructor of lockGuard
            // will be called due to stack unwinding.
            //
            mMoney++;
        }
        // Once function exits, then destructor
        // of lockGuard Object will be called.
        // In destructor it unlocks the mutex.
    }
 };
 ===============================
Thread will keep on acquiring the lock and release it just to check the value, therefore it will 
consume CPU cycles and will also make Thread 1 slow, because it needs to acquire same lock to update the bool flag.
#include<iostream>
#include<thread>
#include<mutex>
class Application
{
 std::mutex m_mutex;
 bool m_bDataLoaded;
public:
 Application()
 {
 m_bDataLoaded = false;
 }
 void loadData()
 {
	 // Make This Thread sleep for 1 Second
	 std::this_thread::sleep_for(std::chrono::milliseconds(1000));
	 std::cout<<"Loading Data from XML"<<std::endl;
	 // Lock The Data structure
	 std::lock_guard<std::mutex> guard(m_mutex);
	 // Set the flag to true, means data is loaded
	 m_bDataLoaded = true;
 }
 void mainTask()
 {
	 std::cout<<"Do Some Handshaking"<<std::endl;
	 // Acquire the Lock
	 m_mutex.lock();
	 // Check if flag is set to true or not
	 while(m_bDataLoaded != true)
	 {
		  // Release the lock
		  m_mutex.unlock();
		  //sleep for 100 milli seconds
		  std::this_thread::sleep_for(std::chrono::milliseconds(100));
		  // Acquire the lock
		  m_mutex.lock();
	  }
	  // Release the lock
	  m_mutex.unlock();
	  //Doc processing on loaded Data
	  std::cout<<"Do Processing On loaded Data"<<std::endl;
 }
};
int main()
{
  Application app;
  std::thread thread_1(&Application::mainTask, &app);
  std::thread thread_2(&Application::loadData, &app);
  thread_2.join();
  thread_1.join();
  return 0;
}
====================================
what is the difference between lock_guard and unique_lock in the above pgrom . why we havent used only lock_guar or 
unique_guard in bot cases?
ChatGPT
Both std::lock_guard and std::unique_lock are used for providing RAII-style locking and unlocking of mutexes. However, 
they have some differences in terms of flexibility and functionality.

In the given program, std::lock_guard is used in the sendSignal() function, while std::unique_lock is used in the 
waitForSignal() function. Let's understand the reasons behind this choice:

std::lock_guard:

std::lock_guard is a simple lock wrapper that acquires the lock during its construction and releases it automatically 
upon destruction.
It is a lightweight lock and cannot be manually locked or unlocked.
std::lock_guard is suitable when you need to acquire a lock and release it automatically when the lock_guard object 
goes out of scope, as seen in the sendSignal() function. In this case, we acquire the lock using std::lock_guard to 
protect the critical section where isReady is modified.
std::unique_lock:

std::unique_lock is a more flexible lock wrapper that provides additional functionalities compared to std::lock_guard.
It can be locked and unlocked manually multiple times, which allows more fine-grained control over locking and unlocking.
std::unique_lock also supports deferred locking and timed locking, which can be useful in some scenarios.
In the waitForSignal() function, we use std::unique_lock because we need more control over waiting and signaling. We use cv.wait(lock) to wait until the condition isReady becomes true. The unique_lock provides the ability to unlock the mutex during waiting and automatically reacquire it when the thread is signaled.
In summary, std::lock_guard is a simpler lock wrapper that provides automatic locking and unlocking, suitable for straightforward lock and unlock scenarios. On the other hand, std::unique_lock is more versatile and provides additional functionalities like manual locking/unlocking, deferred locking, and timed locking. It offers more control over the locking and unlocking process, making it suitable for situations that require more flexibility.
===========================================
it is not necessary that we should always have some function in wait?

#include <mutex>              // For std::mutex
#include <condition_variable> // For std::condition_variable
std::mutex mtx;
std::condition_variable cv;
bool isReady = false;

void waitForSignal()
{
    std::unique_lock<std::mutex> lock(mtx);
    while (!isReady) {
        cv.wait(lock); //release the lock and wait. once the signal is received lock is acquired 
    }
    std::cout << "Signal received! Continuing with the execution." << std::endl;
}

void sendSignal()
{
    std::this_thread::sleep_for(std::chrono::seconds(2)); // Simulating some work
    {
        std::lock_guard<std::mutex> lock(mtx);
        isReady = true;
    }
    cv.notify_one();
}

int main()
{
    std::thread waitingThread(waitForSignal);

    std::cout << "Main thread is doing some work..." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(1));

    sendSignal();

    waitingThread.join();

    return 0;
}
========================================
The threadCallback() function is called by the thread and waits for the signal using cv.wait(). The lambda function passed 
to cv.wait() checks if the isReady flag is set. Once the condition is satisfied, the thread proceeds with the execution.

//if the time expired wait will not require the mutex.
//This line waits for either the condition variable to be notified, or for the timeout to be reached.
cv.wait_for(lock, std::chrono::seconds(1), [] { return ready; }))
===================
The wait function is called on the std::condition_variable object m_condVar. It is used to block the current thread until the condition variable
 is notified. In this case, the wait function waits until the condition isDataLoaded() returns true.

m_condVar.wait(mlock, std::bind(&Application::isDataLoaded, this)) releases the lock (mlock) 
and puts the thread to sleep until the condition variable m_condVar is notified. Once the thread is awakened, 
it reacquires the lock and checks if the condition isDataLoaded() is met. 
If the condition is false, the thread goes back to sleep. If the condition is true, the thread continues executing.

while (!isDataLoaded())
{
    m_condVar.wait(mlock);
}
====> equivalent
m_condVar.wait(mlock, [this] { return !isDataLoaded(); });==> this is in loop to check
====> equivalent
m_condVar.wait(mlock, std::bind(&Application::isDataLoaded, this));
====?
==============================================================================================================================
==============================================================================================================================
=============================================================================================================================
placeholder namespace?
condition variable?
a. bind is present in which header ?
b. does bind requires the placeholder all the time?
b. thread using the condition variable?
c. how to sleep the thread?
c. conditional wait argument()? { unique lock and condition}
- call lamda expression
- call global function
- call bind - retrun is not required here
d. thread creation using the class member function and object
e. placeholders not placeholder?
f. thread join order: check the thread is joinable and Join the threads in the reverse order of their creation: 

std::this_thread::sleep_for(std::chrono::milliseconds(1000));

 
not conditional ==> condition

condition wait using bind?
in which lock we will notify?

notify_one() not notify()

#include <iostream>
#include <thread>
#include <functional>
#include <mutex>
#include <condition_variable>
using namespace std::placeholders; // not required as the bind is not taking the argument
class Application
{
  std::mutex m_mutex;
  std::condition_variable m_condVar;
  bool m_bDataLoaded;
public:
  Application()
  {
    m_bDataLoaded = false;
  }
  void loadData()
  {
   // Make This Thread sleep for 1 Second
   std::this_thread::sleep_for(std::chrono::milliseconds(1000));
   std::cout<<"Loading Data from XML"<<std::endl;
   // Lock The Data structure
   {
	   std::lock_guard<std::mutex> guard(m_mutex);
	   // Set the flag to true, means data is loaded
	   m_bDataLoaded = true;
   }
   // Notify the condition variable
   m_condVar.notify_one();
  }
  bool isDataLoaded()
  {
    return m_bDataLoaded;
  }
  void mainTask()
  {
    std::cout<<"Do Some Handshaking"<<std::endl;
    // Acquire the lock
    std::unique_lock<std::mutex> mlock(m_mutex);
    // Start waiting for the Condition Variable to get signaled
    // Wait() will internally release the lock and make the thread to block
    // As soon as condition variable get signaled, resume the thread and
    // again acquire the lock. Then check if condition is met or not
    // If condition is met then continue else again go in wait.
    m_condVar.wait(mlock, std::bind(&Application::isDataLoaded, this));
    std::cout<<"Do Processing On loaded Data"<<std::endl;
  }
};
int main()
{
   Application app;
   std::thread thread_1(&Application::mainTask, &app);
   std::thread thread_2(&Application::loadData, &app);
   thread_2.join();
   thread_1.join();
   return 0;
}
==========================================================
//lamda function with no argument and calling the print statement
//differents of doing the above
//replace auto

#include <iostream>

int main() {
    // Example: Lambda function with no arguments
    auto incrementCounter = [] { std::cout << "viswa"; };// auto ca be relaced to function <void(void)> incrementCounter
	//auto incrementCounter = []() { std::cout << "viswa"; };// auto ca be relaced to function <void(void)> incrementCounter
	function <void(void)> incrementCounter = [] { std::cout << "viswa"; };// auto ca be relaced to function <void(void)> incrementCounter
    incrementCounter();

    return 0;
}
===========================================================
what is the return type of find_if for the vector and map?
find_if in the vector to match whether the target element is present using lamda?

lamda sum function
lamda multiplication number
retun value of the lamda function
lamda vector integer comparision
it is not always neccessay to lamda capture list to be reference
passing the local variable to the lambda?
header file?
difference between for_each, find_if


#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    // Example 1: Simple lambda function
    int x = 10;
    int y = 5;
    auto sum = [](int a, int b) { return a + b; };
    int result = sum(x, y);
    std::cout << "Sum of " << x << " and " << y << " is: " << result << std::endl;

    // Example 2: Using lambda with standard library algorithms
    std::vector<int> numbers = {3, 7, 1, 9, 2, 5};
    int target = 5;
    auto it = std::find_if(numbers.begin(), numbers.end(), [target](int num) { return num == target; });
    if (it != numbers.end()) {
        std::cout << "Found " << target << " in the vector." << std::endl;
    } else {
        std::cout << target << " not found in the vector." << std::endl;
    }

    // Example 4: Capturing variables by value and modifying them
    int multiplier = 2;
    auto multiplyByValue = [multiplier](int value) { return value * multiplier; };
    int resultValue = multiplyByValue(5);
    std::cout << "Result of multiplication: " << resultValue << std::endl;

    return 0;
}
=======================================================
find_if in map using lamda to match with the target key?

#include <iostream>
#include <algorithm>
#include <map>

int main() {
    std::map<int, std::string> myMap;

    myMap[1] = "one";
    myMap[2] = "two";
    myMap[3] = "three";
    myMap[4] = "four";

    int keyToFind = 2;

    // Using std::find_if to find an element in the map
    auto result = std::find_if(myMap.begin(), myMap.end(), [keyToFind](const std::pair<int, std::string>& pair) {
        return pair.first == keyToFind;
    });

    if (result != myMap.end()) {
        std::cout << "Found: Key=" << result->first << ", Value=" << result->second << std::endl;
    } else {
        std::cout << "Not found" << std::endl;
    }

    return 0;
}

========================================================
difference between for_each, find_if
for_each to print the elemnet doubling the element value temporary?

#include <iostream>
#include <algorithm>
#include <vector>

void printSquare(int x) {
    std::cout << x * x << " ";
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    std::cout << "Original numbers: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    // Use std::for_each to print squares of each number
    std::cout << "Squares of numbers: ";
    std::for_each(numbers.begin(), numbers.end(), printSquare);
    std::cout << std::endl;

    return 0;
}
=====================
for each to change the element of the vector
different ways to change value in vector?
for_each
range over loop
for and iterator
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    // Use std::for_each with a lambda to double each element
    std::for_each(numbers.begin(), numbers.end(), [](int& num) {
        num *= 2;
    });

    // Print the modified vector
    std::cout << "Modified numbers: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}

===========================================================
coonditional variable using lamda function 
is it necessary to have the argument for the lamda function
return is used inside the lamda for the condition check of the contion wait

#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

bool isDataReady = false;
std::mutex mutexObj;
std::condition_variable condVar;

void processData() {
    std::this_thread::sleep_for(std::chrono::seconds(2));
    std::lock_guard<std::mutex> lock(mutexObj);
    isDataReady = true;
	lock.unlock(); //it is necessary to unlock before notify
    condVar.notify_one();
}

int main() {
    std::thread threadObj(processData);

    std::cout << "Performing other tasks while waiting..." << std::endl;

    std::unique_lock<std::mutex> lock(mutexObj);
    condVar.wait(lock, [] { return isDataReady; }); //or condVar.wait(lock, [] (){ return isDataReady; });

    std::cout << "Data is ready!" << std::endl;

    threadObj.join();

    return 0;
}
In this example:

We have a global flag isDataReady to indicate if the data is ready or not.
We launch a new thread using the processData() function.
Inside processData(), we simulate a time-consuming operation by sleeping for 2 seconds and then set the isDataReady flag to true.
In the main thread, we print a message indicating that we are performing other tasks while waiting.
We acquire a std::unique_lock on the mutex and call wait() on the condition variable. The lambda function passed to wait() checks the value of isDataReady.
If isDataReady is false, the main thread will wait until it is notified by another thread and the condition becomes true.
Once the condition becomes true, the main thread resumes execution and prints "Data is ready!".
===========================================================
calling the thread with the global function and prmise object
what is future and promise object?
how to set and get the value;
how to get the future from the promise
passing the promise to the thread function
get the value from the future
header file required?
define the promise and future? 
what is the important think required for thread.
ordering of the thread?
joining thread?



set_value not set to set the value

2.) C++11 Way : Using std::future and std::promise
In C++, std::promise and std::future are classes that provide a synchronization mechanism for asynchronous communication between threads
std::future is a class template and its object stores the future value.
Now what the hell is this future value.

Actually a std::future object internally stores a value that will be assigned in future and it also provides a 
mechanism to access that value i.e. using get() member function. But if somebody tries to access this associated value \
of future through get() function before it is available, then get() function will block till value is not available.

std::promise is also a class template and its object promises to set the value in future. Each std::promise object has 
an associated std::future object that will give the value once set by the std::promise object.

A std::promise object shares data with its associated std::future object.

#include <iostream>
#include <thread>
#include <future>
void initiazer(std::promise<int> * promObj)
{
    std::cout<<"Inside Thread"<<std::endl;     promObj->set_value(35);
}
int main()
{
    std::promise<int> promiseObj;
    std::future<int> futureObj = promiseObj.get_future();
    std::thread th(initiazer, &promiseObj);
    std::cout<<futureObj.get()<<std::endl;
    th.join();
    return 0;
}
If std::promise object is destroyed before setting the value the calling get() function on associated std::future object
 will throw exception.
A part from this, if you want your thread to return multiple values at different point of time then just pass multiple 
\std::promise objects in thread and fetch multiple return values from thier associated multiple std::future objects.
======================================================================
header file required for exception?
how to handle the exception in the promise inside the lamda function
how to create the thread using lamda expression using the promise
throw the runctime exception, header file required
current exception
lamda expression using the promise
why need the join?
catch all the exception
how to setthe exception and value in promise?
how to handle the exception in future?

std::promise and std::future are synchronization primitives that provide a way to communicate and transfer data between two threads. 
They are part of the C++ Standard Library and are used for asynchronous operations and inter-thread communication.

Here's a detailed explanation of std::promise and std::future:

std::promise:

A std::promise is a template class that allows you to store a value or an exception that will be made available in the future.
It provides a mechanism for one thread (the "producer") to set a value or an exception that can be retrieved by another thread (the "consumer").
The producer thread uses std::promise::set_value() or std::promise::set_exception() to fulfill the promise with a value or an exception, respectively.
The consumer thread can obtain a corresponding std::future object from the std::promise to retrieve the value or handle the exception.
std::future:

A std::future represents a value or an exception that will be available in the future.
It provides a mechanism for one thread (the "consumer") to wait for and retrieve the value or handle the exception set by another thread (the "producer").
The consumer thread uses the std::future object obtained from the std::promise to query the status and retrieve the value or handle the exception.
The consumer thread can block until the value is available by calling std::future::get() or use non-blocking techniques like std::future::wait_for() 
or std::future::wait_until().

#include <iostream>
#include <future>
#include <stdexcept>

int main()
{
    std::promise<int> promiseObj;
    std::future<int> futureObj = promiseObj.get_future();

    std::thread threadObj([&promiseObj]() {
        try {
            throw std::runtime_error("Custom exception");
        } catch (...) {
            promiseObj.set_exception(std::current_exception());
        }
    });

    try {
        futureObj.get();  // This will throw the exception set in the promise. if no exception value will be received.
    } catch (const std::exception& ex) {
        std::cout << "Caught exception: " << ex.what() << std::endl;
    }

    threadObj.join();

    return 0;
}
==============================================
future and promise setting the integer value.

thread with lamda+promise+detach

detach will detach th thread and it doesnot require the join?


#include <iostream>
#include <future>

int main() {
    std::promise<int> promiseObj;
    std::future<int> futureObj = promiseObj.get_future();

    std::thread([&promiseObj]() { //This lambda function represents the code that will be executed in a separate thread.
        // Simulating some computation
        int result = 42;

        // Setting the value in the promise
        promiseObj.set_value(result);
    }).detach();

    // Retrieving the value from the future
    int value = futureObj.get();

    std::cout << "Value received from the future: " << value << std::endl;

    return 0;
}

==================================================
return type of the async?

aync thread asynchronously and detaching at same time to calculate the addition taking the arguments in lamda returning nothing. 
how the future will look.
async option asyn and detach and call the local lamda with argument?
std::launch::deferred is opposite for std::launch::async
lamda returning nothing how the asyn variable will look like?
what is the aync type ie how to replace auto?
what is async opposire spelling 
what happens if we dont store the async return type to the variable? 
   the task is not properly synchronized and managed, it could lead to resource leaks or a thread leak if the task does not complete 
before the program terminates. synchronization may not be acheived

async lamda function to add and print the values by passing the value in the capture list;
async lamda function async and detach?

#include <iostream>
#include <future>

int main() {
    // Example: Passing arguments and detaching the thread in a single line
    int x = 10;
    int y = 5;

    // Using std::async with launch policy std::launch::async | std::launch::detach
    auto asyncTask = std::async(std::launch::async | std::launch::detach, [x, y]() { // or std::future<void> asyncTask or
	//std::future<void> asyncTask
        std::cout << "Result of " << x << " + " << y << " is: " << (x + y) << std::endl;
    });

    // Rest of the main thread can continue without waiting for the asyncTask to complete
    // The asyncTask will run independently in a detached thread

    return 0;
}

===========================================
thread with lamda function and taking the argument and detach at the same line

#include <iostream>
#include <thread>

int main() {
    // Example: Creating a detached thread with a lambda function and passing arguments
    int x = 5;
    int y = 6;

    // Using function-style call and detach in the same line
    std::thread([](int a, int b) {
        // Your code inside the lambda function
        std::cout << "Result of " << a << " + " << b << " is: " << (a + b) << std::endl;
    }, x, y).detach();

    // The detached thread runs independently and may or may not complete before the program terminates.

    return 0;
}

=======================================
promise taking class
future and prmoise taking class? in the lamda function and setting the class value in promise and detaching
set the class?

set_class or set_value?

#include <iostream>
#include <future>
#include <string>

class MyClass {
public:
    MyClass(const std::string& name) : name_(name) {}

    void PrintMessage() const {
        std::cout << "Hello, " << name_ << "!" << std::endl;
    }

private:
    std::string name_;
};

int main() {
    std::promise<MyClass> promiseObj;
    std::future<MyClass> futureObj = promiseObj.get_future();

    std::thread([&promiseObj]() {
        // Simulating some computation
        std::string name = "John";
        MyClass myClass(name);

        // Setting the value in the promise
        promiseObj.set_value(myClass);
    }).detach();

    // Retrieving the value from the future
    MyClass result = futureObj.get();

    // Using the value retrieved from the future
    result.PrintMessage();

    return 0;
}
=============================================================
async to call the add function. passing the the number
thread sleep
async using futue
==============================

#include <iostream>
#include <future>

int addNumbers(int a, int b) {
    std::cout << "Performing addition..." << std::endl;
    return a + b;
}

int main() {
    std::future<int> futureResult = std::async(addNumbers, 4, 5);

    std::cout << "Waiting for the result..." << std::endl;

    int result = futureResult.get();

    std::cout << "The result is: " << result << std::endl;

    return 0;
}
===============================
important things to be consider in thread?
do we set the promise in async?

detach vs async

a. asyn and thread for multiplication
b. detaching the thread
c. what happen if no future get?
d. different ways to detach the thread?

why we need thread join?
what happen if no thread join?
can detach thread be joined?
how to detach the thread at same line of thread creation and at different line?

detached will not have to join so no terminate called without an active exception.
async will have the scope get

calculate the square using square function in async
#include <iostream>
#include <future>
#include <thread>

int square(int x) {
    return x * x;
}

int main() {
    // Using std::async to launch an asynchronous task
    std::future<int> result = std::async(square, 5);
    // The std::future object manages the task, and you can get the result later with std::future::get()

    // Using std::thread::detach to launch a detached thread
    std::thread detachedThread(square, 5);
    detachedThread.detach(); //detache
    // The detachedThread runs independently, and we have no control over it anymore

    // Main thread continues...

    // We don't need to call anything to wait for the std::async task to complete
    // std::future::get() is called implicitly when 'result' goes out of scope.

    return 0;
}
===============================================================
thread sleep:
invalid parameter exception and syntax?
future valid check ? syntax?
header file required for async?
async square with exception handling
which header files are required for sleep?
async with exception.
how to know if the async future is set?
invalid value exception? and syntax?
chrono => chorono
how to check the asyn has updated the future result?

-exception is inside the valid and get . not in the asyn thread

std::this_thread::sleep_for(std::chrono::seconds(56)); => requires thread and chrono header file

#include <iostream>
#include <future>


int square(int x) {
    if (x < 0)
        throw std::invalid_argument("Negative values not allowed.");
    return x * x;
}

int main() {
    std::future<int> result = std::async(square, 5);

    // Check if the future has a valid result
    if (result.valid()) {
        try {
            int squaredValue = result.get();
            std::cout << "Result: " << squaredValue << std::endl;
        } catch (const std::exception& e) {
            std::cout << "Exception: " << e.what() << std::endl;
        }
    } else {
        std::cout << "Future is not valid." << std::endl;
    }

    return 0;
}

================================================================
async with structure name only  and arguments
similar to thread, async thread with local lamda function and argument passed in the same line.


std::async() is a function template that accepts a callback(i.e. function or function object) 
as an argument and potentially executes them asynchronously.
=====
std::async() does following things,

It automatically creates a thread (Or picks from internal thread pool) and a promise object for us.
Then passes the std::promise object to thread function and returns the associated std::future object.
When our passed argument function exits then its value will be set in this promise object, 
so eventually return value will be available in std::future object.

ke 5 seconds only.

Output:

Total Time Taken = 5 Seconds
Data = DB_Data :: File_Data
 Calling std::async with Function Object as callback
/*
 * Function Object
 */
struct DataFetcher
{
    std::string operator()(std::string recvdData)
    {
        // Make sure that function takes 5 seconds to complete
        std::this_thread::sleep_for (seconds(5));
        //Do stuff like fetching Data File
        return "File_" + recvdData;
    }
};
//Calling std::async with function object
std::future<std::string> fileResult = std::async(DataFetcher(), "Data");
 

Calling std::async with Lambda function as callback
//Calling std::async with lambda function
std::future<std::string> resultFromDB = std::async([](std::string recvdData){
                        std::this_thread::sleep_for (seconds(5));
                        //Do stuff like creating DB Connection and fetching Data
                        return "DB_" + recvdData;
                    }, "Data");
====================
local lamda returning an integer to future in async
future object wait for some seconds
future status

timeout not time_out or timedout
If the status is std::future_status::deferred, it means the future is deferred, and the result is not yet available.
If the status is std::future_status::timeout, it means the future is still running, and the result is not
 yet available within the given timeout duration.
The loop continues until the future's status becomes std::future_status::ready, indicating that the result is available.
Once the future is ready, we call std::future::get() to retrieve the result.
Finally, we print the result.
#include <iostream>
#include <future>
#include <chrono>

int main() {
    std::future<int> futureObj = std::async(std::launch::async, []() {
        std::this_thread::sleep_for(std::chrono::seconds(2));
        return 42;
    });

    std::cout << "Waiting for the future..." << std::endl;

    std::future_status status;
    do {
        status = futureObj.wait_for(std::chrono::seconds(1));

        if (status == std::future_status::deferred) {
            std::cout << "Future is deferred." << std::endl;
        } else if (status == std::future_status::timeout) {
            std::cout << "Future is still running." << std::endl;
        }
    } while (status != std::future_status::ready);

    int result = futureObj.get();
    std::cout << "Result: " << result << std::endl;

    return 0;
}

Waiting for the future...
Future is still running.
Future is still running.
Result: 42
==========			
lamda function using the local promise and calling the global sum  and set it in std::promise and std::future:
whether adress is must for promise??

#include <iostream>
#include <thread>
#include <future>

int calculateSum(int a, int b) {
    std::this_thread::sleep_for(std::chrono::seconds(2));
    return a + b;
}

int main() {
    std::promise<int> promiseObj;
    std::future<int> futureObj = promiseObj.get_future();

    std::thread threadObj([&promiseObj]() {
        int result = calculateSum(5, 7);
        promiseObj.set_value(result);
    });

    std::cout << "Performing other tasks while waiting..." << std::endl;

    int result = futureObj.get();
    std::cout << "Sum: " << result << std::endl;

    threadObj.join();

    return 0;
}
In this example:

We create a std::promise<int> object called promiseObj and obtain a std::future<int> object called futureObj from it.
We launch a new thread using a lambda function as the thread function.
Inside the lambda function, we call the calculateSum() function, which simulates a time-consuming operation by sleeping for 2 seconds and then returns the sum of two numbers.
After obtaining the result, we set the value in the promise using set_value().
In the main thread, we print a message indicating that we are performing other tasks while waiting.
We then call get() on the future, which will block until the future has a value set by the promise.
Finally, we retrieve the result from the future and print it.
Synchronous Thread Synchronization using std::mutex and std::condition_variable:
cpp
---------------------------------------------=====================
difference between the asynchronous and synchronous mechanism:
In summary, while there are similarities in terms of performing other tasks while waiting for a result, 
the differences lie in the ownership and responsibility of result production and consumption, the flexibility 
and asynchronicity of threads, and the built-in exception handling support. Asynchronous thread synchronization 
with std::promise and std::future provides a more decoupled and flexible approach, while 
synchronous thread synchronization with condition variables offers more explicit control and coordination between threads.
-------------------------------------------------------------------

==============
async taking friend function as argument which is returning the lamda function.
friend function calling the class member function
//difference between wait and get

std::future::wait(): Use wait() when you want to wait for the asynchronous operation to complete but are not interested in the result value 
immediately. It allows you to control the exact point at which you wait for the completion. After calling wait(), you can perform other tasks 
or synchronization operations before later calling get() to retrieve the result.

#include <iostream>
#include <future>

class MyClass {
public:
    MyClass() {}

    void performTask() {
        std::cout << "Performing task..." << std::endl;
    }

private:
    void privateFunction() {
        std::cout << "Private function called." << std::endl;
    }

    friend auto lambdaFunction1(MyClass* obj) {
	//lamda function 
	[] =>lamda capture list
	() ==> argument
	//here we are returning the callbale object
        return [obj]() {
            obj->privateFunction();
            obj->performTask();
        };
    }
};

int main() {
    MyClass myObject;

    auto futureResult = std::async(lambdaFunction1(&myObject)); //callable object if the function is not returning the lamda it will give error

   //futureResult.wait() is a blocking call that waits for the associated std::future object (futureResult) to become ready. 
   The wait() function blocks the execution of the current thread until the result of the asynchronous operation is available or until the
   associated promise is set.

   //By calling futureResult.wait(), the program will wait until the asynchronous task initiated by std::async completes and the result is 
   //ready. This ensures that the program does not exit before the asynchronous task finishes its execution.
    futureResult.wait();

    return 0;
}
========================================

=====================================
async to add the numbers inside the class member function
#include <iostream>
#include <future>

class MyClass {
public:
    int add(int a, int b) {
        return a + b;
    }
};

int main() {
    MyClass obj;

    // Using std::async with a class member function and its arguments
    std::future<int> futureResult = std::async(&MyClass::add, &obj, 10, 20);

    // The async operation runs concurrently, and you can continue with other tasks

    // Retrieve the result using get() when needed
    int result = futureResult.get();
    std::cout << "Result of add: " << result << std::endl;

    return 0;
}

==========================================
different ways in calling the global function which takes the object which return the lamda function with object and the corresponding output 
in the asyn

thread(funtion())=> when to use like this?

thread(funtion1, &obj) => creates the callable object.funtion1 return int

thread(funtion())=> possible only when the function returns the lamda function.

async calling the function has callable object. function returning the lamda function
     auto lambdaFunction2(MyClass* obj) {
        std::cout <<"viswa";
        return [obj]() {
            std::cout <<"viswa";
        };
    }
int main() {
    MyClass myObject;

    auto futureResult = std::async(lambdaFunction2(&myObject)); //callable object

       futureResult.wait();

    return 0;
}
only two viswa viswa

auto futureResult = std::async(lambdaFunction2,&myObject)); //callable object
output will be viswa
============================================
what is must when we use the lamda function inside the class member function?
calling class member function which return the lamda function taking the argument
using bind the class member function which has the placeholders
this is required in lamda function?
bind for the function with argument?
when we do the bind for the function which takes the argument then the placeholder or argument is must.
 
#include <iostream>
#include <functional>

class MyClass {
public:
    void performTask(int value) {
        std::cout << "Performing task with value: " << value << std::endl;
    }

    std::function<void(int)> createCallable() {
        return [this](int value) {
            performTask(value);
        };
    }
};

int main() {
    MyClass myObject;
    
    int additionalArgument = 42;

    auto callable = myObject.createCallable(); 
	/*
	 //std::function<void(int)> createCallable1 = MyClass::performTask; //non static memebr function error
    std::function<void(int)> createCallable1 = std::bind(&MyClass::performTask,&myObject,std::placeholders::_1);
	//remeber bind requires the third aruments
	createCallable1(12);
	*/

    callable(additionalArgument);

    return 0;
}
===============================================
bind callable calling returing another callable object
bind is prent in which header?
asyn and waitt in single line
when the member function returning the lamda we should be careful on two returns in that function
async with different way of using wait?
lamda taking the arguments in the capture list?
what are the points to be consider for the function has the lamda function

member function returning lamda and calling the function by bind method using async

#include <iostream>
#include <functional>
#include <future>

class MyClass {
public:
    MyClass() {}

    void performTask(int value) {
        std::cout << "Performing task with value: " << value << std::endl;
    }

    auto memberFunction(int value) {
        std::cout << "Member function called with value1: " << value << std::endl;
        return [this, value]() {
            std::cout << "Member function called with value2: " << value << std::endl;
            performTask(value);
        };
    }
};

int main() {
    MyClass myObject;

    int additionalArgument = 42;

    auto boundFunc = std::bind(&MyClass::memberFunction, &myObject, additionalArgument);

    auto callable = boundFunc(); // Execute the lambda function

    std::async(std::launch::async, callable).wait(); //or std::async(std::launch::async, myObject.memberFunction(42)).wait();
	//if you call std::async(std::launch::async, boundFunc).wait(); you will get only Member function called with value1: 42
	//asyn will call only one callabale object

    return 0;
}

Member function called with value1: 42
Member function called with value2: 42
Performing task with value: 42

===============================
async lamda function calling the member function with argument from the capture list
calling the member function which return the lamda function and executing the lamda function at the same line?
async local lamda function taking the arguments in capture list and calling the memebre function which inturn call another lamda function
wait
#include <iostream>
#include <future>
 
class MyClass {
public:
    MyClass() {}

    void performTask(int value) {
        std::cout << "Performing task with value: " << value << std::endl; //42
    }

    auto memberFunction(int value) {
        return [this, value]() {
            std::cout << "Member function called with value: " << value << std::endl; //42
            performTask(value);
        };
    }
};

int main() {
    MyClass myObject;

    int additionalArgument = 42;

    auto futureResult = std::async([&myObject, additionalArgument]() {
        myObject.memberFunction(additionalArgument)(); // it is similar to calling the member function directly in the asyn
    });

    futureResult.wait();

    return 0;
}
Member function called with value: 42
Performing task with value: 42
===========================
async has wait?
std::async(std::launch::deferred, boundFunc).wait();
The std::async function is called with std::launch::deferred as the launch policy, and the boundFunc is passed as the task to be executed. 
However, the task is not executed at this point. Instead, it is deferred until the wait() function is called on the future object returned by 
std::async. The wait() function is immediately called after the std::async call, which waits for the completion of the task.

By using std::launch::deferred, you can control when the task associated with the std::async call gets executed. It allows you to delay the 
execution until you explicitly call wait() or get() on the future object, providing more flexibility in synchronizing the execution of asynchronous
tasks.
===============================================
bind is going to call the function with argument. bind neednot have the placeholders , ie it an take the exact value also.
bind is going to call the function with no argument then placeholder is not required
what is the default behaviour of the callable object in the sync
what are the 2 types of launch asyn task?
different way to call wait? (2)
different way to call the member function with argument using the async

std::launch::deferred
std::launch::async

async with bind function call to call the class member function:

#include <iostream>
#include <functional>
#include <future>

class MyClass {
public:
    MyClass() {}

    void performTask(int value) {
        std::cout << "Performing task with value: " << value << std::endl;
    }

    void memberFunction(int value) {
        std::cout << "Member function called with value: " << value << std::endl;
        performTask(value);
    }
};

int main() {
    MyClass myObject;

    int additionalArgument = 42;

    auto boundFunc = std::bind(&MyClass::memberFunction, &myObject, additionalArgument);

    std::async(std::launch::deferred, boundFunc).wait(); //or std::async(boundFunc).wait();
	//default launch policy can be platform-specific and may vary between different implementations of the C++ standard library. 

    return 0;
}

============================
async with structure object capture and integer arguments in the lamda function and return the structure member function of the multiplier

#include <iostream>
#include <future>

struct MyStruct {
    int multiplyNumbers(int a, int b) {
        std::cout << "Performing multiplication..." << std::endl;
        return a * b;
    }
};

int main() {
    MyStruct myStruct;

    auto futureResult = std::async([&myStruct](int a, int b) {
        return myStruct.multiplyNumbers(a, b);
    }, 4, 5);

    std::cout << "Waiting for the result..." << std::endl;

    int result = futureResult.get();

    std::cout << "The result is: " << result << std::endl; //20

    return 0;
}
==================================================================
async without the class object for the structure and calling the multiplier program of the structure in lamda
no operator() function

#include <iostream>
#include <future>

class MyClass {
public:
    int multiplyNumbers(int a, int b) {
        std::cout << "Performing multiplication..." << std::endl;
        return a * b;
    }
};

int main() {
    auto futureResult = std::async([]() {
        MyClass myObject;
        return myObject.multiplyNumbers(4, 5);
    });

    std::cout << "Waiting for the result..." << std::endl;

    int result = futureResult.get();

    std::cout << "The result is: " << result << std::endl;

    return 0;
}
========================================================
async with direct calling the member function with argument using bind.

#include <iostream>
#include <future>

class MyClass {
public:
    MyClass() {}

    void performTask(int value) {
        std::cout << "Performing task with value: " << value << std::endl;
    }

    void memberFunction(int value) {
        std::cout << "Member function called with value: " << value << std::endl;
    }
};

int main() {
    MyClass myObject;

    int additionalArgument = 42;

    auto futureResult = std::async(&MyClass::memberFunction, &myObject, additionalArgument); //42 or you can use bind

    futureResult.wait();

    return 0;
}
======================================================
can async takes the callable object as the argument?
how to make automatic return type for the function?
bind is defined in which header?
mapping the member function with argument to the callable object without bind

3 different way of calling the member function which return the lamda function
a. calling the member function creating the callable object
b. bind
c. passing directly as an arguument in async

#include <iostream>
#include <future>

class MyClass {
public:
    MyClass() {}

    void performTask(int value) {
        std::cout << "Performing task with value: " << value << std::endl; //42
    }

    auto memberFunction(int value) {
        return [this, value]() {
            std::cout << "Member function called with value: " << value << std::endl; //42
            performTask(value);
        };
    }
};

int main() {
    MyClass myObject;

    int additionalArgument = 42;

    auto callable = myObject.memberFunction(additionalArgument);

    auto futureResult = std::async(std::launch::async, callable);
	// or auto futureResult = std::async(callable); //patform specific it can take deferred or async
	// or auto futureResult = std::async(myObject.memberFunction(additionalArgument));
	// or auto futureResult = std::async(std::bind(&MyClass::memberFunction, &myObject, additionalArgument));==> not calling the performtask

    futureResult.wait();

    return 0;
}
=======================================
callbale object is passed to the async and not the address;
#include <iostream>
#include <future>

int main() {
    int x = 10;
    int y = 20;

    // Using a lambda with std::async
    auto asyncTask = ([x, y]() {
        std::cout << "Asynchronous task started. Sum of x and y: " << (x + y) << std::endl;
    });

    // Call std::async and store the result in std::future variable 'f'
    auto f = std::async(std::move(asyncTask));

    // Wait for the asynchronous task to complete
    f.wait();

    std::cout << "Asynchronous task completed." << std::endl;

    return 0;
}
======================================================
std::packaged_task<> can wrap around a normal function and make it applicable to run as asynchronous function.
When std::packaged_task<> is called in a separate thread, it calls the associated callback and stores the 
return  value/exception in its internal shared state.
 This value can be accessed in other thread or main function through std::future<> object.
 ==============
 different way of creating the thread
 in thread we cannot call the function directly like
 
 thread t(function(12)); //error //will not be error when the function is returning the lamda.
 thread t(function,12);//ok //function is function taking int and returning int.
 void foo(param)
{
  Statements;
}
// The parameters to the function are put after the comma
std::thread thread_obj(foo, params);
==========
Launching Thread Using Lambda Expression
std::thread object can also be launched using a lambda expression as a callable. The following code snippet demonstrates how this is done:

// Define a lambda expression
auto f = [](params)
{
    Statements;
};
 
// Pass f and its parameters to thread
// object constructor as
std::thread thread_object(f, params);
Launching Thread Using Function Objects
Function Objects or Functions can also be used for launching a thread in C++. The following code snippet demonstrates how it is done:

// Define the class of function object
class fn_object_class {
    // Overload () operator
    void operator()(params)
    {
      Statements;
    }
}
 
// Create thread object
std::thread thread_object(fn_object_class(), params)
//or 
//fn_object_class obj;
//std::thread thread_object(obj, params);; //not like  std::thread thread_object(obj(), params)
Note: We always pass parameters of the callable separately as arguments to the thread constructor.
=======================
// C++ program to demonstrate
// multithreading using three
// different callables.
#include <iostream>
#include <thread>
using namespace std;
 
// A dummy function
void foo(int Z)
{
  for (int i = 0; i < Z; i++)
  {
    cout << "Thread using function"
            " pointer as callable\n";
  }
}
 
// A callable object
class thread_obj {
public:
    void operator()(int x)
    {
      for (int i = 0; i < x; i++)
        cout << "Thread using function"
                " object as callable\n";
    }
};
 
// Driver code
int main()
{
  cout << "Threads 1 and 2 and 3 "
          "operating independently" << endl;
   
  // This thread is launched by using
  // function pointer as callable
  thread th1(foo, 3);
 
  // This thread is launched by using
  // function object as callable
  thread th2(thread_obj(), 3);
   
  // Define a Lambda Expression
  auto f = [](int x)
  {
    for (int i = 0; i < x; i++)
      cout << "Thread using lambda"
              " expression as callable\n";
  };
   
  // This thread is launched by using
  // lambda expression as callable
  thread th3(f, 3);
   
  // Wait for the threads to finish
  // Wait for thread t1 to finish
  th1.join();
   
  // Wait for thread t2 to finish
  th2.join();
   
  // Wait for thread t3 to finish
  th3.join();
   
  return 0;
}
=================
async function with global function and argument

#include <iostream>
#include <future>

int threadFunction(int value) {
    return value * 2;
}

int main() {
    int value = 42;
    std::future<int> result = std::async(threadFunction, value); // not like std::async(threadFunction(value));
    int finalResult = result.get();
    std::cout << "Final result: " << finalResult << std::endl;
    return 0;
}
========================================
condition wait access the global vraible?
 Here's an example demonstrating the usage of std::condition_variable and std::mutex to implement a notify_all mechanism in C++:

cpp

#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mutex;
std::condition_variable cv;
bool isReady = false;

void waitingThread(int i)
{
    std::unique_lock<std::mutex> lock(mutex); //Both std::unique_lock and std::lock_guard are used to manage the ownership of a mutex within a 
	scoped block. 
	//The main difference is that std::unique_lock offers more flexibility, allowing the mutex to be locked and unlocked at different points,
	whereas std::lock_guard acquires the lock upon construction
	//and releases it upon destruction, making it more suitable for simple locking scenarios
    
	cv.wait(lock, [] { return isReady; }); //if notifythread send the notification without setting the flag to true, then When a thread wakes up from a cv.wait() call, it needs to recheck the
	//condition before proceeding. In this case, the condition being checked is the value of isReady. If the value of isReady is still false, the threads will go back to waiting until the condition becomes true.
    std::cout << "Waiting thread has been notified!" << i <<std::endl;
}

void notifyingThread()
{
    std::this_thread::sleep_for(std::chrono::seconds(2));

    {
        std::lock_guard<std::mutex> lock(mutex);
        isReady = true;
    }

    cv.notify_all();
    std::cout << "Notifying thread has notified all waiting threads!" << std::endl;
}

int main()
{
    std::thread thread1(waitingThread, 1);
    std::thread thread2(waitingThread, 2);
    std::thread thread3(notifyingThread);

    thread3.join();
    thread2.join();
    thread1.join();

    return 0;
}
===
the output maynot be the same since the notify wake up all the waiting thread and the line after the notify_all is not under mutex
Notifying thread has notified all waiting threads!
Waiting thread has been notified!2

Waiting thread has been notified!1
=================================
In this example, we have two waiting threads (thread1 and thread2) and one notifying thread (thread3).
 The waiting threads wait on a condition variable (cv) until a shared flag (isReady) is set to true. The notifying thread sleeps for
 2 seconds and then sets the flag to true and calls notify_all() to wake up all waiting threads.

When executed, the waiting threads will block on the cv.wait() call until the notifying thread notifies them by setting isReady to 
true and calling cv.notify_all(). Once notified, the waiting threads will print a message indicating that they have been notified.

Note that the use of std::lock_guard and std::unique_lock helps ensure thread-safety by automatically acquiring and releasing the mutex lock.
======================
Note: To compile programs with std::thread support use g++ -std=c++11 -lpthread.

======================================
he  std::packaged_task class wraps any Callable objects (function, lambda expression, bind expression,
 or another function object) so that they can be invoked asynchronously. A packaged_task won’t start on its own, 
 you have to invoke it, 
As its return value is stored in a shared state that can be called/accessed by  std::future objects.

Need of packaged_task

The main advantage of a packaged task is that it can link a callable object to a future and that is very 
important in a flooding environment. For example, if we have an existing function that fetches the data from Database
 (DB) and returns it. Now there is a need to execute this function in a separate thread. This can be done using:
 ============================================
 packaged_task
 
 not pakage_task it is packaged_task?
 
 a. normal function
 b. functor
 c. lamda function
 d. what is must required ?
 
 std::move and thread.join
 
 #include <iostream>
#include <thread>
#include <future>
#include <string>
// Fetch some data from DB
std::string getDataFromDB( std::string token)
{
    // Do some stuff to fetch the data
    std::string data = "Data fetched from DB by Filter :: " + token;
    return data;
}
int main()
{
    // Create a packaged_task<> that encapsulated the callback i.e. a function
    std::packaged_task<std::string (std::string)> task(getDataFromDB);
    // Fetch the associated future<> from packaged_task<>
    std::future<std::string> result = task.get_future();
    // Pass the packaged_task to thread to run asynchronously
    std::thread th(std::move(task), "Arg");
    // Join the thread. Its blocking and returns when thread is finished.
    th.join();
    // Fetch the result of packaged_task<> i.e. value returned by getDataFromDB()
    std::string data =  result.get();
    std::cout <<  data << std::endl;
    return 0;
}
Output:

Data fetched from DB by Filter :: Arg
On similar lines we can create a packaged_task with lambda function and function objects too i.e.

Creating packaged_task with Lambda Function
#include <iostream>
#include <thread>
#include <future>
#include <string>
int main()
{
    // Create a packaged_task<> that encapsulated a lambda function
    std::packaged_task<std::string (std::string)> task([](std::string token){
        // Do some stuff to fetch the data
            std::string data = "Data From " + token;
            return data;
    });
    // Fetch the associated future<> from packaged_task<>
    std::future<std::string> result = task.get_future();
    // Pass the packaged_task to thread to run asynchronously
    std::thread th(std::move(task), "Arg");
    // Join the thread. Its blocking and returns when thread is finished.
    th.join();
    // Fetch the result of packaged_task<> i.e. value returned by getDataFromDB()
    std::string data =  result.get();
    std::cout <<  data << std::endl;
    return 0;
}
Output:

Data fetched from DB by Filter :: Arg
 Creating packaged_task with Function Object
#include <iostream>
#include <thread>
#include <future>
#include <string>
/*
 * Function Object to Fetch Data from DB
 */
struct DBDataFetcher
{
    std::string operator()(std::string token)
    {
        // Do some stuff to fetch the data
                    std::string data = "Data From " + token;
                    return data;
    }
};
int main()
{
    // Create a packaged_task<> that encapsulated a lambda function
    std::packaged_task<std::string (std::string)> task(std::move(DBDataFetcher()));
    // Fetch the associated future<> from packaged_task<>
    std::future<std::string> result = task.get_future();
    // Pass the packaged_task to thread to run asynchronously
    std::thread th(std::move(task), "Arg");
    // Join the thread. Its blocking and returns when thread is finished.
    th.join();
    // Fetch the result of packaged_task<> i.e. value returned by getDataFromDB()
    std::string data =  result.get();
    std::cout <<  data << std::endl;
    return 0;
}
 

Output:

Data fetched from DB by Filter :: Arg

=============================
Synchronous and asynchronous thread execution refer to different ways of managing concurrent tasks and the resulting behavior of the program. Here's an explanation of the difference between the two:

Synchronous Thread Execution:

In synchronous thread execution, threads are executed in a sequential and blocking manner.
When a thread performs a task, it blocks the execution of other threads until it completes its task.
Threads wait for the completion of a task before proceeding to the next task.
Synchronous execution ensures that tasks are performed in a specific order, with each task depending on the
 completion of the previous task.
Synchronous execution simplifies program flow and can be useful when tasks have strict dependencies on each other.
Asynchronous Thread Execution:

In asynchronous thread execution, threads are executed concurrently and independently.
Threads are not blocked by each other and can perform tasks simultaneously.
Asynchronous execution allows threads to continue with other work while waiting for long-running tasks or
 operations to complete.
Threads can initiate tasks and move on to other tasks without waiting for the completion of previous tasks.
Asynchronous execution enables efficient utilization of resources and can improve overall program responsiveness.
Asynchronous programming often involves mechanisms such as callbacks, futures, promises, or coroutines to handle the 
results of concurrent tasks.
In summary, synchronous thread execution follows a sequential and blocking approach, where threads wait for each other to complete tasks. On the other hand, asynchronous thread execution allows threads to work independently and concurrently, with the ability to initiate tasks and continue with other work without waiting for task completion. The choice between synchronous and asynchronous execution depends on the specific requirements of the program, the desired performance, and the level of concurrency needed.
-------------------------------
The main advantage is:

Threads share the same address space
Thread remains lightweight
Cost of communication between threads is low.
----------------------
 What are the states associated with the thread?
Runnable: A thread which is ready to run
Running: A thread which is executing is in running state.
Blocked: A blocked thread is waiting for a monitor lock is in this state. This thing can also happen when a thread performs an I/O operation and 
moves to the next state.For example, a thread can be waiting for a condition 
variable to be signaled, waiting for a mutex to be unlocked, or waiting for data to be available in a queue.

Waiting: It is a thread that is waiting for another thread to do the specific action. user input, waiting for timer to expire. waiting for message
in message queue.When a thread is in the "Waiting" state, it is not consuming CPU resources and is effectively paused until the condition it is
 waiting for becomes true.

Timed_waiting: It is a thread that is waiting for another thread to perform.you might use "Timed_waiting" when waiting for a response from a 
remote server, and if the response doesn't arrive within a certain time, you might decide to proceed with a default value or take some other action.
Terminated: A thread that has exited is in this state.
4) Discuss a Thread Life Cycle?
The life cycle of a thread is similar to the life cycle of processes running in an operating system. During its life cycle, the thread can move from 
one state to another. However, it depends on the operation performed on it.
===================
creating the 2 threads in the same line
each thread to have its own variable but declared only once globally

in C++, the thread_local keyword is used to declare variables that have thread-local storage duration. It allows each thread to have its own copy
 of the variable, and each thread can independently access and modify its own copy without affecting the copies in other threads. 
This can be useful when you want to have per-thread state or when you need to avoid synchronization issues in a multi-threaded program.
Note that thread_local variables are default-initialized, meaning they are initialized with the default value (e.g., zero for integers) 
if no explicit initializer is provided

n C++, thread_local is a storage class specifier that allows you to declare thread-local variables. A thread-local variable is a variable that has
 its own unique instance for each thread in the program. Each thread accessing the variable will see its own copy of the variable, and changes
 made to the variable in one thread will not affect its value in other threads.

#include <iostream>
#include <mutex>
#include <string>
#include <thread>
 
thread_local unsigned int rage = 1; 
std::mutex cout_mutex;
 
void increase_rage(const std::string& thread_name)
{
    ++rage; // modifying outside a lock is okay; this is a thread-local variable
    std::lock_guard<std::mutex> lock(cout_mutex);
    std::cout << "Rage counter for " << thread_name << ": " << rage << '\n';
}
 
int main()
{
    std::thread a(increase_rage, "a"), b(increase_rage, "b");
 
    {
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "Rage counter for main: " << rage << '\n';
    }
 
    a.join();
    b.join();
}
Possible output:

Rage counter for a: 2
Rage counter for main: 1
Rage counter for b: 2
=========================================================
check the vector has the even element if so insert in the seperate vector.

#include <iostream>
#include <vector>
#include <algorithm>

// A regular function to filter even numbers
bool isEven(int num) {
    return num % 2 == 0;
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    std::vector<int> evenNumbers;

    std::copy_if(numbers.begin(), numbers.end(), std::back_inserter(evenNumbers), isEven);

    for (int num : evenNumbers) {
        std::cout << num << " ";
    }

    return 0;
}
=======================================================================
what is the header file required for alignas alignof?
differenent ways to use alignas

alignas(alingof(long long int))
alignas(long long int)
alignas/alignof for variable type

// Note: `alignas(alignof(long double))` below can be simplified to simply 
// `alignas(long double)` if desired.
Regarding the discrepancy between alignof(data) and alignof(int), it seems there was a mistake in the previous response. 
The alignment of data is expected to be 16 because it is explicitly aligned using alignas(16).

On the other hand, the alignment of int alone is platform-dependent and typically equals the size of int itself, which is usually 4 bytes on many systems.
 So, alignof(int) returning 4 is the expected behavio
.....
#include <cstddef> //alignof and alignas

int main() {
    alignas(16) char buffer[32];
    std::cout << "Alignment of 'buffer' is " << alignof(decltype(buffer)) << std::endl; //1
    std::cout << "Alignment of 'buffer' is " << alignof((buffer)) << std::endl; //16
    return 0;
}
================
header file for the pointer to the value?
which header file is required for uintrptr_t
which casting is required to cast the pointer to integer?

#include <cstdint> // uintptr_t

int main() {
    int* ptr = nullptr;
    uintptr_t uintptr = reinterpret_cast<uintptr_t>(ptr);  pointer address to the integer value

    std::cout << "uintptr value: " << uintptr << std::endl; //0

    return 0;
}					
=================
example for alignas
a.structure
b. variable
c. array 
d. alignas should be in power of 2

how to print the address of the variable in hexadecimal and decimal.

if you try to alignas(3), you will get error

#include <iostream> //reinterpret_cast
struct alignas(16) AlignedStruct {
    int a;
    double b;
};

int main() {
    std::cout << "Alignment of AlignedStruct: " << alignof(AlignedStruct) << std::endl; //16

    alignas(32) int alignedInt = 5;
    std::cout << "Alignment of type alignedInt: " << alignof(decltype(alignedInt)) << std::endl; //4
    std::cout << "Alignment of alignedInt: " << alignof((alignedInt)) << std::endl;

    alignas(64) char alignedCharArray[8];

    std::cout << "Alignment of alignedCharArray: " << alignof((alignedCharArray)) << std::endl; //64

    AlignedStruct data;
    std::cout << "Alignment of data: " << alignof(data) << std::endl;16
	std::cout << "Alignment of data: " << alignof(decltype(data)) << std::endl;16
    std::cout << "Memory address of data: " << reinterpret_cast<std::uintptr_t>(&data) << std::endl;
    std::cout << "Memory address of data: " << (&data) << std::endl;    

    return 0;
    return 0;
}
=========
Alignment of AlignedStruct: 16
Alignment of alignedInt: 4
Alignment of alignedInt: 32
Alignment of alignedCharArray: 64
Alignment of alignedInt: 16
Memory address of data: 140720349044784
Memory address of data: 0x7ffc026ae030
===========================
what is the need for the alignas and alignof?

The alignas and alignof keywords in C++ provide control over memory alignment, which can be important in certain scenarios where memory 
alignment requirements need to be met. Here are a few practical examples where alignas and alignof are useful:

Structure Packing and Alignment:

Working with Hardware Devices: Some hardware devices, such as graphics cards or specialized processors, have alignment requirements 
for efficient data transfers or processing. By using alignas to align data properly, you can ensure compatibility with such devices 
and maximize performance when interacting with them.

Interoperability with External Libraries: When working with external libraries or APIs that have specific alignment expectations, 
using alignas allows you to align your data structures to match the requirements of those libraries. This ensures proper data exchange 
and avoids issues such as data corruption or performance degradation due to misaligned access.

==================================================
what is the need for static_assert? taking size in template

The static_assert keyword in C++ is used for compile-time assertions. It allows you to check a condition at compile-time and 
generate a compilation error if the condition evaluates to false.
#include <iostream> //reinterpret_cast and static_assert

template <typename T, std::size_t Size>
class Array {
    static_assert(Size > 0, "Size of Array must be greater than zero."); // error: static assertion failed: Size of Array must be greater than zero.
    T data[Size];

public:
    void printSize() {
        std::cout << "Size of Array: " << Size << std::endl;
    }
};

int main() {
    Array<int, 5> arr1; // Valid, Size = 5
    //Array<double, 0> arr2; // Invalid, Size = 0, triggers static_assert

    arr1.printSize(); // Output: Size of Array: 5

    return 0;
}
================
Size of Array: 5
==============================
which header file has the static_assert and reinterpret_cast?

#include <iostream> //static_assert and reinterpret_cast

class MyClass {
    static_assert(sizeof(int) >= 4, "int size must be at least 4 bytes");

public:
    void someFunction() {
        static_assert(sizeof(int) >= 4, "int size must be at least 4 bytes");

        std::cout << "Class member function called." << std::endl;
    }
};

int main() {
    MyClass obj;  //class whole check
    obj.someFunction(); //only inside the function check

    return 0;
}

==============================================================================
header file required to check the datatypes?
integer, floating , union, pointer
compare any other types?

why i need is_integral?
header file required?
Standard Library Compatibility: std::is_integral is part of the C++ Standard Library, ensuring portability and compatibility 
across different compilers and platforms. It follows the standard specification and provides consistent behavior. Comparing a type using
 int == decltype(value) may not be portable or reliable in all scenarios.
 #include <iostream>
#include <type_traits>

int main() {
    int value = 42;
    
    if (std::is_same<decltype(value), int>::value) {
        std::cout << "The type of 'value' is int." << std::endl;
    } else {
        std::cout << "The type of 'value' is not int." << std::endl;
    }

    return 0;
}

============================
type check for union, floating, double and integer? 
is introduced in c++11?

#include <iostream>
#include <type_traits>

class MyClass {
    int x;
    double y;
};

union MyUnion {
    int a;
    float b;
};

int main() {
    std::cout << std::boolalpha;

    std::cout << "Is MyClass a union? " << std::is_union<MyClass>::value << std::endl; //false
    std::cout << "Is MyUnion a union? " << std::is_union<MyUnion>::value << std::endl; //true

    std::cout << "Is double a floating-point type? " << std::is_floating_point<double>::value << std::endl; //true
    std::cout << "Is int a floating-point type? " << std::is_floating_point<int>::value << std::endl; //false

    return 0;
}

 if(std::is_floating_point<decltype(integerVariable)>::value) { }
 ======================================
 header file?
 is_union with static_assert?
 
 #include <iostream>
#include <type_traits>

class MyClass {
    // Class definition
};

int main() {
    static_assert(std::is_union<MyClass>::value, "MyClass must be a union type.");
    std::cout << "Is MyClass a union? " << std::boolalpha << std::is_union<MyClass>::value << std::endl;
    return 0;
}

=========================================
is_integral of long, int, short int, wchar_t , boolean will return true
integral spelling
static_assert in template to find the size
::value not ::values?

#include <iostream>
#include <type_traits>

template <typename T>
void processValue(T value) {
    static_assert(std::is_integral<T>::value, "T must be an integral type"); //here we are accessing the true or false value using the value
	//it is not our local variable.

    // Process the value...
    std::cout << "Processing value: " << value << std::endl;
}

int main() {
    int intValue = 42;
    processValue(intValue);  // OK, int is an integral type

    double doubleValue = 3.14;
    // processValue(doubleValue);  // Error! double is not an integral type

    return 0;
}
==============================
=====================================================
which header file is required for is_heap?
which version of c++ ?
c++11 has is_heap
types of heap?

algorithm not algoritham?

#include <iostream>
#include <vector>
#include <algorithm> //is_heap
#include <vector>
using namespace std;

int main() {
    std::vector<int> vec{9, 5, 7, 2, 3, 6, 8};

    bool isHeap = std::is_heap(vec.begin(), vec.end());

    std::cout << "Is vec a heap? " << std::boolalpha << isHeap << std::endl;

    std::cout << "After make_heap: ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    return 0;
}
                 9
          5                     7
       2     3               6     8

A min heap is a heap where every single parent node, including the root, is less than or equal to the value of its children nodes.
max heap: every parent node, including the root, is greater than or equal to the value of its children nodes.	   
=========================
Is vec a heap? false
After make_heap: 9 5 7 2 3 6 8 
=======================
bind which header file?

bind to call a function takes string?

#include <iostream>
#include <functional>

void greet(const std::string& name) {
    std::cout << "Hello, " << name << "!" << std::endl;
}

int main() {
    auto greetJohn = std::bind(greet, "John");
    greetJohn(); // Calls greet("John")

    auto greetAlice = std::bind(greet, "Alice");
    greetAlice(); // Calls greet("Alice")

    return 0;
}
In this example, std::bind is used to create new callable objects greetJohn and greetAlice by binding the first parameter
 of the greet function to the respective names. When the callable objects are invoked with greetJohn() and greetAlice(),
 they will call greet with the pre-bound 
arguments.
=======================
functional composite?
how to call 2 funtion in bind?

Function Composition:
Functional composition is a technique used in functional programming where two or more functions are combined to create a new function. 
It involves applying one function to the output of another function, effectively chaining them together.
cpp

#include <iostream>
#include <functional>

int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

int main() {
    auto addAndMultiply = std::bind(multiply, std::bind(add, std::placeholders::_1, std::placeholders::_2), 3);
    int result = addAndMultiply(4, 5);
    std::cout << "Result: " << result << std::endl;  // Output: Result: 27

    return 0;
}
In this example, std::bind is used to create a new callable object addAndMultiply. It binds the add function to its first 
two arguments and then binds the result to the multiply function's first argument. When addAndMultiply is invoked with
 arguments 4 and 5, it first adds them (4 + 5 = 9) and then multiplies the result by 3 (9 * 3 = 27).
==============================================
passing the bind callback funtion to another functionwith placeholder:
ie assigning the bind function callback to the functional callback.

#include <iostream>
#include <functional>

void callback(int value) {
    std::cout << "Callback invoked with value: " << value << std::endl;
}

void performOperation(std::function<void(int)> callbackFunc) {
    // Perform some operation
    int result = 42;

    // Invoke the callback function with the result
    callbackFunc(result);
}

int main() {
    auto boundCallback = std::bind(callback, std::placeholders::_1);
    performOperation(boundCallback);

    return 0;
}
In this example, std::bind is used to bind the callback function to a callable object boundCallback.
 The boundCallback is then passed as a callback function to the performOperation function. When performOperation is called, 
 it performs some operation and invokes the callbackFunc with the result.
================================================
assigning the bind of the class taking argument to the function taking void(void)
#include <iostream>
#include <functional>

class MyClass {
public:
    void printMessage(const std::string& message) {
        std::cout << "Message: " << message << std::endl;
    }
};

int main() {
    MyClass obj;

    // Using std::bind to bind the member function to an instance
    auto boundFunction = std::bind(&MyClass::printMessage, &obj, "Hello, world!");

    // Using std::function to store the callable object
    std::function<void()> func = boundFunction;

    // Call the bound member function through the std::function
    func();

    return 0;
}
Message: Hello, world!
================================================
#include <iostream>
#include <functional>

class MyClass {
public:
    void printMessage(const std::string& message) {
        std::cout << "Message: " << message << std::endl;
    }
};

int main() {
    MyClass obj;

    // Using std::bind to bind the member function to an instance
    auto boundFunction = std::bind(&MyClass::printMessage, &obj, "Hello, world!");

    // Using std::function to store the callable object
    std::function<void(int)> func = boundFunction;

    // Call the bound member function through the std::function
    func(10);

    return 0;
}
Message: Hello, world!
==================================================
for_each different way of usage to print the vector element
bindingfunction
functor
functionlamda
assigning the function to function pointer?

using bind for vector?
uninary function - 2 different ways
lamda function
for_each is introduced in ?
what is the key adavantage of for_each?

c++98

Adapting Function Signatures:Certainly! In C++, std::for_each is a higher-order algorithm that operates on a range 
of elements and applies a specified function or callable object to each element in that range. 

unary function.

#include <iostream>
#include <functional>
#include <vector>
#include <algorithm>

void printValue(int value) {
    std::cout << value << " ";
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    std::for_each(numbers.begin(), numbers.end(), std::bind(printValue, std::placeholders::_1));
    std::cout << std::endl;  // Output: 1 2 3 4 5

    return 0;
}
In this example, std::bind is used to adapt the function signature of printValue to match the requirements of std::for_each.
 The printValue function takes an int argument, but std::for_each expects a function that takes a single argument of the
 iterator's value type. By binding printValue with std::placeholders::_1, we create a new callable object that accepts 
 a single argument compatible with std::for_each.
============================================================
for_each using functor object?
#include <iostream>
#include <vector>
#include <algorithm>

// Functor class to print the square of each element
class SquareFunctor {
public:
    void operator()(int x) const {
        std::cout << x * x << " ";
    }
};

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    // Using a functor with std::for_each
    SquareFunctor squareFn;
    std::for_each(numbers.begin(), numbers.end(), squareFn);

    return 0;
}
========================================
of_each using functor class?

#include <iostream>
#include <vector>
#include <algorithm>

// Functor class to print the square of each element
class SquareFunctor {
public:
    void operator()(int x) const {
        std::cout << x * x << " ";
    }
};

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    // Using a functor with std::for_each
    SquareFunctor squareFn;
    std::for_each(numbers.begin(), numbers.end(), SquareFunctor());

    return 0;
}
==============================================
what is unary function?
for_each using using unary function to calculate the square?
for_eah using function pointer?

unary function takes single argument and generate single result.

#include <iostream>
#include <algorithm>
#include <vector>

void printSquare(int x) {
    std::cout << x * x << " ";
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    // Using std::for_each to print the squares of the elements
    std::for_each(numbers.begin(), numbers.end(), printSquare); // Output: 1 4 9 16 25
	// Using a function pointer to adapt the signature
    ////void (*funcPtr)(int) = printSquare;
    std::for_each(numbers.begin(), numbers.end(), funcPtr); //

    return 0;
}
===================================================
for_each using lamda function to print the value?

afs(adapding functional signature)

#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    // Using a lambda expression to adapt the signature
    std::for_each(numbers.begin(), numbers.end(), [](int x) {
        std::cout << x * x << " ";
    }); // Output: 1 4 9 16 25

    return 0;
}

=====================================================
Delaying Function(taking string) Invocation using bind in main.
#include <iostream>
#include <functional>

void printMessage(const std::string& message) {
    std::cout << message << std::endl;
}

int main() {
    auto delayedPrint = std::bind(printMessage, "Delayed message");
    
    // Delayed invocation
    // ...
    // Some time later
    delayedPrint();  // Output: Delayed message

    return 0;
}
In this example, std::bind is used to create a callable object delayedPrint that holds the printMessage 
function and its argument. The function is invoked later when delayedPrint() is called, resulting in the delayed 
execution of the printMessage function.
====================================================
bind taking the fixed input (string)and variable input and callingg the function:
Simplifying Function Calls:
cpp

#include <iostream>
#include <functional>
placeholders not placeholder?

void printMessage(const std::string& message, int count) {
    for (int i = 0; i < count; ++i) {
        std::cout << message << std::endl;
    }
}

int main() {
    auto printHello = std::bind(printMessage, "Hello", std::placeholders::_1);
    printHello(3);  // Output: Hello Hello Hello

    return 0;
}
In this example, std::bind is used to create a callable object printHello that fixes the first argument of printMessage 
to "Hello". When printHello is called with an argument (3 in this case), it invokes printMessage with the fixed 
argument along with the provided argument.
===================
Write a program that uses std::bind to create a function object that multiplies two numbers and subtracts a third number from the result.

function composite: (multiply and subtract)
fixed and variable value

#include <iostream>
#include <functional>

int multiply(int a, int b) {
    return a * b;
}

int subtract(int a, int b) {
    return a - b;
}

int main() {
    auto multiplyAndSubtract = std::bind(subtract, std::bind(multiply, std::placeholders::_1, std::placeholders::_2), std::placeholders::_3);

    int result = multiplyAndSubtract(4, 5, 2);
    std::cout << "Result: " << result << std::endl;  // Output: Result: 18

    return 0;
}
In this example, we define the multiply and subtract functions to perform the respective operations. Then, using std::bind, we create a function object multiplyAndSubtract. We bind the first two arguments of multiply using std::placeholders::_1 and std::placeholders::_2. Similarly, we bind the third argument of subtract using std::placeholders::_3. When multiplyAndSubtract is invoked with arguments 4, 5, and 2, 
it multiplies 4 and 5 to get 20 and subtracts 2, resulting in the final result of 18.
============================================================================================
bind argument reversing?
function argument and bind function argument difference ?

bind function with paritial and fixed variable arguments:
// C++ code to demonstrate placeholder
// property 2
#include <functional> // for bind()
#include <iostream>
using namespace std;
 
// for placeholders
using namespace std::placeholders;
 
// Driver function to demonstrate bind()
void func(int a, int b, int c)
{
    cout << (a - b - c) << endl;
}
 
int main()
{
    // for placeholders
    using namespace std::placeholders;
 
    // 1 placeholder
    auto fn1 = bind(func, _1, 2, 4);  //actual function argument
 
    // calling of function with 1 argument
    cout << "The value of function with 1 "
            "placeholder is : ";
    fn1(10); //10 -2 -4 //bind function argument
 
    // 2 placeholders
    auto fn2 = bind(func, _1, 2, _2);
 
    // calling of function with 2 arguments
    cout << "The value of function with 2"
            " placeholders is : ";
    fn2(13, 1); // 13 -2 -1
 
    // 3 placeholders
    auto fn3 = bind(func, _1, _3, _2);
 
    // calling of function with 3 arguments
    cout << "The value of function with 3 "
            "placeholders is : ";
    fn3(13, 1, 4); //13-4-1
 
    return 0;
}
Output:

The value of function with 1 placeholder is : 4
The value of function with 2 placeholders is : 10
The value of function with 3 placeholders is : 8
====================
how the bind handle the overload member function inside the class in c++?
takes the return type, class pointer and the argument?
header file for bind?
namesace for bind?


static_cast<void(myclass::*)(int)>
class MyClass {
public:
    void memberFunction(int value) {
        std::cout << "Member function called with value: " << value << std::endl;
    }

    void overloadedFunction(int value) {
        std::cout << "Overloaded member function called with value: " << value << std::endl;
    }

    void overloadedFunction(double value) {
        std::cout << "Overloaded member function called with value: " << value << std::endl;
    }
};

int main() {
    MyClass obj;

    // Bind member function to an object
    auto func1 = std::bind(&MyClass::memberFunction, &obj, std::placeholders::_1);
    func1(42);  // Call memberFunction(42)

    // Bind overloaded member function to an object
    auto func2 = std::bind(static_cast<void(MyClass::*)(int)>(&MyClass::overloadedFunction), &obj, std::placeholders::_1);
    func2(42);  // Call overloadedFunction(int)

    // Bind overloaded member function to an object
    auto func3 = std::bind(static_cast<void(MyClass::*)(double)>(&MyClass::overloadedFunction), &obj, std::placeholders::_1);
    func3(3.14);  // Call overloadedFunction(double)

    return 0;
}
================================================================
================================================================
================================================================
header file for forward?
why we meed forward?
not forward reference for the lvalue needs const 
c++11
(std::forward<T>(x)) note () before x

f an lvalue is passed as the argument to std::forward, it will preserve it as an lvalue reference when forwarding it.

If an rvalue is passed as the argument to std::forward, it will preserve it as an rvalue reference when forwarding it.
std::forward is used in a template function to preserve the original value category (lvalue or rvalue) 
of the arguments when forwarding them to another function.
==========================
// forward example
#include <utility>      // std::forward make_pair
#include <iostream>     // std::cout

preserve the original category
// function with lvalue and rvalue reference overloads:
void overloaded (const int& x) {std::cout << "[lvalue]";}
void overloaded (int&& x) {std::cout << "[rvalue]";}

// function template taking rvalue reference to deduced type:
template <class T> void fn (T&& x) {
  overloaded (x);                   // always an lvalue
  overloaded (std::forward<T>(x));  // rvalue if argument is rvalue
}

int main () {
  int a;

  std::cout << "calling fn with lvalue: ";
  fn (a);
  std::cout << '\n';

  std::cout << "calling fn with rvalue: ";
  fn (0);
  std::cout << '\n';

  return 0;
}
calling fn with lvalue: [lvalue][lvalue]
calling fn with rvalue: [lvalue][rvalue]
================

forward preserve the original value category.
normal variable to rvalue?

#include <iostream>
#include <utility>

// Function that accepts an lvalue reference
void otherFunction(int& x) {
    std::cout << "Lvalue reference: " << x << std::endl;
}

// Function that accepts an rvalue reference
void otherFunction(int&& x) {
    std::cout << "Rvalue reference: " << x << std::endl;
}

// Function template that takes a universal reference and forwards it to another function
template <typename T>
void process(T&& arg) {
    // Forward the argument to another function
    otherFunction(std::forward<T>(arg));
}
int main() {
    int value = 42;

    // Call the process function with an lvalue and an rvalue
    process(value);         // Output: Lvalue reference: 42
    process(std::move(value)); // Output: Rvalue reference: 42

    return 0;
}

----------------------------------------------------------------------------------------


=============================

header file required?
forward reference or universal reference for the thread creation?
thread creation using emplace_back? with universal reference
what is must before joining the thread?
how to create the thread in the vector

#include <iostream>
#include <iostream>
#include <cstdint>
#include <type_traits>
#include <memory>

#include <iostream>
#include <thread>
#include <vector>

class ThreadManager {
public:
    ThreadManager() = default;
    ~ThreadManager() {
        joinAll();
    }

    template <typename Function, typename... Args>
    void createThread(Function&& func, Args&&... args) { //forward reference or universal reference:
        threads.emplace_back(std::forward<Function>(func), std::forward<Args>(args)...);
    }

    void joinAll() {
        for (auto& thread : threads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
        threads.clear();
    }

private:
    std::vector<std::thread> threads;
};

// Example usage
void threadFunction(int id, int y) {
    std::cout << "Thread " << id << " is running." << y << std::endl;
}

int main() {
    ThreadManager threadManager;

    // Create threads
    for (int i = 0; i < 5; ++i) {
        threadManager.createThread(threadFunction, i, i+1);
    }

    // Do other work in the main thread

    // Wait for all threads to finish
    threadManager.joinAll();

    std::cout << "Main thread exiting." << std::endl;

    return 0;
}


Thread 1 is running.2
Thread 2 is running.3
Thread 3 is running.4
Thread 4 is running.5
Thread 0 is running.1
Main thread exiting.
===

When emplace_back is called, it takes the arguments provided and constructs a new std::thread object directly in the vector's memory.
The arguments passed to emplace_back are forwarded to the constructor of std::thread. These arguments define the function to be executed by the thread and any arguments to be passed to that function.
The std::thread object is created and added to the end of the threads vector, utilizing move semantics to efficiently transfer ownership.
Using emplace_back instead of push_back avoids the need for an additional copy or move operation. It directly constructs the std::thread object in the vector, reducing unnecessary overhead and improving performance.
=================
emplace_back:
a. no unnecessary copy or move
b. no temporary object creation

Constructs the new element in-place at the end of the vector, using the arguments provided.
It avoids unnecessary copying or moving of the element by constructing it directly in the vector's memory.
It is more efficient when working with complex or expensive-to-copy elements, as it eliminates the need for temporary objects.
It requires the element's constructor to be callable with the provided arguments.
It is available in C++11 and later versions.
push_back:

Copies or moves the given element to the end of the vector.
It creates a copy or moves an existing object and inserts it into the vector.
It is suitable when working with simple objects or when there is a need to keep a separate copy of the object.
It relies on the element's copy or move constructor to make a copy or move the object.
It is available in all versions of C++.
==================================

calling the function with argumnet using forward reference?

#include <iostream>
#include <utility>

// Forwarding reference in a template function
template <typename Function, typename... Args>
void callFunction(Function&& func, Args&&... args) {
    std::cout << "Calling the function..." << std::endl;
    std::forward<Function>(func)(std::forward<Args>(args)...);
}

// Function to be called
void printMessage(const std::string& message) {
    std::cout << "Message: " << message << std::endl;
}

int main() {
    std::string message = "Hello, C++!";
    
    // Call the function with a forwarding reference
    callFunction(printMessage, message);

    return 0;
}

=====================================
defining the class template member function outside the class?

template <typename T>
class MyClass {
public:
    MyClass(); // Member function declaration

    void memberFunction(); // Member function declaration

private:
    T data_;
};

// Member function definition outside the class
template <typename T>
MyClass<T>::MyClass() {
    // Implementation goes here
}

// Member function definition outside the class
template <typename T>
void MyClass<T>::memberFunction() {
    // Implementation goes here
}
=============
only class member function taking the template argument?
and defining that function outside?

#include <iostream>

class MyClass {
public:
    MyClass(); // Member function declaration

    template <typename T>
    void memberFunction(T a); // Member function declaration

private:
    int data_;
};

// Member function definition outside the class
MyClass::MyClass() {
    // Implementation goes here
    data_ = 0;
}

// Member function definition outside the class
template <typename T>
void MyClass::memberFunction(T a) {
    // Implementation goes here
    std::cout << "Member function called with argument: " << a << std::endl;
}

int main() {
    MyClass obj;

    obj.memberFunction(10);    // Calling memberFunction with int argument
    obj.memberFunction(3.14);  // Calling memberFunction with double argument

    return 0;
}

===============
Member function called with argument: 10
Member function called with argument: 3.14
===============================================================================================

singleton object without using the pointer

location of the copy and assignement operator and how to remove them;
not necessary to classname::getinstance inside the class

#include <iostream>

class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }

    void someMethod() {
        std::cout << "Calling someMethod()" << std::endl;
    }

    static void destroyInstance() {
        Singleton& instance = getInstance();
        delete &instance;
    }

    // Other member functions...

private:
    Singleton() {
        // Constructor implementation...
        std::cout << "Singleton instance created." << std::endl;
    }

    ~Singleton() {
        // Destructor implementation...
        std::cout << "Singleton instance destroyed." << std::endl;
    }

    // Disable copy constructor and assignment operator
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

int main() {
    Singleton& instance = Singleton::getInstance();

    instance.someMethod();

    Singleton::destroyInstance();

    return 0;
}
In this updated code, a new static member function destroyInstance() is added to the Singleton class. This function is responsible for explicitly deleting the singleton instance.

Inside destroyInstance(), we retrieve the reference to the singleton instance by calling getInstance(). Then, we use the delete keyword to delete the instance by taking the address of the instance and calling delete on it.

In the main() function, after using the singleton instance, we call destroyInstance() to explicitly delete the singleton object.
============================
how to check whether the 2 function are of same type?
header file name?
false nummerical value?
alias name for the function type?
create the function pointer using alias
is alias is function pointer?
what is the difference is_same and is_pointer?

ispointer and is_same take the varibale?

is_same compaision for function in different ways?
(std::is_same<ThreadFunctionType, void(int)>::value) or (std::is_same<ThreadFunctionType, decltype(threadFunction))

error message is not must in static_assert?
ie hello static_assert(std::is_same<ThreadFunctionType, void(int)>::value,"hello")

#include <iostream>
#include <type_traits>

void threadFunction(int id) {
    std::cout << "Thread " << id << " is running." << std::endl;
}

int main() {
    using ThreadFunctionType = decltype(threadFunction);  //function type
	//std::is_pointer<ThreadFunctionType>::value;==> false

    // Check if the type is a function with the expected signature
	// or static_assert(std::is_same<ThreadFunctionType, void(int)>::value);
	

    // Use the type
    ThreadFunctionType* funcPtr = &threadFunction;
    funcPtr(42);

    return 0;
}
In this program, we declare a type alias ThreadFunctionType using decltype(threadFunction). We then use std::is_same from the <type_traits>
 header to assert that the ThreadFunctionType is indeed  a function with the signature void(int). Finally, we assign the function pointer 
 &threadFunction to a variable of type ThreadFunctionType and call it with an argument.
 ===================================
 static_assert with string literal is ontroduced in c++17
 #include <iostream>
#include <type_traits>

class MyClass {
    // Class definition
};

int main() {
    static_assert(std::is_union<MyClass>::value, "MyClass must be a union type.");
    return 0;
}

=====================================================
checking whether the given variable is pointer?

     int* ptr = &num;

    // Check if 'ptr' is a pointer type
    if (std::is_pointer<decltype(ptr)>::value) {
        std::cout << "ptr is a pointer type." << std::endl;
    } else {
        std::cout << "ptr is not a pointer type." << std::endl;
    }
=================
===============================
assigning the callabale object to another callable object type using using no need to know the argument and return type.
 // Assuming you have a function named threadFunction with a specific signature
// (e.g., void threadFunction(int)).

auto threadFunction = [](int param) {
    // Function implementation here
};

// Use decltype with auto for ThreadFunctionType
using ThreadFunctionType = decltype(threadFunction); 

int main() {
    ThreadFunctionType functionPointer = threadFunction;
    // Now you can use functionPointer to call the threadFunction.
    functionPointer(42);

    return 0;
}

 ==============================================================================
 apply ?
 header?
 
 std::apply can be used to call a function with arguments stored in a tuple. (c++17)
 
 #include <iostream>
#include <tuple>

// A function that takes three integers and returns their sum.
int sum(int a, int b, int c) {
    return a + b + c;
}

int main() {
    // Create a tuple containing the arguments to be passed to the 'sum' function.
    std::tuple<int, int, int> arguments = std::make_tuple(1, 2, 3);

    // Use std::apply to call the 'sum' function with the arguments from the tuple.
    int result = std::apply(sum, arguments);

    std::cout << "Result: " << result << std::endl; // Output: Result: 6

    return 0;
}

=================================================================================================================
Tuple cannot be passed as the argument to the thread?

The problem with passing the tuple variable as an argument to the thread creation in C++ is that the std::thread constructor expects the arguments
 to be passed by value or by reference. However, when you pass the tuple directly, it is treated as a single argument, and the std::thread 
 constructor tries to copy or reference the entire tuple as a single object.Since the std::thread constructor cannot handle the tuple directly,
 you need to use a workaround to unpack the tuple and pass its elements as separate arguments to the thread function. 
==================================================================================================================
Creating the reference for the tuple changes only the tuple and not the original value?
make_tuple creating the rvalue reference in the case template having the universal reference?

// if you pass the addess to the tuple we can change the original variable value?
 
#include <iostream>
#include <tuple>

void printArguments(int a, double b, const std::string& c) {
    std::cout << "a: " << a << ", b: " << b << ", c: " << c << std::endl;
}

int main() {
    int a = 42;
    double b = 3.14;
    std::string c = "Hello";

    // Create a tuple with the arguments
    auto arguments = std::make_tuple(a, b, c); //lvalue reference

    // Extract and print the arguments using std::get
    int &extractedA = std::get<0>(arguments);
    double &extractedB = std::get<1>(arguments);
    const std::string& extractedC = std::get<2>(arguments);

    std::cout << "Extracted arguments using std::get:" << std::endl;
    std::cout << "a: " << extractedA << ", b: " << extractedB << ", c: " << extractedC << std::endl;
    extractedA = 12;
    extractedB = 15;
    int &extractedA1 = std::get<0>(arguments);
    double &extractedB1 = std::get<1>(arguments);
    std::cout << "a: " << extractedA1 << ", b: " << extractedB1 << ", c: " << extractedC << std::endl;

    return 0;
}

Extracted arguments using std::get:
a: 42, b: 3.14, c: Hello
a: 12, b: 15, c: Hello
===============================================================================================
when make_tuple returns the rvalue reference?
//if you use make_tuple here it will return the lvalue reference , hence we cannot create the  lvalue reference for it
Args... is called variadic number of arguments
syntax for template  with variadic argument?
extract the first element from the tuple containing the variadiac element

variable argument for the tuple as reference:
std::make_tuple creates a tuple of rvalue references, but we need to create a tuple of lvalue references to 
bind them to the arguments passed by reference.

============
Lvalue References (T&): These are references to existing variables. They can only be bound to lvalues (variables), and they refer to an 
already existing object. They cannot exist on their own. Attempting to store
 them in a container like a tuple would be problematic because the reference would be dangling as soon as the original object goes out of scope.

Rvalue References (T&&): These are typically used to identify temporary values (rvalues) that can be moved from. They can bind to both rvalues 
and lvalues, but they usually indicate that you want to move from the value.

When you declare Args&&... args in your template function, it's a so-called "universal reference." It can be either an lvalue reference or an 
rvalue reference, depending on how it's used when calling the function. 
In your case, it's being used with variables (a, b, c), so they're effectively lvalue references.

When you try to create a tuple with std::tuple<Args...> obj=make_tuple(forward<ARGS>(args)...), you're attempting to create a tuple of references. Since references themselves
 cannot exist independently, this results in a compilation error.

To fix this, you need to make sure that the values are moved into the tuple as copies. That's why you use std::forward<Args>(args)... when 
constructing the tuple. This construct allows the function to accept both
 lvalues and rvalues, and it moves rvalues into the tuple while copying lvalues. This ensures that the tuple holds actual values and not references.
========================================
creating the lvalue reference tuple
difference between forward and tie?

forward<Args>(args)...
in the case tie(args...)
remove reference type..
get<args>(t)... getting the arguments of tuple

#include <iostream>
#include <tuple>
#include <utility>

template<typename... Args>
void printFirstElement(Args&&... args) {
    std::tuple<Args...> obj(std::forward<Args>(args)...); 
	//if you use make_tuple here it will return the rvalue reference , hence we cannot create the  lvalue reference for it
    auto& parameter = std::get<0>(obj);
    std::cout << "First element: " << parameter << std::endl;
}

int main() {
    int a = 42;
    float b = 3.14;
    std::string c = "Hello";

    printFirstElement(a, b, c);

    return 0;
}

First element: 42
============================
creating the lvalue reference and && reference for the original variable?

int main() {
   int x = 42;
std::tuple<int&> tuple1(x);
std::get<0>(tuple1) = 100;
std::cout<<std::get<0>(tuple1);  // This modifies 'x' as well //100
std::cout<<x; //100

    return 0;
}

int main() {
   int x = 42;
std::tuple<int&&> tuple(std::move(x));
std::get<0>(tuple) = 100;
std::cout<<std::get<0>(tuple);  100 // This modifies 'x' as well but it is wrong incorrect usage of && 

    return 0;
}
======================================
header file required for tuple and forward?
std::make_tuple creates a tuple of rvalue references, and in this case, we need a tuple of lvalue references to bind them to the arguments using tie
How to use tie get the variable argument in single variable;

passed by reference

First element: 42
#include <iostream>
#include <tuple>
#include <utility>

template<typename... Args>
void printFirstElement(Args&&... args) {
    std::tuple<Args...> obj = std::tie(args...);
    auto& parameter = std::get<0>(obj);
    std::cout << "First element: " << parameter << std::endl;
}

int main() {
    int a = 42;
    float b = 3.14;
    std::string c = "Hello";

    printFirstElement(a, b, c);

    return 0;
}
===============================================
how to create the tuple removing the reference;
how to use make_tuple for args?

note (args...)
The issue here is related to the fact that you're trying to create a tuple of references (Args&&...), and 
tuples cannot hold references as elements directly. Even though you're using make_tuple(args...), which should create a tuple of values, the type deduction for Args in this context is still deducing the parameters 
as references.
#include <iostream>
#include <tuple>

template<typename... Args>
void printFirstElement(Args&&... args) {
    using TupleType = std::tuple<typename std::remove_reference<Args>::type...>;
    TupleType obj = std::make_tuple(args...);
    
    std::cout << std::get<0>(obj) << std::endl; //42
}

int main() {
    int a = 42;
    float b = 3.14;
    std::string c = "Hello";

    printFirstElement(a, b, c);

    return 0;
}
===================================================
how to use the typeid to print the datatype after removing the reference

std::cout << "Original type: " << typeid(T).name() << std::endl;
    std::cout << "Modified type: " << typeid(typename std::remove_reference<T>::type).name() << std::endl;
===================================================
can i create the empty tuple object for forward reference?

if you pass the template as forward reference we cannot create the emplty tuple like tuple<Arg...> obj; 
in the below program please note there is no &&

emplate<typename... Args>
void printFirstElement(Args... args) {
    std::tuple<Args...>obj;
    [&obj, &args...]() { obj = std::tie(args...); }();
    std::cout << std::get<0>(obj) << std::endl;
}

int main() {
    int a = 42;
    float b = 3.14;
    std::string c = "Hello";

    printFirstElement(a, b, c);

    return 0;
}
===========================================

==============================================
use tie to to individual elements from tuple variadic argument.

template<typename... Args>
void printFirstElement(Args&&... args) {
    //std::tuple<Args...> obj ;
    auto [parameter1, parameter2, parameter3] = std::tie(args...);
    //auto& parameter = std::get<0>(obj);
    std::cout << "First element: " << parameter1 << std::endl;
}

int main() {
    int a = 42;
    float b = 3.14;
    std::string c = "Hello";

    printFirstElement(a, b, c);

    return 0;
}

================================================================================================
member function and template argumnet
member function getting the variable argument and creating the tuple and calling other member function in the thread
creating the new tuple from another tuple which has the function and variable aruments
what is the diffferrence between the tuple and make_tuple?
header file required?
condition before thread join?
typename... Args represents a variadic template parameter. It allows a template to accept an arbitrary number of template arguments of different types.
get the variable arguments from tuple?
apply?
can tuple get be reference?
creating the threat in vector?
why thread member function argument specifies the template type?
what is nedded if the class member function is going to be called in the thread creation?
passing function and tuple to the class function?

&ThreadManager::threadFunctionWrapper : member function
<Function, Args...>: template argument
Args&&... args

#include <iostream>
#include <vector>
#include <thread>
#include <tuple>

class ThreadManager {
public:
    ThreadManager() = default;
    ~ThreadManager() {
        joinAll();
    }

    template <typename Function, typename... Args>
    void createThread(Function&& func, Args&&... args) {
        auto tuple = std::make_tuple(std::forward<Function>(func), std::forward<Args>(args)...); //forward is required for perfect forwarding
        threads.emplace_back(std::thread(&ThreadManager::threadFunctionWrapper<Function, Args...>, this, tuple)); 
    }

    void joinAll() {
        for (auto& thread : threads) {
            if (thread.joinable())
                thread.join();
        }
        threads.clear();
    }

private:
    std::vector<std::thread> threads;

    template <typename Function, typename... Args>
    void threadFunctionWrapper(std::tuple<Function, Args...> tuple) {
        auto& function = std::get<0>(tuple);
        auto arguments = std::make_tuple(std::get<Args>(tuple)...);
        callFunction(function, arguments);
    }

    template <typename Function, typename... Args>
    void callFunction(Function& function, std::tuple<Args...>& arguments) {
        std::apply(function, arguments);
    }
};

// Example usage
void threadFunction(int id) {
    std::cout << "Thread " << id << " is running." << std::endl;
}

int main() {
    ThreadManager threadManager;

    // Create threads
    for (int i = 0; i < 5; ++i) {
        threadManager.createThread(threadFunction, i); //unction = void (&)(int); Args = {int&}
    }

    // Do other work in the main thread

    // Wait for all threads to finish
    threadManager.joinAll();

    std::cout << "Main thread exiting." << std::endl;

    return 0;
}
=====================================================================================
how to pass tuple to a thread?

#include <iostream>
#include <vector>
#include <thread>
#include <tuple>

class ThreadManager {
public:
    ThreadManager() = default;
    ~ThreadManager() {
        joinAll();
    }

    template <typename Function, typename... Args>
    void createThread(Function&& func, Args&&... args) {
        auto boundFunction = [func = std::forward<Function>(func), args = std::make_tuple(std::forward<Args>(args)...)]() mutable {
            std::apply(func, args);
        };
        threads.emplace_back(std::move(boundFunction));
    }

    void joinAll() {
        for (auto& thread : threads) {
            if (thread.joinable())
                thread.join();
        }
        threads.clear();
    }

private:
    std::vector<std::thread> threads;
};

// Example usage
void threadFunction(int id) {
    std::cout << "Thread " << id << " is running." << std::endl;
}

int main() {
    ThreadManager threadManager;

    // Create threads
    for (int i = 0; i < 5; ++i) {
        threadManager.createThread(threadFunction, i);
    }

    // Do other work in the main thread

    // Wait for all threads to finish
    threadManager.joinAll();

    std::cout << "Main thread exiting." << std::endl;

    return 0;
}

Thread Thread Thread 1 is running.0 is running.2 is running.

Thread 3 is running.
Thread 4 is running.

Main thread exiting.
========================================
is_arithmetic_v check if t is of type int, flaot, double 
#include <iostream>

template <typename T>
T add(T a, T b) {
    static_assert(std::is_arithmetic_v<T>, "T must be an arithmetic type");
    return a + b;
}

int main() {
    int result = add(3, 4);
    std::cout << "Result: " << result << std::endl;

    // This line will cause a compilation error because std::string is not an arithmetic type
    // add("Hello", "World");

    return 0;
}
===============================================
#include <iostream>
#include <thread>

void myFunction() {
    std::cout << "Thread is executing..." << std::endl;
}

int main() {
    // Create and launch a thread
    std::thread myThread(myFunction);

    // Wait for the thread to finish
    myThread.join();

    // Attempt to join the thread again (undefined behavior)
    myThread.join();

    std::cout << "Main thread continues..." << std::endl;

    return 0;
}
========================================
there is no need to specify the data type if you declaring the variable in the lamda capture;

    
    void createThread() {
	    int x =10
        auto boundFunction = [x=100](){ //changing the value of x here has no impact outer
            std::cout << x <<"  ";
        };
        boundFunction();
        std::cout << x << "  "; //use the global function
        
    }
100 10 
================================================
if there is no & in the [] we cannot access the argument parameter.
thread cannot take args...

#include <iostream>
#include <vector>
#include <thread>
#include <tuple>

class ThreadManager {
public:
    ThreadManager() = default;
    ~ThreadManager() {
        joinAll();
    }

    template <typename Function, typename... Args>
    void createThread(Function&& func, Args&&... args) {
        auto boundFunction = [&](){//[func = std::forward<Function>(func), args = std::make_tuple(std::forward<Args>(args)...)]() mutable {
            std::apply(func, std::make_tuple(std::forward<Args>(args)...));
        };
        threads.emplace_back(std::move(boundFunction));
    }

    void joinAll() {
        for (auto& thread : threads) {
            if (thread.joinable())
                thread.join();
        }
        threads.clear();
    }

private:
    std::vector<std::thread> threads;
};

// Example usage
void threadFunction(int id) {
    std::cout << "Thread " << id << " is running." << std::endl;
}

int main() {
    ThreadManager threadManager;

    // Create threads
    for (int i = 0; i < 5; ++i) {
        threadManager.createThread(threadFunction, i);
    }

    // Do other work in the main thread

    // Wait for all threads to finish
    threadManager.joinAll();

    std::cout << "Main thread exiting." << std::endl;

    return 0;
}

=====================================================================================
get the individual element from tupel:
moving the tuple in capture list
std::cout << std::get<0>(arguments) << std::endl;
passing the local tuple to the thread creation function? without the local callable object
what is the difference between the make_tuple() and tuple()
make_tuple : uses the template function
tuple: creates the drect initialization

#include <iostream>
#include <thread>
#include <tuple>

void threadFunction(int a, double b, const std::string& c) {
    std::cout << "Thread is running with arguments: " << a << ", " << b << ", " << c << std::endl;
}

int main() {
    int a = 42;
    double b = 3.14;
    std::string c = "Hello";

    // Create a tuple with the arguments
    auto arguments = std::make_tuple(a, b, c);

    // Use std::thread to call the lambda that captures the tuple
    std::thread myThread([tuple = std::move(arguments)]() { //note move has removed the contemt of the argument
        std::apply(threadFunction, tuple);
		std::cout << std::get<0>(tuple); //accessing the first element of the tuple
    });

    // Wait for the thread to finish
    myThread.join();

    return 0;
}
Thread is running with arguments: 42, 3.14, Hello
=====================================================================================
we can pass the tuple to the thread but not the variable argument tuple to the thread.
what points to be considered while passing normal tuple to the thread?

In instantiation of ‘std::thread::thread(_Callable&&, _Args&& ...)

#include <iostream>
#include <thread>
#include <tuple>

void function (const std::tuple<int,double,std::string> &a) //or  void function (std::tuple<int,double,std::string> a) 
{
    
}

int main() {
    int a = 42;
    double b = 3.14;
    std::string c = "Hello";

    // Create a tuple with the arguments
    auto arguments = std::make_tuple(a, b, c);

    // Use std::apply to unpack the tuple and call the threadFunction
    std::thread myThread(function, arguments);

    // Wait for the thread to finish
    myThread.join();

    return 0;
}
=========================================================
print the varaiable argumenets using the tuple?
forwars tuple syntax?
apply taking the lamda function with variable argument

#include <iostream>
#include <tuple>

// Function to print a variable argument tuple
template <typename... Args>
void printTuple(Args&&... args) {
    std::cout << "Printing tuple: ";
    std::apply([](auto&&... t)  //  std::apply([](Args&&... t)
    { 
        ((std::cout << t << " "), ...);  //call the function (std::cout << t << " "), for each element
        
    }, std::forward_as_tuple(args...)); //apply is taking the tuple arguments
    
    std::cout << std::endl;
}

int main() {
    int a = 10;
    double b = 3.14;
    std::string c = "Hello";

    // Call the function with different number of arguments
    printTuple(a);
    printTuple(a, b);
    printTuple(a, b, c);

    return 0;
}
Printing tuple: 10 
Printing tuple: 10 3.14 
Printing tuple: 10 3.14 Hello 
=======================================================================================
variable argument can be the object also?
how to print the variable object data member using the forward reference for the variable argument?

#include <iostream>

// Sample template class
template <typename T>
class VariableTemplate {
public:
    VariableTemplate(T value) : data(value) {}

    void print() {
        std::cout << "Value: " << data << std::endl;
    }

private:
    T data;
};

// Function taking variable template as argument
template <typename... Args>
void printVariableTemplates(Args&&... args) {
    ((args.print()), ...);
}

int main() {
    // Create variable template instances
    VariableTemplate<int> a(42);
    VariableTemplate<double> b(3.14);
    VariableTemplate<std::string> c("Hello");

    // Call the function with different variable templates
    printVariableTemplates(a, b, c);

    return 0;
}
Value: 42
Value: 3.14
Value: Hello
================================================================
=========================================================================================
template meta programming to convert the function to function pointer? and calling a global function
same_v is used in which version of c++?


c++17

#include <iostream>
#include <type_traits>

void threadFunction(int id) {
    std::cout << "Thread " << id << " is running." << std::endl;
}

//place holder for single argument
template <typename Function>
struct ThreadFunctionWrapper;

template <typename ReturnType, typename... Args>
struct ThreadFunctionWrapper<ReturnType(Args...)> {
    using Type1 = ReturnType (*)(Args...);
};

int main() {
    using ThreadFunctionType = ThreadFunctionWrapper<decltype(threadFunction)>::Type1;

    // Check if the type is a function with the expected signature
    static_assert(std::is_same_v<ThreadFunctionType, void(*)(int)>);

    // Use the type
    ThreadFunctionType funcPtr = &threadFunction;
    funcPtr(42);

    return 0;
}
======================================================
getting the first argument from the tuple of variable argment
getting all the avraible argument in different tuple?
how to replace make_tuple with new?
if the tuple is created using the auto then we need typecast in creation
make_tuple allocate the heap? no
casting void pointer to tuple
getting the value for the tuple memory
How you will pass the callback function and the argument to the template?
pthread_create arguments?
pthread thread exit?
why ... is not required getting the argument from variable element.

auto& arguments = std::get<1>(*tuple); //thread argument

make_tuple allocate the heap? no heap memory
#include <iostream>
#include <vector>
#include <pthread.h>

class ThreadManager {
public:
    ThreadManager() = default;
    ~ThreadManager() {
        joinAll();
    }

//vardic template member function
//create function template is decided by the argument it takes.
    template <typename Function, typename... Args>
    void createThread(Function&& func, Args&&... args) {
        pthread_t thread;
        auto tuple = new std::tuple<Function, Args...>(std::forward<Function>(func), std::forward<Args>(args)...);
        pthread_create(&thread, nullptr, threadFunctionWrapper<Function, Args...>, tuple);
        threads.push_back(thread);
    }

    void joinAll() {
        for (auto& thread : threads) {
            pthread_join(thread, nullptr);
        }
        threads.clear();
    }

private:
    std::vector<pthread_t> threads;
};

// Function wrapper to call the actual thread function
template <typename Function, typename... Args>
void* threadFunctionWrapper(void* args) {
    auto tuple = reinterpret_cast<std::tuple<Function, Args...>*>(args);
    auto& function = std::get<0>(*tuple); //thread function
    auto& arguments = std::get<1>(*tuple); //thread argument
    function(arguments);
    delete tuple;
    return nullptr;
}

// Example usage
void threadFunction(int id) {
    std::cout << "Thread " << id << " is running." << std::endl;
}

int main() {
    ThreadManager threadManager;

    // Create threads
    for (int i = 0; i < 5; ++i) {
        threadManager.createThread(&threadFunction, i);
    }

    // Do other work in the main thread

    // Wait for all threads to finish
    threadManager.joinAll();

    std::cout << "Main thread exiting." << std::endl;

    return 0;
}
============================================================================
====================================================================================
singleton instance without the pointer
location of the copy and assignement operator;

If you want to explicitly delete the singleton object at a specific point in your code, you can add a static member function to the Singleton class 
that handles the deletion. Here's an updated version of the code:


#include <iostream>

class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }

    void someMethod() {
        std::cout << "Calling someMethod()" << std::endl;
    }

    static void destroyInstance() {
        Singleton& instance = getInstance(); // if no & Singleton instance then it call the copy constructor
        delete &instance;
    }

    // Other member functions...

private:
    Singleton() {
        // Constructor implementation...
        std::cout << "Singleton instance created." << std::endl;
    }

    ~Singleton() {
        // Destructor implementation...
        std::cout << "Singleton instance destroyed." << std::endl;
    }

    // Disable copy constructor and assignment operator
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

int main() {
    Singleton& instance = Singleton::getInstance();

   // Attempting to create a copy or assign the singleton instance
    // Singleton copy = instance; // Compilation error
    // Singleton anotherInstance;
    // anotherInstance = instance; // Compilation error
	
    instance.someMethod();

    Singleton::destroyInstance();

    return 0;
}

In this updated code, a new static member function destroyInstance() is added to the Singleton class. This function is responsible for 
explicitly deleting the singleton instance.

Inside destroyInstance(), we retrieve the reference to the singleton instance by calling getInstance(). Then, we use the delete keyword to 
delete the instance by taking the address of the instance and calling delete on it.

In the main() function, after using the singleton instance, we call destroyInstance() to explicitly delete the singleton object.

When you run this code, you should see the following output:

Singleton instance created.
Calling someMethod()
Singleton instance destroyed.
This demonstrates that the singleton instance is created, used, and then explicitly deleted using the destroyInstance() function.
==========================================================================
#include <iostream>

class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }

    void someMemberFunction() {
        std::cout << "Some member function of Singleton class\n";
    }

    void destroyInstance() {
        isInstanceDestroyed = true;
    }

private:
    Singleton() {} // Private constructor to prevent instantiation

    Singleton(const Singleton&) = delete; //not neccessary to have see the next program
    Singleton& operator=(const Singleton&) = delete;  //not neccessary to have see the next program

    ~Singleton() {} // Private destructor to prevent manual destruction

    bool isInstanceDestroyed = false;
};

int main() {
    Singleton& instance = Singleton::getInstance();
    instance.someMemberFunction();

    instance.destroyInstance();
    // delete &instance; // Alternative way to delete the instance manually

    // Attempting to use the deleted instance
    // instance.someMemberFunction(); // Accessing deleted instance will result in undefined behavior

    return 0;
}
In this updated example, I've added a destroyInstance() member function to the Singleton class. When called, it sets the isInstanceDestroyed 
flag to true, indicating that the instance is destroyed.
=========================================================================================================================================

class Singleton {
private:
    // Private constructor to prevent instantiation
    Singleton() {
        std::cout << "Singleton instance created." << std::endl;
    }

    // Private destructor to prevent deletion
    ~Singleton() {
        std::cout << "Singleton instance destroyed." << std::endl;
    }

public:
    // Public method to access the singleton instance
    static Singleton& getInstance() {
        static Singleton instance; // The only instance of Singleton
        return instance;
    }

    // Public method to perform singleton tasks
    void someFunction() {
        std::cout << "Executing someFunction." << std::endl;
        // Add your functionality here
    }
};

int main() {
    // Access the singleton instance
    Singleton &singletonInstance = Singleton::getInstance();
    Singleton singletonInstance1=(singletonInstance); /error destructor is in provate section . assignement has no issue
    // Use the singleton instance
    singletonInstance.someFunction();

    // No explicit destruction needed, handled automatically

    return 0;
}

===========================================================================================================================================
how  to check whether the 2 data types are same ?
what header file to include?
how to print true and false in the cconsole?
false value?
is_same comparision syntax?
class, float, int and pthread_t

::value not values?

#include <iostream>
#include <type_traits>

int main() {
    std::cout << std::boolalpha;
    
    // Check if a type is pthread_t
    std::cout << "Is pthread_t: " << std::is_same<pthread_t, pthread_t>::value << std::endl; //true
    
    // Check if a type is MyClass
    class MyClass {};
    std::cout << "Is MyClass: " << std::is_same<MyClass, MyClass>::value << std::endl; //true
	bool isSameFloat = std::is_same<int, float>::value; //false 0

    return 0;
}
==================
header file required?
how to check the object are same type?
value for false?

#include <type_traits>
class MyClass {};

int main() {
    MyClass obj1;
    MyClass obj2;

    bool isSameType = std::is_same<decltype(obj1), decltype(obj2)>::value; //1

    std::cout << "isSameType: " << isSameType << std::endl;

    return 0;
}
=========================================
callable object can point to different function provided the parameter and the return types are the same.
we cannot set the functional object to NULL
#include <functional>
#include <iostream>

int main() {
    // Initialize std::function to a default "null" state
    std::function<void(int)> func1 = [](int) {
        // Default behavior (can be empty or have a specific default action)
        std::cout << "Default behavior or null state." << std::endl;
    };

    // Use the std::function
    func1(42);  // Calls the default lambda behavior

    // Set std::function to a new function
    func1 = [](int x) {
        // New behavior
        std::cout << "New behavior with x = " << x << std::endl;
    };

    // Use the std::function again
    func1(10);  // Calls the new lambda behavior

    // Set std::function back to the default "null" state
    func1 = [](int) {
        std::cout << "Default behavior or null state." << std::endl;
    };

    // Use the std::function after setting it to the "null" state
    func1(99);  // Calls the default lambda behavior

    return 0;
}
=======================================
which version std::function is introduced?
a. how one class memeber function void <int> as the callable object in another class objecct?
b. how to check whether the callable variable is initialized ?
c. header file
d. remember to use const &
e. how to remove the placeholders from the bind function.

using namespace std::placeholders;

function was introduced in c++11
header file name is functional not function

#include <iostream>

#include <iostream>
#include <type_traits>
#include <iostream>

#include <iostream>
#include <iostream>
#include <functional>

// Example class with a public member function
class MyClass {
public:
    void myFunction(int value) {
        std::cout << "myFunction called with value: " << value << std::endl;
    }
};

// Another class with a member function that takes a function pointer as a parameter
class AnotherClass {
public:
    std::function<void(int)> func1;
    void callFunction(const std::function<void(int)>& func, int value) {
        //func1 = func;
        if (static_cast<bool>(func1) == true) //if the func1 is set its value will be true
        {
            func1(42);    //
        }
        else
        {
            std::cout << "not set " <<std::endl;
        }
    }
};

int main() {
    MyClass myObject;
    AnotherClass anotherObject;

    // Bind the member function of MyClass to a std::function
	// pthread can call only the public static function of the class
    auto boundFunction = std::bind(&MyClass::myFunction, &myObject, std::placeholders::_1);

    // Pass the bound function to another class's member function
    anotherObject.callFunction(boundFunction, 42);

    return 0;
}
======================================================================================
==================================================================================
string to void* and back to string;

===============================================

// Disable copy constructor and assignment operator
	  LxThreadManager(const LxThreadManager&) = delete;
      LxThreadManager& operator=(const LxThreadManager&) = delete;
==========================================================
function taking lamda function with argument and calling the class member function
#include <functional>

class MyClass {
public:
    void myFunction(int x) {
        // Your function code here
    }
};

int main() {
    MyClass obj;

    // Using std::bind
    std::function<void(int)> funcPtr = std::bind(&MyClass::myFunction, &obj, std::placeholders::_1);

    // Using a lambda function
    std::function<void(int)> funcRef = [&obj](int x) { obj.myFunction(x); };

    // Now you can call the function through the std::function objects
    funcPtr(42);
    funcRef(42);

    return 0;
}
======================================================
#include <functional>

class MyClass {
public:
    void myFunction(int x) {
        // Your function code here
    }
};

int main() {
    MyClass obj;

    // Using function pointer
    std::function<void(int)> funcPtr = &MyClass::myFunction;//error since not static

    // Using function reference
    std::function<void(int)> &funcRef = obj.myFunction; //error. can take only global and static and not member function

    // Now you can call the function through the pointer or reference
    funcPtr(42);
    funcRef(42);

    return 0;
}
==============================================================
function<> can call only the static member function or global function.assignement dont take take value
bind cal call the static and calass member function?. assignment can take value.
class MyClass {
public:
    static void myFunction(int x) {
        // Your function code here
    }
};

int main() {
    MyClass obj;

    // Using function pointer
    std::function<void(int)> funcPtr = &MyClass::myFunction;

    // Using function reference
    std::function<void(int)> funcRef = MyClass::myFunction;
   // std::function<void(int)> &funcRef1 = MyClass::myFunction; //we cannot create the reference for the function
    // Now you can call the function through the pointer or reference
    funcPtr(42);
    funcRef(42);

    return 0;
}

===========================================================
how to create the reference for the static function?
can i create the reference for the static function using the function pointer?
create the alias for the function pointer type?

#include <iostream>

class MyClass {
public:
    static void myFunction(int x) {
        std::cout << "myFunction called with " << x << std::endl;
    }
};

int main() {
    // Using a function pointer
    void (*funcPtr)(int) = &MyClass::myFunction;

    // Using a reference to the function's type
    using FuncRefType = void(*)(int); //alias
    FuncRefType &funcRef = MyClass::myFunction;//creating the reference to the function pointer type FuncRefType
	//FuncRefType &funcRef = &MyClass::myFunction; //error
    const FuncRefType &funcRef = &MyClass::myFunction;
    // Now you can call the function through the pointer or reference
    funcPtr(42);
    funcRef(42);

    return 0;
}
============================================================
to call the callobject function inside the static member function withe arguments.
static memeber function calling the other member function of the class

	  class MyClass {
public:
    void memberFunction(int value) {
        // Do something with value
    }

    static void staticMemberFunction() {
        MyClass obj;
        int value = 42;

        // Create a callable object (lamda function) using a pointer to obj and member function pointer
        auto callable = [&obj](int val) {
            obj.memberFunction(val);
        };

        // Call the callable object
        callable(value);
    }
};
int main() {
    MyClass::staticMemberFunction();
    return 0;
}
=================
assiging global static function return type void and takes void argument to the callable object and calling it:
function needs &?
does void(void) ?

#include <iostream>
#include <functional>

static void myStaticFunction() { //neednot be static function. can be normal function also
    std::cout << "Static function called." << std::endl;
}

int main() {
    std::function<void(void)> funcParam = myStaticFunction; // no &
	std::function<void()> funcParam = &myStaticFunction; // no error
    funcParam();

    return 0;
}

====================
assiging function to the callable object to the function (void void()) as local variable and passing it to the function taking as single reference:
#include <iostream>
#include <functional>

static void myStaticFunction() {
    std::cout << "Static function called." << std::endl;
}

void function1(std::function<void(void)> &funcParam) {
    funcParam();
}

int main() {
    std::function<void(void)> func = myStaticFunction;
    function1(func);

    return 0;
}
Static function called.
============================================
assiging function to the callable object to the function without local variable using single reference:

#include <functional>

static void myStaticFunction(void) {
    std::cout << "Static function called." << " " << 90 << std::endl;
}

void function1(const std::function<void(void)> &funcParam) { //local object rvalue
    funcParam();
}

int main() {
   function1(myStaticFunction);

    return 0;
}
========================
assiging function to the callable object to the function without local variable using double reference:

static void myStaticFunction(void) {
    std::cout << "Static function called." << " " << 90 << std::endl;
}

void function1(std::function<void(void)> &&funcParam) {
    funcParam();
}

int main() {
   function1(myStaticFunction);

    return 0;
}
========================================
std::string originalString(10, ' ');
    originalString.clear();
    originalString.resize(10, '\0');
	originalString.assign(10, '\0'); 
	datasend.erase(datasend.length()-1); //erase the last character
	 myString.erase(0, 2);//erase first 2 character of the string
===============	
#include <iostream>
#include <string>

int main() {
    std::string originalString;
    originalString.resize(10);
    
    if (originalString.size() > 5) {
        originalString.assign("Hello, World!", 5);
        std::cout << "Substring: " << originalString << std::endl;
    } else {
        std::cout << "The string is too short." << std::endl;
    }

    return 0;
}
Substring: Hello
=======================================
assiging function to the callable object to the function without local variable:

static void myStaticFunction(void) {
    std::cout << "Static function called." << " " << 90 << std::endl;
}

void function1(std::function<void(void)> funcParam) {
    funcParam();
}

int main() {
   function1(myStaticFunction);

    return 0;
}
==========================================
how to create the void function(void) local callable object and pass it to the function.

#include <iostream>
#include <functional>

static void myStaticFunction() {
    std::cout << "Static function called." << std::endl;
}

void function1(std::function<void(void)> funcParam) {
    funcParam();
}

int main() {
    std::function<void(void)> func = myStaticFunction;
    function1(myStaticFunction);

    return 0;
}
Static function called.
==================================================================
how to create the void function(int) callable object using function and pass it to the function

#include <iostream>
#include <functional>

static void myStaticFunction(int a) {
    std::cout << "Static function called." << " " << a << std::endl;
}

void function1(std::function<void(int)> funcParam) {
    funcParam(10);
}

int main() {
    std::function<void(int)> func = myStaticFunction;
    function1(myStaticFunction);

    return 0;
}
Static function called. 10
===============================================================================
event thouh i map the bind funcction with value to the function while calling function expect the arument.

how to pass the void function (int) with value as the callable object to another function?

static void myStaticFunction(int a) { //10 will be passed
    std::cout << "Static function called." << " " << a << std::endl;
}

void function1(std::function<void(int)> funcParam) {
    funcParam(0); // 0 will be taken since (int) is specified
}

int main() {
   function1(std::bind(&myStaticFunction,10)); // std::function<void(int)> funcParam = std::bind(&myStaticFunction,10); function1(funcParam);

    return 0;
}
=========================================================================
static void myStaticFunction(int a) {
    std::cout << "Static function called." << " " << a << std::endl;
}

void function1(std::function<void(int)> funcParam) {
    funcParam(0); // 0 will not be taken
}

int main() {
    std::function<void()> funcParam = std::bind(&myStaticFunction, 10); //& is not must here
    funcParam();

    return 0;
}
==========================================================================
function object with void return type and void argument
function need the return type and the argument type
function object => <void(void)>
function object => <int (int,int)>

#include <iostream>
#include <functional>

void greet() {
    std::cout << "Hello!" << std::endl;
}

int add(int a, int b) {
    return a + b;
}

int main() {
    std::function<void()> func1 = greet;//std::function<void(void)> func1
    std::function<int(int, int)> func2 = add;

    func1(); // Call greet() through the std::function
    int result = func2(3, 4); // Call add() through the std::function

    std::cout << "Result: " << result << std::endl;

    return 0;
}

=======================================================================
When you compile and link your code, resulting in an executable file (e.g., an .exe file), it is typically stored on the hard disk. 
The executable file contains instructions and data necessary for your program to run. However, when you execute the program by running the .exe file,
it gets loaded into the computer's memory (RAM).

Here's how the process works:

Loading: When you execute the .exe file, the operating system loads it into the RAM. The RAM acts as a temporary storage area where the 
program's instructions and data are stored while the program is running.

Execution: Once the program is loaded into the RAM, the processor executes its instructions. The processor fetches the instructions from the
 RAM, processes them, and performs the necessary computations.

Data storage and manipulation: During execution, the program may create variables, arrays, objects, and other data structures that are also 
stored in the RAM. Any data that needs to be processed or manipulated by the program is typically stored in the RAM.

Stack and heap: The RAM is divided into two main areas: the stack and the heap. The stack is used for managing function calls, local variables, 
and storing other temporary data. The heap is used for dynamic memory allocation, where objects and data can be allocated and deallocated as needed.

Memory usage: While the program is running, the RAM is used to store the program's instructions, data, and runtime resources. This includes any 
libraries, frameworks, and dependencies that the program relies on. The amount of RAM used by a program depends on factors such as the size of the
 program, the complexity of the code, and the amount of data it needs to process.

It's important to note that while the executable file is stored on the hard disk, the RAM is used for actual program execution and data storage 
during runtime. The RAM provides fast access to instructions and data, allowing the program to run efficiently. Once you close the program, 
its data is typically cleared from the RAM, freeing up the memory for other programs or tasks.

Yes, the file system is typically cached in RAM to improve performance. When you access files on a storage device, the operating system may cache frequently 
used data and metadata in RAM. 

#include <iostream>

int main() {
    int num1 = 5;
    int num2 = 7;
    int sum = num1 + num2;
    std::cout << "The sum of " << num1 << " and " << num2 << " is " << sum << std::endl;
    return 0;
}
After compiling and linking this code, we obtain an executable file (e.g., sum.exe). When we run this executable, it gets loaded into the RAM 
for execution. The RAM stores the program's instructions, variables, and any other necessary resources.

In this example, the variables num1, num2, and sum are stored in the RAM. The cout statement also requires memory in the RAM to store the output 
temporarily. The RAM is used to execute the program's instructions, perform the addition operation, and display the result on the screen.

While the executable file itself resides on the hard disk, the RAM is utilized to run the program and store the necessary data during its
 execution.
 ===================================================
When an executable is loaded and executed using system calls like execv, and a new shell is created to execute the program, the process involves 
a few additional steps. Let's look at the process with more details:

Command execution: The parent shell receives the command to execute the program. The shell forks a new process to create a child process, which
 will execute the program.

Forking: The fork() system call is used to create a new child process that is an exact copy of the parent process, including the shell environment
 and memory contents.

Loading the executable: The child process uses the execv system call (or a related system call like execve, execvp, etc.) to replace its current 
program with the specified executable. The child process loads the executable into its memory space, overwriting its previous contents.

Execution: The child process starts executing the loaded program from its entry point (e.g., main() function). The operating system transfers 
control to the program, and it begins its execution.

New shell: If the program being executed is a shell script or interpreter, a new shell environment is created within the child process. This new 
shell is responsible for interpreting and executing the commands within the script.

Execution of the program or script: The new shell environment executes the commands within the program or script sequentially, following the 
specified logic and flow.

Completion and return: After the program or script execution is complete, the child process terminates. At this point, if the new shell was 
created solely for executing the program, the child process terminates, and the control returns to the parent shell.

Parent shell: Once the child process terminates, the parent shell resumes its execution. It can perform further actions or display the shell 
prompt to accept new commands.

The execv system call is commonly used for executing programs in Unix-like systems. It replaces the current process image with a new one, and the 
loaded program starts from its entry point. This allows the execution of different programs within the same process space, saving the overhead of 
creating separate processes for each program.

In summary, when an executable is loaded and executed using execv with a new shell created, the parent shell forks a child process, which replaces 
its memory contents with the executable using execv. The new shell environment interprets and executes the commands within the program or script, and upon completion, the control returns to the parent shell.
================================================================================
================================================================================
list of arguments that the main function can take and how to print it?

#include <iostream>

int main(int argc, char* argv[], char* envp[]) {
    std::cout << "Number of arguments: " << argc << std::endl;
    for (int i = 0; i < argc; i++) { // or for (int i = 0;  argv[i] != nullptr; i++) {
        std::cout << "Argument " << i << ": " << argv[i] << std::endl;
    }

    std::cout << "Environment variables:" << std::endl;
    for (int i = 0; envp[i] != nullptr; i++) {
        std::cout << "Variable " << i << ": " << envp[i] << std::endl;
    }
    
    return 0;
}
When you execute the program, it will display the command-line arguments as well as the environment variables:

ruby

Number of arguments: 1
Argument 0: ./myprogram
Environment variables:
Variable 0: PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
Variable 1: HOME=/home/user
Variable 2: USER=user
...
========================================================
how to make sure that the int always takes 2 bytes?

int16_t type, defined in the <cstdint> ensure the sizeof the short is always 2 bytes.
<cstdint> also has the uintptr_t
===============================================================================================

Union and enum inside the structure
================================================

, is for enum
; for union and struct
copy data to structure memebrs
structure object declaration

#include <stdio.h>

typedef enum {
    TYPE_INT,
    TYPE_FLOAT,
    TYPE_STRING
} DataType;

typedef union {
    int intValue;
    float floatValue;
    char stringValue[50];
} DataValue;

struct Data {
    DataType dataType;
    DataValue value;
};

int main() {
    struct Data data1;
    data1.dataType = TYPE_INT;
    data1.value.intValue = 42;

    struct Data data2;
    data2.dataType = TYPE_FLOAT;
    data2.value.floatValue = 3.14;

    struct Data data3;
    data3.dataType = TYPE_STRING;
    strcpy(data3.value.stringValue, "Hello, World!");

    // Accessing the values based on data type
    switch (data1.dataType) {
        case TYPE_INT:
            printf("Data1: %d\n", data1.value.intValue);
            break;
        case TYPE_FLOAT:
            printf("Data1: %f\n", data1.value.floatValue);
            break;
        case TYPE_STRING:
            printf("Data1: %s\n", data1.value.stringValue);
            break;
    }

    // Similar switch cases for data2 and data3

    return 0;
}
===============================================================================
binary value setting:or binary literal
=================
// C++ code to demonstrate working of
// "binary" numbers
#include<iostream>
using namespace std;
int main()
{
    auto number = 0b011; //3
    cout << number;
    return 0;
}
========================
where can be the declaration of delete and default function

=============
deleted function can be only inline
/ Sample C++ code to demonstrate the
// incorrect syntax of declaring a member
// function as delete
class C
{
public:
    C();
};
 
// Error, the deleted definition 
// of function C must be the first
// declaration of the function.
C::C() = delete;
======================================
It is very important to note that A deleted function is implicitly inline. A deleted definition of a function must be the first declaration 
of the function. In other words, the following way is the correct way of 
declaring a function as deleted:
 

class C 
{
public:
         C(C& a) = delete;
};
==================================================
Disabling undesirable argument conversion 

a. it can be for the constructor
b. user defined function
c. default argument

// C++ program to disable undesirable argument
// type conversion using delete operator
#include <iostream>
using namespace std;
 
class A {
public:
    A(int) {}
 
 
    // Declare the conversion constructor as a
    // deleted function. Without this step,
    // even though A(double) isn't defined,
    // the A(int) would accept any double value
    // for it's argumentand convert it to an int
    A(double) = delete;//A(double=90) = delete; // 90 has no impact
	int A1(double) = delete;//default argument value has no impact
};
 
int main()
{
    A A1(1);
     
    // Error, conversion from
    // double to class A is disabled.
    A A2(100.1);
    return 0;
}
=======================================================
can the delete be a normal function instead of class member function?
can default be a normal function?

delete keyword can be for the global function also

// Deleting a global function
void myFunction() = delete;

// Deleting a specific overload of a global function
void myFunction(int) {
    std::cout << "Calling myFunction(int)" << std::endl;
}
========================================================
default memeber function cannot take?

argument constructor.

A defaulted function needs to be a special member function (default constructor, copy constructor, destructor etc), or has no default arguments. 
 should be generated by the compiler and follow its default behavior.
For example, the following code explains that non-special member functions 
can’t be defaulted: 
 
// C++ code to demonstrate that
// non-special member functions
// can't be defaulted
class B {
public:
 
    // Error, func is not a special member function.
    int func() = default;
     
    // Error, constructor B(int, int) is not
    // a special member function.
    B(int, int) = default; //custom implementation is required for this constructor, it cannot be declared as default.
 
    // Error, constructor B(int=0)
    // has a default argument.
    B(int = 0) = default; //custom implementation is required for this constructor, it cannot be declared as default.
};
 
// driver program
int main()
{
    return 0;
}
=======================
Can you make already defined function as default()?

class MyClass {
public:
     MyClass() {}  // Already explicitly defined function

     MyClass() = default;  // error: ‘MyClass::MyClass()’ cannot be overloaded with ‘MyClass::MyClass()’
};
========================================================
Can the function be default and delete at the same time?

//same function cannot be default and delete;
class MyClass {
public:
    MyClass() = delete;  
    MyClass() = default;  // ‘MyClass::MyClass()’ cannot be overloaded with ‘MyClass::MyClass()’
};
=====================================================
Can the user defined function be default or delete?
in which access specifier the default and delete?

class sample
{
   int myfunction() = default; //error
} 

default keyword is not applicable for defining the default implementation of regular member functions. 
It is mainly used for special member functions like constructors, copy constructors, copy assignment 
operators, and destructors.
class Sample {
public:
    int myFunction() {
        // Default implementation
        return 42;
    }
};


//default and delete member function can be inside any of the accesss specifier.

how to overlaod the assignemen opertaor?

========================================================================================
Preventing Object Copy in C++ (3 Different Ways)
=============================================
how to assign the data members in the definition of the construction?

Keeping the Copy Constructor and Copy assignment operator as private in the class.

define the copy constructor and the assignment operator in the private section of the code:
// Copy constructor
    Base(const Base& obj) : x(obj.x) {   }
  
    // copy assignment operator
    Base& operator=(const Base& tmp_obj)
    {
        x = tmp_obj.x;
        return *this;
    }
------------------------------------------
inherit a Dummy class with a private copy constructor and a private copy assignment operator.
Below is the C++ implementation to illustrate how this can be done.


#include <iostream>
using namespace std;
  
class Dummy {
public:
    Dummy() {  }
private:
    Dummy(const Dummy& temp_obj)  {   }
    Dummy& operator=(const Dummy& temp_obj)   {   }
};
  
class Base : public Dummy {
    int x;
public: 
    Base()  {   }
    Base(int y) : x(y)  {  }
};
  
int main()
{
    Base b1(10);
    Base b2(b1); // Calls copy constructor
    b2 = b1; // Calls copy assignment operator
    return 0;
}
prog.cpp: In function 'int main()':

prog.cpp:12:5: error: 
'Dummy::Dummy(const Dummy&)' is private
     Dummy(const Dummy &temp_obj)
-------------------------------------------------------
Using Deleted copy constructor and copy assignment operator: Above two ways are quite complex, C++11 has come up with a simpler solution
 i.e. just delete the copy constructor and assignment operator.
Below is the C++ implementation to illustrate :


// CPP program to demonstrate use Delete copy
// constructor and delete assignment operator
#include <iostream>
using namespace std;
  
class Base {
    int x;
public:
    Base()   {     }
    Base(int y) : x(y) {    }
    Base(const Base& temp_obj) = delete;
    Base& operator=(const Base& temp_obj) = delete;
};
  
int main()
{
    Base b1(10);
    Base b2(b1); // Calls copy constructor
    b2 = b1; // Calls copy assignment operator
    return 0;
}
prog.cpp: In function 'int main()':
prog.cpp:24:15: error: use of deleted function
 'Base::Base(const Base&)'
     Base b2(b1); // Calls copy constructor
-----------------------------------------------------
==========================================================================================================================
placement new:
----------------
a. what is placement new
b. placement new example for array
c. pointer to array

Placement new is a variation new operator in C++. Normal new operator does two things : 
(1) Allocates memory 
(2) Constructs an object in allocated memory. 

Placement new allows us to separate above two things. In placement new, we can pass a preallocated memory 
and construct an object in the passed memory. 
================================================
pointer to the next element:
pointer to the end of the array

int* ptr = &myArray[0] + 1;
int* ptr = myArray+ 1; //pointer to the 2nd element
// ptr now points to the address of the second elemen
==========
int myArray[] = {1, 2, 3, 4, 5};
int* ptr = &(myArray + 1);
================================================== 

new vs placement new

Normal new allocates memory in heap and constructs objects there whereas using placement new, object construction can be done at known address.
With normal new, it is not known that, at what address or memory location it’s pointing to, whereas the address or memory location that it’s pointing is known while using placement new.
The deallocation is done using delete operation when allocation is done by new but there is no placement delete, but if it is needed one can write it
with the help of destructor

// C++ program to illustrate the placement new operator
#include<iostream>
using namespace std;
  
int main()
{
    // buffer on stack
    unsigned char buf[sizeof(int)*2] ;
  
    // placement new in buf
    int *pInt = new (buf) int(3);
  
    int *qInt = new (buf + sizeof (int)) int(5);
    int *pBuf = (int*)(buf+0) ;
    int *qBuf = (int*) (buf + sizeof(int));
    cout << "Buff Addr             Int Addr" << endl;
    cout << pBuf <<"             " << pInt << endl;
    cout << qBuf <<"             " << qInt << endl;
    cout << "------------------------------" << endl;
    cout << "1st Int             2nd Int" << endl;
    cout << *pBuf << "                         "
         << *qBuf << endl;
  
    return 0;
}
Output: 
 

Buff Addr              Int Addr
0x69fed8               0x69fed8
0x69fedc               0x69fedc
------------------------------
1st Int                2nd Int
3                      5
------------------------------------------------------------
placement new for the class with syntax?

operator new return type?

a. deleting the memory
b. deleting the object

how to avoid double free?
allocating memory for pointer class?


#include <iostream>

class MyClass {
public:
    MyClass() {
        std::cout << "Constructor called" << std::endl;
    }

    ~MyClass() {
        std::cout << "Destructor called" << std::endl;
    }

    void display() {
        std::cout << "Hello, I am an object of MyClass" << std::endl;
    }
};

int main() {
    // Allocate memory using placement new
    void* memory = operator new(sizeof(MyClass));

    // Create an object at the allocated memory address using placement new
    MyClass* obj = new(memory) MyClass();

    // Call member function on the object
    obj->display();

    // Manually invoke the destructor
    obj->~MyClass(); //only destrutor is called , memory is not freed.

    // Deallocate the memory using placement delete
    operator delete(memory); // will call only the memory free , destructor is not called.

    return 0;
}
=====================================================================================
deleting the class object for the placement new

class MyClass {
public:
    MyClass() {
        std::cout << "Constructor called" << std::endl;
    }

    ~MyClass() {
        std::cout << "Destructor called" << std::endl;
    }

    void display() {
        std::cout << "Hello, I am an object of MyClass" << std::endl;
    }
};

int main() {
    // Allocate memory using placement new
    void* memory = operator new(sizeof(MyClass));

    // Create an object at the allocated memory address using placement new
    MyClass* obj = new(memory) MyClass();

    // Call member function on the object
    obj->display();
    delete obj;

    operator delete(memory); // will lead to double free

    return 0;
}

Hello, I am an object of MyClass
Destructor called
free(): double free detected in tcache 2
=====================================================================================
placement new for single integer variable:
======================================================================================
placement new taking the 4 byte address space.

// C++ program to illustrate the placement new operator
#include<iostream>
using namespace std;
int main()
{
    // initial value of X
    int X = 10;
  
    cout << "Before placement new :" << endl;
    cout << "X : " << X << endl;
    cout << "&X : " << &X << endl;
  
    // Placement new changes the value of X to 100
    int *mem = new (&X) int(100);
  
    cout << "\nAfter placement new :" << endl;
    cout << "X : " << X << endl;
    cout << "mem : " << mem << endl;
    cout << "&X : " << &X << endl;
  
    return 0;
}
Output: 
 

Before placement new :
X : 10
&X : 0x69fee8

After placement new :
X : 100
mem : 0x69fee8
&X : 0x69fee8
==============================================================
// Read the entire line, including spaces
string input;
    std::getline(std::cin, input);
	
#include <iostream>
#include <fstream>
#include <string>

int main() {
    // Open a file for reading
    std::ifstream inputFile("example.txt");

    // Check if the file is open
    if (!inputFile.is_open()) {
        std::cerr << "Error opening the file." << std::endl;
        return 1;  // Return with an error code
    }

    // Read the file line by line
    std::string line;
    while (std::getline(inputFile, line)) {
        // Process each line
        std::cout << line << std::endl;
    }

    // Close the file
    inputFile.close();

    return 0;
}

===============================================================
structure binding is introduced in which version?
structured binding (c++17) in the map? 
when make_pair is not required in map?
when we need make_pair?
what are different ways to print string in c++?

cout <<string name or cout <<strinmae.c_str();

Structured binding in C++ :alias to the reference object
#include <bits/stdc++.h>
#include <map>
using namespace std;
  
int main()
{
    // Creating a map with key and value 
    // fields as String
    map<string, string> sites;
      
    sites.insert({ "GeeksforGeeks", "Coding Resources" }); //make_pair is not required since we are using {};
	//make_pair is required if we use sites.insert(make_pair( "GeeksforGeeks", "Coding Resources" ));
    sites.insert({ "StackOverflow", "Q-A type" });
    sites.insert({ "Wikipedia", "Resources + References" });
  
    for (auto & [ key, value ] : sites) // & is not must
    {
       cout << key.c_str() << " " << value.c_str() << endl; // it is not must to have c_str()
    }
      
    return 0;
}
Output :

GeeksforGeeks Coding Resources
StackOverflow Q-A type
Wikipedia Resources + References

=====================================================================
Example 1 : In C++98


#include <bits/stdc++.h>
using namespace std;
  
// Creating a structure named Point
struct Point {
    int x;
    int y;
};
  
// Driver code
int main()
{
    Point p = {1, 2};
      
    int x_coord = p.x;
    int y_coord = p.y;
      
    cout << "X Coordinate : " << x_coord << endl;
    cout << "Y Coordinate : " << y_coord << endl;
  
    return 0;
}
Output :

X Coordinate : 1
Y Coordinate : 2
===================================================
structured binding using the 
a. overloading opertaor?
b. using tie 
c. auto []

Example 2 : In C++11/C++14


#include <bits/stdc++.h>
#include <tuple>
using namespace std;
  
// Creating a structure named Point
struct Point
{
    int x, y;
      
    // Default Constructor
    Point() : x(0), y(0) 
    {
          
    }
      
    // Parameterized Constructor for Init List
    Point(int x, int y) : x(x), y(y) 
    {
          
    }
    auto operator()()
    {
        // returns a tuple to make it work with std::tie
        return make_tuple(x, y); 
    }
};
  
// Driver code
int main()
{
    Point p = {1, 2};
    int x_coord, y_coord;
    tie(x_coord, y_coord) = p();
      
    cout << "X Coordinate : " << x_coord << endl;
    cout << "Y Coordinate : " << y_coord << endl;
      
    return 0;
}
Output :

X Coordinate : 1
Y Coordinate : 2

for Point p;
X Coordinate : 0
Y Coordinate : 0

for Point p(12,13);
X Coordinate : 12
Y Coordinate : 13

int x_coord, y_coord;
tie(x_coord, y_coord) = p();

===>
auto [x_coord, y_coord]= p(); //tuple can be used with tie and auto also
or
auto [x_coord, y_coord]= p;

====================================================================================
structure binding willnot work on?

structured binding decompose will not work for the private or protected data member: In C++17

#include <bits/stdc++.h>
using namespace std;
  
struct Point
{
    int x; //members has to only public and private data memebrs cannot be decomposed.
    int y;
};
  
// Driver code
int main( )
{
    Point p = { 1,2 };
      
    // Structure binding
    auto[ x_coord, y_coord ] = p;
      
    cout << "X Coordinate : " << x_coord << endl;
    cout << "Y Coordinate : " << y_coord << endl;
      
    return 0;
}
Output :

X Coordinate : 1
Y Coordinate : 2
Applications : Structured Binding can be used with arrays to get the elements from the array. In this case, E is an array type, hence the names are bound to the array elements. Below is the implementation to show the same :
=======================================================
which specifier does the structured binding cannot use?
example:


class MyClass {
private: //or protected
    int privateData;

public:
    MyClass(int data) : privateData(data) {}

    int getPrivateData() const {
        return privateData;
    }
};

int main() {
    MyClass obj(42);

    auto [x] = obj;  // Error: Cannot access private and protected data member directly

    return 0;
}
In this example, MyClass has a private data member privateData and a public member function getPrivateData() to access it. 
In the main function, we create an object obj of type MyClass and initialize its private data member.

However, when we try to use structured bindings with auto [x] = obj;, we encounter a compilation error.
 This error occurs because structured bindings cannot directly access the private data member privateData of MyClass.

To make structured bindings work with private data members, you can provide public member functions that allow access to those private members. 
In the example above, you could modify MyClass to include a public getter function, like getPrivateData(), which can be used to retrieve the 
private data and then bind it using structured bindings.
=========================================================================================================
how to return one value from the function to the structred varaiable
when the advantage of structured binding comes in role?

the advantage of structure binding comes in picture when we want to decompose the multiple variable.
class MyClass {
private:
    int privateData;

public:
    MyClass(int data) : privateData(data) {}

    int getPrivateData() const {
        return privateData;
    }
};

int main() {
    MyClass obj(42);

    auto [x] = std::make_tuple(obj.getPrivateData()); //here we are decomposing the single variable so no advantage of structured binding
	//simply you can make it as int x = obj.getPrivateData()

    // Using structured bindings to access private data member
    std::cout << "Private Data: " << x << std::endl;

    return 0;
}

==================================================================
does auto keyword work on array?
how the structured binding work on array?

structured binding in c++

#include <bits/stdc++.h>
using namespace std;
  
int main()
{
  
    int arr[3] = { 1, 2, 3 }; // auto keyword will not work for array. the number of elements in the array and the number in [] has to match
      
    // Here, E is an array type, hence the 
    // names are bound to the array elements.
    auto[x, y, z] = arr; // number of elemenets and the array elements needs to match
      
    cout << x << " " << y << " " << z << endl;
  
    return 0;
}
Output :


1 2 3
==================================================
what is strutured binding ?
how structured binding is useful when returning from the function?

Structured bindings (introduced in c++17) in C++ allow you to declare and initialize multiple variables from 
a single expression that returns a structured type, such as a tuple or a user-defined type with non-static 
data members. It provides a convenient way to decompose the elements 
of a structured type into individual variables.

Here's an example of how structured bindings can be used in C++17:

different ways to extract the elements from the function returing the tuple?

#include <iostream>
#include <tuple>

std::tuple<int, double, std::string> getPerson()
{
    return std::make_tuple(25, 175.5, "John Doe");
}

int main()
{
    auto [age, height, name] = getPerson(); //int age;    double height;    std::string name; std::tie(age, height, name) = getPerson();

    std::cout << "Name: " << name << std::endl;
    std::cout << "Age: " << age << std::endl;
    std::cout << "Height: " << height << std::endl;

    return 0;
}
=============================================
header 
array declaration for charecter and initialization?
tuple cannot take characterer array since the array is not copyable like
tuple <char[]>
tuple delclaration needs to use 
tuple definion for const char*

declaration :<>
definition()

#include <iostream>
#include <tuple>

int main() {
    // Create a tuple with a character array
    std::tuple<const char*> myTuple = std::make_tuple("Hello, World!");

    // Access and print the character array from the tuple
    const char* str = std::get<0>(myTuple);
    std::cout << str << std::endl;

    return 0;
}
==========================================================
stl::array taking  character
array declaration and definition example?
how to find the starting and ending of array

std::array<char, 5> myArray1 = {'h','e','\0'};

========================================================== 
tuple with character array? 
why typecasting is required inside make_tuple?
how to print character string from character array
how to create the reference to the first element
how to print the array?
getting back the array element from tuple?

#include <iostream>
#include <tuple>
#include <array>

int main() {
    // Create a tuple with an std::array of characters
    std::tuple<std::array<char, 6>> myTuple = 
	        std::make_tuple(std::array<char, 6>{'H', 'e', 'l', 'l', 'o', '\0'});

    // Access and print the character array from the tuple
    std::array<char, 6>& charArray = std::get<0>(myTuple);
    std::cout << charArray.data() << std::endl;

    return 0;
}
=======================================
array declaration and initialization?
tuple cannot have have char[]
in C++, arrays are not copyable because they do not have a copy constructor or a copy assignment operator 
defined by default. When you try to copy an array, what actually happens is that a pointer to the array is
 copied, but not the entire contents of the array.

Consider the following example:

cpp

int main() {
    int arr1[] = {1, 2, 3, 4, 5};
    int arr2[5];

    arr2 = arr1; // Error: Arrays are not assignable

    return 0;
}
===============================
whether the structure binding will not work on?

structured binding(introduced in c++17) will not work for class having the static variable:
class MyClass {
public:
    static int staticData;
    int nonStaticData;
};

int MyClass::staticData = 10;

int main() {
    MyClass obj;
    obj.nonStaticData = 20;

    auto [a, b] = obj;  // Error: Cannot use structured bindings with static members

    return 0;
}
=================================
a. reference for the structured type using auto?
b. all the class member variable can be refrence in one line;

class MyClass {
public:
    int staticData;
    double nonStaticData;
};

int main() {
    MyClass obj;
    obj.nonStaticData = 20;

    // Access staticData using regular member access
    obj.staticData = 10;

    // Use structured bindings for non-static data members
    auto& [a, b] = obj;

    // Now you can use a and b as references to nonStaticData and staticData
    a = 30; // Equivalent to obj.nonStaticData = 30;
    b = 5;  // Equivalent to obj.staticData = 5;

    return 0;
}
==================================================================
reference for the structured type using individual data member type?

class MyClass {
public:
    int staticData;
    double nonStaticData;
};

int main() {
    MyClass obj;
    obj.nonStaticData = 20;

    // Access staticData using regular member access
    obj.staticData = 10;

    // Declare variables of specific types (int and double) for structured bindings
    int& a = obj.staticData;
    double& b = obj.nonStaticData;

    // Now you can use a and b as references to nonStaticData and staticData
    a = 30; // Equivalent to obj.staticData = 30;
    b = 5.0;  // Equivalent to obj.nonStaticData = 5.0;

    return 0;
}

====================================================================
array

what is the difference between the char[] and stl array 
stl::array is introduced in the c++11

both the memory size is determined at compile time and the size.
stl::array provide additional functions
=======================================
header file for array?
how to pass the array to a function?
loop over the array?

passing array with  size
#include <iostream>
#include <array>

template<size_t Size>
void printArray(const std::array<int, Size>& arr) {
    for (const auto& element : arr) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
}

int main() {
    std::array<int, 5> myArray1 = {1, 2, 3, 4, 5};
    std::array<int, 3> myArray2 = {10, 20, 30};

    printArray(myArray1);  // Expands to: printArray<5>(myArray1) // we cannot change the number 5 to 3. compiler will give error
    printArray(myArray2);  // Expands to: printArray<3>(myArray2)

    return 0;
}
=====================================
passing array wit data type and size

template<typename T, size_t Size>
void printArray(const std::array<T, Size>& arr) {
    for (const auto& element : arr) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
}

int main() {
    std::array<int, 5> myArray1 = {1, 2, 3, 4, 5};
    std::array<int, 3> myArray2 = {10, 20, 30};

    printArray(myArray1);  // Expands to: printArray<5>(myArray1) // we cannot change the number 5 to 3. compiler will give error
    printArray(myArray2);  // Expands to: printArray<3>(myArray2)

    return 0;
}
====================
sum of the array without the template


int calculateSum(const std::array<int, 5>& arr) {
    int sum = 0;
    for (const auto& element : arr) {
        sum += element;
    }
    return sum;
}

int main() {
    std::array<int, 5> myArray = {1, 2, 3, 4, 5};//runntime
    int sum = calculateSum(myArray);
    std::cout << "Sum: " << sum << std::endl;

    return 0;
}
========
compilation array size using the variable

 const int a = 5;
 std::array<int, a> myArray = {1, 2, 3, 4, 5}; // a has to constant
=====================================================
array:
front, back, at, size, empty, fill and initialization in 2 different lines?
range exception
to get pointer from array
array has begin and end?
array initialization 

std::array<int, 5> myArray = {1, 2, 3, 4, 5};
std::size_t arraySize = myArray.size(); //5

    std::array<int, 0> myArray ;//= {1, 2, 3, 4, 5};
std::size_t arraySize = myArray.size(); //0 here emptyArray.empty(); is true

    std::array<int, 5> myArray ;//= {1, 2, 3, 4, 5};
std::size_t arraySize = myArray.empty(); //1

std::array<int, 5> myArray;
myArray.fill(42);  // {42, 42, 42, 42, 42} 
//or
 std::fill(std::begin(myArray), std::end(myArray), 23);

std::array<int, 5> myArray = {1, 2, 3, 4, 5};
int* dataArray = myArray.data();

std::array<int, 5> myArray;
myArray = {1, 2, 3, 4, 5};
	
we cannot change the size of the stl::array
==========================================
find the front and back

#include <iostream>
#include <array>

int main() {
    std::array<int, 5> myArray = {1, 2, 3, 4, 5};

    int frontElement = myArray.front();
    int backElement = myArray.back();

    std::cout << "Front element: " << frontElement << std::endl;
    std::cout << "Back element: " << backElement << std::endl;

    return 0;
}
In this example, we create an std::array called myArray with 5 elements. We use the front() and back() member functions to access the first and last elements of the array, respectively. The corresponding values are then printed using std::cout.

The output will be:

mathematica

Front element: 1
Back element: 5
==================================
reading and inserting the value into the array at particulator index?
array out of range:
catch for the above exception?

#include <iostream>
#include <array>

int main() {
    std::array<int, 5> myArray = {1, 2, 3, 4, 5};
    myArray.at(1) = 99;
    try {
        int element = myArray.at(10); // Accessing an out-of-range index
        std::cout << "Element: " << element << std::endl;
    }
    catch (const std::out_of_range& e) {
        std::cout << "Exception: " << e.what() << std::endl;
    }

    return 0;
}
=====================
Exception: array::at: index out of range
==========================================
how to change the element value in array?
loop over all the element of the array?

#include <iostream>
#include <array>

int main() {
    std::array<int, 5> myArray = {1, 2, 3, 4, 5};

    // Access and change elements using the indexing operator
    myArray[2] = 100; // Change the element at index 2 to 100

    // Access and change elements using the at() member function
    myArray.at(4) = 200; // Change the element at index 4 to 200

    // Print the modified array
    for (int i = 0; i < myArray.size(); ++i) {
        std::cout << myArray[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}

===========================================================
pointer to the stl::array:
header file
=====================
#include <iostream>
#include <array>

int main() {
    std::array<int, 5> myArray = {1, 2, 3, 4, 5};

    int* ptr = myArray.data();

    for (size_t i = 0; i < myArray.size(); ++i) {
        std::cout << "Element at index " << i << ": " << *(ptr + i) << std::endl;
    }

    return 0;
}
============================
fill and fill_n 
what points to be considered when working with fill and fill_n?
array also has begin ad end

is present in the c++98

 std::vector<int> numbers(5); // Create a vector of size 5

// Fill the vector with the value 42
std::fill(numbers.begin(), numbers.end(), 42);
-------------
std::vector<int> numbers(8); // Create a vector of size 8

// Fill the first 4 elements of the vector with the value 99
std::fill_n(numbers.begin(), 4, 99);
	
=================================
points to be noted in copy?
copy the array?
how to fill array?
can we expand the array size?


we cannot expand the array size like vector.

#include <iostream>
#include <array>

#include <iostream>
#include <array>

int main() {
    std::array<int, 5> originalArray = {1, 2, 3, 4, 5};
    std::array<int, 8> resizedArray;

    // Resize using slice assignment
    resizedArray.fill(0);
    std::copy(originalArray.begin(), originalArray.end(), resizedArray.begin());
    
    std::cout << "Resized Array (Slice Assignment): ";
    for (const auto& element : resizedArray) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    // Resize by creating a new std::array
    std::array<int, 3> newArray;
    std::copy(originalArray.begin(), originalArray.begin() + newArray.size(), newArray.begin());
    
    std::cout << "New Array (Creating a new std::array): ";
    for (const auto& element : newArray) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    return 0;
}

Resized Array (Slice Assignment): 1 2 3 4 5 0 0 0 
New Array (Creating a new std::array): 1 2 3 
==============================
array to get the first and last element?
different way to initialize the array


int main() {
    std::array<int, 5> myArray = {{1, 2, 3}}; //or std::array<int, 5> myArray {{1, 2, 3}};

    int frontElement = myArray.front();//1
    int backElement = myArray.back(); //0

    std::cout << "Front element: " << frontElement << std::endl;
    std::cout << "Back element: " << backElement << std::endl;

    return 0;
}
=============================================
header file
copy vs copy_n for the vector copying?
how the number of elements in the destination is determined.

copy is available in c++98
copy_n is present in c++11
different way to initialize the vector

#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> source = {1, 2, 3, 4, 5}; //std::vector<int> numbers{1, 2, 3, 4, 5};
    std::vector<int> destination(source.size()); // Pre-allocate memory for the destination vector i nedded for copy
	//if the size is not specified then no element will be copied

    // Copy using std::copy
    std::copy(source.begin(), source.end(), destination.begin()); // if the destination size is 2 only 2 element will be opied.

    // Print the elements in the destination vector after copying
    std::cout << "Destination vector (std::copy): ";
    for (const auto& element : destination) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    // Copy using std::copy_n
    std::vector<int> destination_copy_n(source.size()); // Pre-allocate memory for the destination vector

    std::copy_n(source.begin(), source.size(), destination_copy_n.begin());

    // Print the elements in the destination vector after copying
    std::cout << "Destination vector (std::copy_n): ";
    for (const auto& element : destination_copy_n) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    return 0;
}

======================
Destination vector (std::copy): 1 2 3 4 5 
Destination vector (std::copy_n): 1 2 3 4 5 
=========================

3 different way to initialize the vector with set of individual elements:

we cannot use the () for vector initialization using the individual element

std::vector<int> numbers(5, 0);
std::vector<int> numbers(5); // Default-initialized with 0


std::vector<int> numbers{1, 2, 3, 4, 5};
std::vector<int> numbers={1, 2, 3, 4, 5};

std::vector<int> numbers{{1, 2, 3, 4, 5}};
std::vector<int> numbers={{1, 2, 3, 4, 5}};

std::vector<int> source = {1, 2, 3, 4, 5};
std::vector<int> numbers(source.begin(), source.end());
 std::vector<int> v = std::vector<int>{1, 2, 3, 4, 5};
=====================================================================
how to change the value of the class member variable inside the lamda function.
member function takes an integer variable. lamda function having that value and object as pass by value;
mutuable is not required if the local variable initilization inside the class lamda function
data type is not required for declaring the new variable inside the [] here obj

passing the argumentof the member function to the capture list:
 
lamda taking the object as pass by value inside the member function.
use of mutable
arbitary object

#include <iostream>

class MyClass {
public:
    MyClass(int value) : x(value) {}

    void modifyValue(int newValue) {
	
        auto lambda = [obj = *this, newValue]() mutable { //obj is arbitary name. mutuable is to modify the value of the object
		//inside the lamda. lamda is the read only 
		
            obj.x = newValue;
        };
        lambda();
    }

    int getValue() const {
        return x;
    }

private:
    int x;
};

int main() {
    MyClass obj(5);
    std::cout << "Initial value: " << obj.getValue() << std::endl;  // Output: 5

    obj.modifyValue(10);
    std::cout << "Modified value: " << obj.getValue() << std::endl;  // Output: 5

    return 0;
}
===================================
can lamda function change the global or member variable value?

modifying the main function local variable inside the lamda function
lamda can modify the local variable pass by reference
#include <iostream>
int main() {
    int x = 5;
    x += 2;
    // Mutable lambda function
    auto lambda = [x]() mutable {
        x += 10;
        std::cout << "Inside lambda: x = " << x << std::endl;
    };

    x += 12;
    lambda();
    std::cout << "After lambda: x = " << x << std::endl;

    return 0;
}
Inside lambda: x = 17
After lambda: x = 19
================================
how to change the class member variable in const function?
const object can call const function
non const object can call const function

#include <iostream>

class Counter {
public:
    void increment() const {
        mutableCount++;
    }

    int getCount() const {
        return mutableCount;
    }

private:
    mutable int mutableCount = 0;
};

int main() {
    Counter counter;
    counter.increment();

    std::cout << "Count: " << counter.getCount() << std::endl;  // Output: 1

    return 0;
}

In this example, we have a class Counter that maintains a count value. The increment member function is marked as const, indicating that
 it does not modify the state of the class object.

However, by using the mutable keyword on the mutableCount member variable, we allow it to be modified even within const-qualified member 
functions. In this case, the increment function increments the mutableCount variable.
==================================
bind third argument needn't be the placeholders it can be the value also?
calling bind object?
//iterator header file// begin and end
//fill //algorithm header file
#include <iostream>
#include <functional>

class MyClass {
public:
    MyClass() {}

    void performTask(int value) {
        std::cout << "Performing task with value: " << value << std::endl; //42
    }

    void memberFunction(int value) {
        std::cout << "Member function called with value: " << value << std::endl; //42
        performTask(value);
    }
};

int main() {
    MyClass myObject;

    int additionalArgument = 42;

    auto boundFunc = std::bind(&MyClass::memberFunction, &myObject, additionalArgument);

    boundFunc(); //boundFunc(12); //no use in passing 12 it is not used

    return 0;
}
==========================================================
static member function taking object pointer returning 
lamda function taking void argument and returning void and calling other class member function

#include <iostream>
#include <functional>

class MyClass {
public:
    void privateFunction() {
        std::cout << "Private function called." << std::endl;
    }

    void performTask() {
        std::cout << "Performing task..." << std::endl;
    }

    static std::function<void()> lambdaFunction1(MyClass* obj) { //or  static std::function<void(void)> lambdaFunction1(MyClass* obj) {
        return [obj]() {
            obj->privateFunction();
            obj->performTask();
        };
    }
};

int main() {
    MyClass myObject;

    auto lambda = MyClass::lambdaFunction1(&myObject);

    lambda();

    return 0;
}
===================================================
#include <iostream>
#include <functional>

// Function taking an int and a float, and returning void
void printValues(int value1, float value2) {
    std::cout << "Value 1: " << value1 << std::endl;
    std::cout << "Value 2: " << value2 << std::endl;
}

int main() {
    // Define a std::function with the desired signature
    std::function<void(int, float)> func = printValues;

    // Call the std::function with int and float arguments
    func(42, 3.14f);

    return 0;
}
====================================================
static member function taking object pointer returning
lamda function taking integer, integer argument and calling other member function and returning integer inside
when we put return for the lamda for the lamda function

return is required in lamba when we call lamda function otside the current function

#include <iostream>
#include <functional>

class MyClass {
public:
    int multiplyNumbers(int a, int b) {
        return a * b;
    }

    static std::function<int(int, int)> lambdaFunction1(MyClass* obj) {
        return [obj](int a, int b) { // we put return here since we call it in main
            return obj->multiplyNumbers(a, b);
        };
    }
};

int main() {
    MyClass myObject;

    auto lambda = MyClass::lambdaFunction1(&myObject);

    int result = lambda(4, 5);

    std::cout << "The result is: " << result << std::endl;

    return 0;
}
=========================================================\
map with in map
same key in outer map but different values in the inner value
#include <iostream>
#include <map>

int main() {
    std::map<int, std::map<std::string, int>> outerMap;

    // Insert elements into the inner maps
    outerMap[1]["apple"] = 5;
    outerMap[1]["orange"] = 8;
    outerMap[2]["banana"] = 3;
    outerMap[3]["grape"] = 6;

    // Access elements in the map of maps using iteration
    for (const auto& outerPair : outerMap) {
        int category = outerPair.first;
        const std::map<std::string, int>& innerMap = outerPair.second;

        std::cout << "Category " << category << ":\n";
        for (const auto& innerPair : innerMap) {
            const std::string& itemName = innerPair.first;
            int itemCount = innerPair.second;

            std::cout << "  Item: " << itemName << ", Count: " << itemCount << "\n";
        }
    }

    return 0;
}

Category 1:
  Item: apple, Count: 5
  Item: orange, Count: 8
Category 2:
  Item: banana, Count: 3
Category 3:
  Item: grape, Count: 6
 =======================
 #include <iostream>
#include <map>

int main() {
    // Create a map with int keys and inner maps as values
    std::map<int, std::map<std::string, int>> outerMap;

    // Insert elements into the inner maps
    outerMap[1]["apple"] = 5;
    outerMap[1]["orange"] = 8;
    outerMap[2]["banana"] = 3;
    outerMap[3]["grape"] = 6;

    // Access elements in the map of maps
    std::cout << "Number of apples in category 1: " << outerMap[1]["apple"] << std::endl;
    std::cout << "Number of oranges in category 1: " << outerMap[1]["orange"] << std::endl;
    std::cout << "Number of bananas in category 2: " << outerMap[2]["banana"] << std::endl;
    std::cout << "Number of grapes in category 3: " << outerMap[3]["grape"] << std::endl;

    return 0;
}
Number of apples in category 1: 5
Number of oranges in category 1: 8
Number of bananas in category 2: 3
Number of grapes in category 3: 6
=============================================================
#include <iostream>
#include <map>

int main() {
    std::multimap<int, int> srssiChannel;

    // Insert elements using std::make_pair
    srssiChannel.insert(std::make_pair(12, 12));
    srssiChannel.insert(std::make_pair(10, 20));
    srssiChannel.insert(std::make_pair(12, 30));
    srssiChannel.insert(std::make_pair(8, 40));

    // Access elements in the multimap
    for (const auto& pair : srssiChannel) {
        std::cout << "Channel: " << pair.first << ", RSSI: " << pair.second << std::endl;
    }

    return 0;
}
Channel: 8, RSSI: 40
Channel: 10, RSSI: 20
Channel: 12, RSSI: 12
Channel: 12, RSSI: 30
===========================================================
//multimap not multi_map?
//map will inser the unique key
//multimap to store the number and string
// how to to print the elements with same key?
insert the element into the map
#include <iostream>
#include <map>

int main() {
    std::multimap<int, std::string> multiMap;

    // Insert elements with non-unique keys
    multiMap.insert(std::make_pair(1, "apple"));
    multiMap.insert(std::make_pair(2, "banana"));
    multiMap.insert(std::make_pair(1, "orange"));
    multiMap.insert(std::make_pair(3, "grape"));
    multiMap.insert(std::make_pair(2, "kiwi"));

    // Access elements with the same key using iterators
	//range.second: This is the iterator pointing to the position just after the last element with key 1 in the multiMap. 
	//In other words, it points to the next element after the last occurrence of key 1. In this case, it points to the position after "orange", 
	//the last occurrence of key 1.
    std::cout << "Elements with key 1: ";
    auto range = multiMap.equal_range(1);
    for (auto it = range.first; it != range.second; ++it) {
        std::cout << it->second << " ";
    }
    std::cout << std::endl;

    std::cout << "Elements with key 2: ";
    range = multiMap.equal_range(2);
    for (auto it = range.first; it != range.second; ++it) {
        std::cout << it->second << " ";
    }
    std::cout << std::endl;

    return 0;
}
Elements with key 1: apple orange 
Elements with key 2: banana kiwi 
=============================================
header file for random number?

generate the random number between 1 to 3:

you can split the distrubtion in 2 different lines:
std::uniform_int_distribution<int> distribution;
distribution = std::uniform_int_distribution<int>(2, 3);
	
#include <iostream>
#include <random>

int main() {
    // Create a random number generator
    std::random_device rd;
    std::mt19937 gen(rd());

    // Define the range [1, 3] for the random number
    std::uniform_int_distribution<int> distribution(1, 3);

    // Generate a random number between 1 and 3
    int randomNumber = distribution(gen);

    std::cout << "Random number between 1 and 3: " << randomNumber << std::endl;

    return 0;
}
===========================================================
fill all the elements to -200?
#include <iostream>
#include <algorithm>

int main() {
    const int size = 5;
    int myArray[size];

    std::fill(myArray, myArray + size, -200);

    // Print the elements of the array
    for (int i = 0; i < size; ++i) {
        std::cout << "Element " << i << ": " << myArray[i] << std::endl;
    }

    return 0;
}
==========================================================
reference for an array
#include <iostream>

int main() {
    int originalArray[] = {1, 2, 3, 4, 5};
    int (&arrayRef)[5] = originalArray;

    // Use the reference to access the elements of the array
    for (int i = 0; i < 5; ++i) {
        std::cout << "Element " << i << ": " << arrayRef[i] << std::endl;
    }

    return 0;
}
===========================================================
Even though the macro is defined inside the function scope exits outside the class also.
#include <stdio.h>

void myFunction() {
    // Macro defined inside the function
    #define MY_MACRO 100
    
    printf("Inside the function: MY_MACRO = %d\n", MY_MACRO);
}

int main() {
    myFunction();

    // The macro MY_MACRO is accessible here
    printf("Outside the function: MY_MACRO = %d\n", MY_MACRO); // This will work fine

    return 0;
}

==========================================================
local lamda function taking object pointer, integer, integer as argument and lamda list also an object
and returning the integer by calling class member function

#include <iostream>
#include <functional>

class MyClass {
public:
    int multiplyNumbers(int a, int b) {
        return a * b;
    }
};

int main() {
    MyClass myObject;

    auto lambdaFunction1 = [&myObject](MyClass* obj, int a, int b) { //object is not required here
        return obj->multiplyNumbers(a, b); //return myObject.multiplyNumbers(a, b);
    };

    int result = lambdaFunction1(&myObject, 4, 5);

    std::cout << "The result is: " << result << std::endl;

    return 0;
}

==========================================
direct assignment of global function with int,int argument and returning int to the function object and calling it
which header file is required?

#include <iostream>
#include <functional>

int myfunction(int a, int b) {
    return a + b;
}

int main() {

    std::function<int(int, int)> lambdaFunction1 = myfunction;

    int result = lambdaFunction1(4, 5);

    std::cout << "The result is: " << result << std::endl;

    return 0;
}
==============================================================
lamda function pass by value

#include <iostream>

int main() {
    int x = 5;
    auto lambda = [x]() {
        std::cout << "Captured value: " << x << std::endl; //5
    };

    x = 10;  // Modifying x after capturing

    lambda();  // Invoking the lambda function //5

    return 0;
}
==========================================================================
lamda function pass by reference

#include <iostream>

int main() {
    int x = 5;
    auto lambda = [&x]() {
        std::cout << "Captured value by reference: " << x << std::endl;//10
    };

    x = 10;  // Modifying x after capturing

    lambda();  // Invoking the lambda function //10

    return 0;
}
===============================
capture all the local variable

#include <iostream>

int main() {
    int x = 5;
    int y = 10;
    auto lambda = [=]() {
	//=: The equals sign = denotes that all variables accessed within the lambda expression will be captured by value.
        std::cout << "Captured values: " << x << ", " << y << std::endl; //5 10
    };

    x = 15;
    y = 20;

    lambda(); //5 10

    return 0;
}

=====================================================
definining the lamda function inside the class member function and calling it inside the member function not taking any argument:
what is must here?
calling other member function


#include <iostream>
#include <functional>

class MyClass {
public:
    MyClass() : memberVariable(42) {}

    void performTask() {
        std::cout << "Performing task with memberVariable: " << memberVariable << std::endl;
    }

    void executeTask() {
	//reurn for the lamda function is not required since we use it with in the function
        auto lambda = [this]() { // this required here since we are accessing the member variable
            std::cout << "Inside lambda: memberVariable = " << memberVariable << std::endl;
            performTask();
        };

        lambda();
    }

private:
    int memberVariable;
};

int main() {
    MyClass myObject;
    myObject.executeTask();

    return 0;
}

==========================================================
mymap.insert({key,value})
mymap.insert(make_par(key,value))
object() =>call the functor
char pointer to tuple?

function pointer
-> taking void function argument and returning void
-> taking int , int argument and returning int

different ways to use the function pointer assignement and calling the function from function pointer
 
 funcPtr = sayHello; // Assign the function address to the pointer
  funcPtr = &sayHello; // Assign the function address to the pointer
 (funcPtr)()
 (*funcPtr)()
 funcPtr()
 
A function pointer and a function object (also known as a functor) 

#include <iostream>

void sayHello() {
    std::cout << "Hello!" << std::endl;
}

int add(int a, int b) {
    return a + b;
}

int main() {
    void (*funcPtr)(); // Declare a function pointer

    funcPtr = sayHello; // Assign the function address to the pointer
    funcPtr(); // Call the function using the pointer

    int (*addPtr)(int, int); // Declare a function pointer for the add function
    addPtr = add; // Assign the add function address to the pointer
    int result = addPtr(3, 4); // Call the function using the pointer

    std::cout << "Result: " << result << std::endl;

    return 0;
}

===============================================================
what is functor?
 
Functors, also known as function objects, provide a way to encapsulate behavior within a class and use it as a callable object.
 They can be thought of as objects that act like functions because they overload the operator(). 
Functors were introduced in earlier versions of C++ and have been part of the language since its inception.
functor example:'

====================================
different way to call the function in functor?
functor function to print the hellow message
MyFunctor(); will not call the function

#include <iostream>

class MyFunctor {
public:
    void operator()() const {
        std::cout << "Hello from MyFunctor!" << std::endl;
    }
};

int main() {
    MyFunctor functor;
    functor(); // Call the functor object like a function
	//or MyFunctor()(); //Call the functor object temporary object
	//MyFunctor() //no output since it creates only the temporary object

    return 0;
}
===================
functor to perform addition

#include <iostream>

class Adder {
public:
    int operator()(int a, int b) const {
        return a + b;
    }
};

int main() {
    Adder adder;
    int result = adder(3, 4);

    std::cout << "Result: " << result << std::endl;

    return 0;
}

===============================================
actual example of functor:
a. algorithm: explain the function logic and the arguments passed
2. polymorphisim : const function, const override, const &
functor inside the algorithm:
===
algorithm we need to pass the object

#include <iostream>
#include <vector>
#include <algorithm>

// Functor class for checking if a number is divisible by a given divisor
class DivisibleBy {
public:
    DivisibleBy(int divisor) : divisor_(divisor) {}

    bool operator()(int number) const { // or bool operator()(const int & number) const
        return (number % divisor_ == 0);
    }

private:
    int divisor_;
};

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int divisor = 3;

    DivisibleBy divisibleByThree(divisor);

    // Use the functor in an algorithm
    auto it = std::find_if(numbers.begin(), numbers.end(), divisibleByThree);
   // auto it = std::find_if(numbers.begin(), numbers.end(), DivisibleBy()); will not work as there is constructor
    if (it != numbers.end()) {
        std::cout << "Found a number divisible by " << divisor << ": " << *it << std::endl;
    } else {
        std::cout << "No number found divisible by " << divisor << std::endl;
    }

    return 0;
}

Found a number divisible by 3: 3
This example demonstrates the use of the DivisibleBy functor within the std::find_if algorithm. The functor is used as the predicate to define
 the condition 
for finding a specific element in the vector. Functors are commonly used as predicates or comparators in various algorithms from the C++ Standard 
Library to customize their behavior based on specific conditions or requirements.
===========================================
functor(function object) inside the polymorphisim:

const function override
override keyword?
neednt create the area calculation object for the each time calculation

===================================
#include <iostream>

// Abstract base class
class Shape {
public:
    virtual double area() const = 0;
};

// Functor class implementing a rectangle
class Rectangle : public Shape {
public:
    Rectangle(double width, double height) : width_(width), height_(height) {}

    double area() const override {
        return width_ * height_;
    }

private:
    double width_;
    double height_;
};

// Functor class implementing a circle
class Circle : public Shape {
public:
    Circle(double radius) : radius_(radius) {}

    double area() const override {
        return 3.14159 * radius_ * radius_;
    }

private:
    double radius_;
};

// Functor that accepts any Shape object and computes its area
class AreaCalculator {
public:
    double operator()(const Shape& shape) const {
        return shape.area();
    }
};

int main() {
    Rectangle rectangle(3.0, 4.0);
    Circle circle(2.5);

    AreaCalculator areaCalculator;

    // Polymorphic behavior using functors
    double rectangleArea = areaCalculator(rectangle);
    double circleArea = areaCalculator(circle);

    std::cout << "Rectangle area: " << rectangleArea << std::endl;
    std::cout << "Circle area: " << circleArea << std::endl;

    return 0;
}
======================================================================================
string reverse in same variable?

#include <iostream>
#include <string>
#include <algorithm>

int main() {
    std::string str = "Hello, World!";
    std::reverse(str.begin(), str.end());
    std::cout << str << std::endl;
    return 0;
}
========================================
factorial:
#include <iostream>

int factorial(int n) {
    if (n == 0)
        return 1;
    return n * factorial(n - 1);
}

int main() {
    int number = 5;
    int result = factorial(number);
    std::cout << "Factorial of " << number << " is: " << result << std::endl;
    return 0;
}

===============================================
fibanacis series:
#include <iostream>

int fibonacci(int n) {
    if (n <= 1)
        return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int count = 10;
    std::cout << "Fibonacci Series up to " << count << " terms:" << std::endl;
    for (int i = 0; i < count; ++i) {
        std::cout << fibonacci(i) << " ";
    }
    std::cout << std::endl;
    return 0;
}
Fibonacci Series up to 3 terms:
0 1 1 
================================================
string reverse in the same variable?
palindrome:
#include <iostream>
#include <algorithm>

bool isPalindrome(const std::string& str) {
    std::string reversed = str;
    std::reverse(reversed.begin(), reversed.end());
    return (str == reversed);
}

int main() {
    std::string input;
    std::cout << "Enter a string: ";
    std::cin >> input;

    if (isPalindrome(input))
        std::cout << "Palindrome" << std::endl;
    else
        std::cout << "Not a palindrome" << std::endl;

    return 0;
}
=========================================
sum of maximum element in array

#include <iostream>
#include <vector>
#include <algorithm>

int maxSubarraySum(const std::vector<int>& nums) {
    int currentSum = nums[0];
    int maxSum = nums[0];

    for (size_t i = 1; i < nums.size(); ++i) {
        currentSum = std::max(nums[i], currentSum + nums[i]);
        maxSum = std::max(maxSum, currentSum);
    }

    return maxSum;
}

int main() {
    std::vector<int> nums = { -2, 1, -3, 4, -1, 2, 1, -5, 4 };
    int result = maxSubarraySum(nums);

    std::cout << "Maximum subarray sum: " << result << std::endl;

    return 0;
}
Maximum subarray sum: 6
The example provided uses the input array {-2, 1, -3, 4, -1, 2, 1, -5, 4}, and the expected output is 6, which represents the maximum sum of the subarray
 [4, -1, 2, 1].
 if the added number is lesser than the current index number value keep adding else move to the index number.
-2  1   -1    1
1  -3   -2   -2
-2  4   2    4
4  -1   3    3
3  2    5    5
5  1    6    6
6  -5   1    1
1  4    5    5
Maximum subarray sum: 6
=======================================
set store the elements in the ascending order:
set uses lesser memory and has high performance in search, insertion and deletion.

find the duplicate of the number:
header file
how to define the set?
operation for set?
multiset preserve the order
unorder_set and unorder map doent preserve the order?

unorder_set not multiset? 
header file for unoder_set<int> is <unorder_set>
in unorder_set use hash . o(1)
multiset use redblack tree o(logn).header file <set>


how to find the duplicate number in set?
unordered?

#include <iostream>
#include <vector>
#include <unordered_set>

int findDuplicate(const std::vector<int>& nums) {
    std::unordered_set<int> numSet;

    for (int num : nums) {
        if (numSet.count(num) > 0)
            return num;
        else
            numSet.insert(num);
    }

    return -1; // In case no duplicate is found
}

int main() {
    std::vector<int> nums = { 1, 3, 4, 2, 2 };
    int result = findDuplicate(nums);

    std::cout << "Duplicate number: " << result << std::endl;

    return 0;
}
//2
====================
stl advantage:

std::deque (Double-ended Queue): If you need efficient insertion and deletion operations at both ends of the container, 
std::deque can be a good alternative. It provides constant time complexity for these operations while still allowing random access. 
However, keep in mind that std::deque may have slightly higher overhead compared to std::vector due to its internal structure.

std::list (Linked List): If you frequently insert or delete elements in the middle of the container, std::list can be a better choice. 
It provides constant time complexity for these operations, but at the cost of slower random access. It also avoids the potential for invalidating 
iterators during modifications.

std::array (Fixed-size Array): If the size of your container is known at compile time and remains fixed, std::array can be a good option. 
It provides the same performance characteristics as C-style arrays but with added benefits such as bounds checking and compatibility with STL 
algorithms.

std::unordered_map or std::unordered_set (Hash-based Containers): If you need fast lookup operations with unique keys or unique values, 
respectively, consider using std::unordered_map or std::unordered_set. These containers use hash tables for efficient element access, insertion,
 and deletion. However, they do not preserve the order of elements o(1)
===============================================
vulnerability in exception handling
information discolsure and example
sensitive data , general information
cerr

#include <iostream>

void divide(int numerator, int denominator) {
    try {
        if (denominator == 0) {
            throw "Division by zero error";
        }
        int result = numerator / denominator;
        std::cout << "Result: " << result << std::endl;
    } catch (const char* errorMessage) {
        std::cerr << "Exception caught: " << errorMessage << std::endl;
    }
}

int main() {
    int numerator, denominator;
    std::cout << "Enter numerator: ";
    std::cin >> numerator;
    std::cout << "Enter denominator: ";
    std::cin >> denominator;

    divide(numerator, denominator);

    return 0;
}
In the above example, the divide() function attempts to perform division but throws an exception when the denominator is zero. 
The exception is caught in the try-catch block and an error message is printed.

However, the problem arises when the exception is thrown as a C-style string (const char*). This can potentially lead to a vulnerability 
called "Information Disclosure" if the exception message contains sensitive information.
 For instance, if an attacker provides a zero denominator intentionally, they can trigger the exception and potentially retrieve sensitive 
 data if the exception message leaks that information.

To avoid this vulnerability, it is crucial to ensure that exception messages do not contain sensitive data. Instead, exceptions should provide 
generic error messages and, if needed, more specific information can be logged internally for debugging purposes.
=========================================
Possibility vulnerability using pointers

Dangling Pointers: Dangling pointers occur when a pointer points to a memory location that has been deallocated or is no longer valid. 
Accessing or dereferencing a dangling pointer can lead to undefined behavior, including crashes, data corruption, or security vulnerabilities.
 Dangling pointers often occur when pointers are not properly updated or freed memory is accessed.

Null Pointers: Null pointers refer to pointers that do not point to any valid memory address. Dereferencing a null pointer leads to undefined 
behavior, causing program crashes or security vulnerabilities. It is important to initialize pointers properly and check for null before 
dereferencing them.

Buffer Overflows and Underflows: Buffer overflows or underflows can occur when accessing memory beyond its boundaries. This vulnerability often 
happens with pointer arithmetic or array access. An attacker can exploit buffer overflows to overwrite adjacent memory regions, modify program 
control flow, or execute arbitrary code.

Uninitialized Pointers: Using uninitialized pointers can lead to undefined behavior and security vulnerabilities. Uninitialized pointers may 
contain garbage values or point to arbitrary memory locations. Dereferencing uninitialized pointers can result in crashes or unpredictable 
behavior.

Pointer Arithmetic Errors: Incorrect use of pointer arithmetic, such as adding or subtracting incorrect values, can lead to vulnerabilities. 
Pointer arithmetic relies on correct understanding of the underlying data types and proper memory layout. Misusing pointer arithmetic can result in memory access violations, buffer overflows, or undefined behavior.
====================================================================
example:
deference an uninitilized memory

#include <iostream>

int main() {
    int* ptr; // Uninitialized pointer

    if (*ptr == 10) { // Dereferencing uninitialized pointer
        std::cout << "Value is 10" << std::endl;
    } else {
        std::cout << "Value is not 10" << std::endl;
    }

    return 0;
}
================================================

sleep command

The sleep function in C/C++ will pause the execution of the current thread, not the entire process. It suspends the execution of the thread for a
 specified amount of time, allowing other threads within the same process to continue running.

When you call sleep in a multi-threaded program, only the thread that made the sleep call will be put to sleep. Other threads running in the 
same process will not be affected and can continue their execution.

a. how to create the thread with global function without the argument
b. thread sleep in milliseconds and seconds
c. header file for sleep?


#include <iostream>
#include <thread>
#include <chrono>

void workerFunction() {
    std::cout << "Thread started." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(2));
    std::cout << "Thread resumed after sleep." << std::endl;
}

int main() {
    std::cout << "Main thread started." << std::endl;

    std::thread workerThread(workerFunction);

    std::this_thread::sleep_for(std::chrono::seconds(1));
	// std::this_thread::sleep_for(std::chrono::milliseconds(200));

    std::cout << "Main thread resumed after sleep." << std::endl;

    workerThread.join();

    std::cout << "Main thread finished." << std::endl;

    return 0;
}

=============================================
to get the thread_id?
return value from the thread function
what happen if i join 2 times?
However, once a thread is joined, it cannot be joined again. If you attempt 
to call join on an already joined thread, it will result in an std::system_error with an error message "Resource deadlock avoided."
terminate called after throwing an instance of 'std::system_error'

to get the thread id?

std::this_thread::get_id()

#include <iostream>
#include <thread>

int threadFunction() {
    return 42;
}

int main() {
    std::thread t(threadFunction);
   
    int result = t.join(); // Get the return value
    std::cout << "Thread function returned: " << result << std::endl;
    return 0;
}

=========================================
return value from the detach thread is not possible:
In C++, when you detach a thread using std::thread::detach(), the thread runs independently, and there is no straightforward way to 
retrieve its return value directly. When you detach a thread, it becomes a "detached" thread, and the calling thread does not wait for it to 
finish or receive its return value.

sleep:
 std::this_thread::sleep_for(std::chrono::seconds(2));
 
detach the thread?

lock using only mutex?

#include <iostream>
#include <thread>
#include <mutex>

std::mutex resultMutex;
int sharedResult = 0;

void detachedThreadFunction() {
    // Simulate some work
    std::this_thread::sleep_for(std::chrono::seconds(2));

    // Update the shared result
    std::lock_guard<std::mutex> lock(resultMutex);
    sharedResult = 42;
}

int main() {
    // Detach the thread
    std::thread(detachedThreadFunction).detach();

    // Main thread continues execution without waiting for the detached thread

    // Wait for some time to allow the detached thread to finish
    std::this_thread::sleep_for(std::chrono::seconds(3));

    // Retrieve the shared result
    std::lock_guard<std::mutex> lock(resultMutex);
    std::cout << "Detached thread returned: " << sharedResult << std::endl;

    return 0;
}
======================================================
=====================================================
thread safe variable in the thread ?

automic header file?

std::atomic<int> thread safe way of doing the read and write:

global atomic counter initialization?
how to initilize the counter variable inside the class?

incrementing the global automic counter and printing after the thread join?
different of printing the counter variable?

#include <iostream>
#include <thread>
#include <atomic>

std::atomic<int> counter(0);

void incrementCounter() {
    for (int i = 0; i < 100000; ++i) {
        counter++; // Increment the counter in a thread-safe manner
    }
}

int main() {
    // Create multiple threads to increment the counter
    std::thread t1(incrementCounter);
    std::thread t2(incrementCounter);

    // Wait for both threads to finish
	
	//before check the thread is joinable?
    t1.join();
    t2.join();

    // Print the final value of the counter
    std::cout << "Final counter value: " << counter << std::endl;

    return 0;
}
Final counter value: 200000
==========================================================
automic varable using classs and increment it from the lamda function
remeber to use const function and referece object?

class member variable initialization in the constructor?

#include <iostream>
#include <atomic>
#include <thread>

class AtomicCounter {
public:
    AtomicCounter() : value(0) {}

    // Increment the counter in a thread-safe manner
    void increment() {
        value++;
    }

    // Decrement the counter in a thread-safe manner
    void decrement() {
        value--;
    }

    // Get the current value of the counter
    int getValue() const {
        return value.load(); // Use load() to obtain the current value safely
    }

private:
    std::atomic<int> value;
};

int main() {
    AtomicCounter counter;

    std::thread t1([&counter](){
        for (int i = 0; i < 100000; ++i) { //note no counter ->
            counter.increment();
        }
    });

    std::thread t2([&counter](){
        for (int i = 0; i < 100000; ++i) {
            counter.decrement();
        }
    });

    t1.join();
    t2.join();

    std::cout << "Final counter value: " << counter.getValue() << std::endl; //0

    return 0;
}

==================================
capture all the element by reference global, scope, local

[&]()
[=]()
[]() => capture only the global variable declared outside the main and not the variable decalred outside the scope ie not the local and
//variable outside the scope

#include <iostream>
int globalVar1 = 10;
int main() {
    int globalVar2 = 11;
{
    int globalVar3 = 12;
    auto lambda = [&]() {
        std::cout << "Inside lambda: globalVar = " << globalVar1 << std::endl; //20
         std::cout << "Inside lambda: globalVar = " << globalVar2 << std::endl; //22
          std::cout << "Inside lambda: globalVar = " << globalVar3 << std::endl;//24
    };

    globalVar1 +=globalVar1;
    globalVar2 +=globalVar2;
    globalVar3 += globalVar3;
    lambda();

}
================================
capture all the element by value global, scope, local
#include <iostream>
int globalVar1 = 10;
int main() {
    int globalVar2 = 11;
{
    int globalVar3 = 12;
    auto lambda = [=]() {
        std::cout << "Inside lambda: globalVar = " << globalVar1 << std::endl; //20 ////if you change the global variable it will imapact the other places also
         std::cout << "Inside lambda: globalVar = " << globalVar2 << std::endl; //11
          std::cout << "Inside lambda: globalVar = " << globalVar3 << std::endl;//12
    };

    globalVar1 +=globalVar1;
    globalVar2 +=globalVar2;
    globalVar3 += globalVar3;
    lambda();

}
return 0;
}
=======================================
#include <iostream>
int globalVar1 = 10;
int main() {
    int globalVar2 = 11;
{
    int globalVar3 = 12;
    auto lambda = []() {
        std::cout << "Inside lambda: globalVar = " << globalVar1 << std::endl; //20
         //std::cout << "Inside lambda: globalVar = " << globalVar2 << std::endl; //error
         // std::cout << "Inside lambda: globalVar = " << globalVar3 << std::endl;//error
    };

    globalVar1 +=globalVar1;
    globalVar2 +=globalVar2;
    globalVar3 += globalVar3;
    lambda();

}
return 0;
}
==================================
it is not necessary to pass the counter object inside the lamda capture list
std::thread t1([&](){
    for (int i = 0; i < 100000; ++i) {
        counter.increment();
    }
});

std::thread t2([&](){
    for (int i = 0; i < 100000; ++i) {
        counter.decrement();
    }
});
By using [&] in the lambda capture list, you are capturing all variables by reference from the surrounding scope, 
including the counter object. This allows the lambda functions to access the counter object directly without the need for explicit capture.
=======================================
constructor order calling for the local class object in another class .
how to resolve the conflict due to class name;

#include <iostream>
#include <atomic>
#include <thread>
using namespace std;

class sample
{
    public:
    sample()
    {
        cout<<"sample constructor ";
    }
    ~sample()
    {
        cout<<"sample destructor ";
    }
};

class srample1
{
    public:
    srample1()
    {
        cout<<"sample1 constructor ";
    }
    ~srample1()
    {
        cout<<"sample1 destructor ";
    }
    ::sample obj;
};

int main()
{
   srample1 obj;
   return 0;
}
sample constructor 
sample1 constructor 
sample1 destructor 
sample destructor 
===============================
when the class object being used in other class has the assignment deleted function , we cannot do the assignement for the outer class.
the other way is you can overwrite the assignement in the outer class 
class sample
{
    public:
    sample & operator=(const sample &) = delete;
};

class srample1
{
    public:
    ::sample obj;
};

int main()
{
   srample1 obj, obj2;
   obj2=obj; //error
   
   return 0;
}

============================================
when the class object being used in other class has the assignment deleted function , we cannot do the assignement for the outer class.
the other way is you can overwrite the assignement in the outer class 

how to resolve the issue.

class sample
{
    public:
    sample & operator=(const sample &) = delete;
};

class srample1
{
    public:
    srample1 & operator=(const srample1 &) {
        return *this;
    }
    ::sample obj;
};

int main()
{
   srample1 obj, obj2;
   obj2=obj;
   
   return 0;
}
=====================================================
lambda pass by value needs
what are the factors to be considered while pass by value?

a. mutable. what is called when the we use [=] 
b. copy constructor
c. lamda pass value creates it own copy of the variable by pass by value
d. when the lamda is passed by value we cannot modify it unless you specify mutable,

#include <iostream>
#include <atomic>
#include <thread>

class AtomicCounter {
public:
    AtomicCounter() : value(0) {}

    // Increment the counter in a thread-safe manner
    void increment() {
        value++;
    }

    // Decrement the counter in a thread-safe manner
    void decrement() {
        value--;
    }

    // Get the current value of the counter
    int getValue() const {
        return value.load(); // Use load() to obtain the current value safely
    }

    // Copy constructor (explicitly defined for capturing by value in lambda)
	// std::atomic type is not copyable, which means its copy constructor and copy assignment operator are deleted. By default, 
	//when you define any constructor in a class, C++ does not generate a copy constructor implicitly. Therefore, if you want to capture an object containing an std::atomic member variable by value in a lambda, you need to explicitly provide a copy constructor for that class to enable copying of the AtomicCounter object.
    AtomicCounter(const AtomicCounter& other) : value(other.value.load()) {}


private:
   std::atomic<int> value;
};

int main() {
    AtomicCounter counter;

    std::thread t1([=]() mutable{
        for (int i = 0; i < 100000; ++i) {
            counter.increment();
        }
    });

    std::thread t2([=]()mutable { //lamda it own copy of the vraiable.
        for (int i = 0; i < 100000; ++i) {
            counter.increment();
        }
    });

    t1.join();
    t2.join();

    std::cout << "Final counter value: " << counter.getValue() << std::endl; //0 since we are passing by value

    return 0;
}
==============================================================
sample class ambiguity?
overloading assignment operator

class sample
{
    public:
    sample & operator=(const sample &) 
    {
        cout <<"base 1";
        return *this;
    }
};

class srample1
{
    public:
    srample1 & operator=(const srample1 &) = default;
    ::sample obj;
};

int main()
{
   srample1 obj, obj2;
   obj2=obj;
   
   return 0;
}

obj2=obj; //will call the srample1 assignement operator
since srample1 has the member function sample, that sample assignement operator will also be called.
order:
srample1 and then sample
==============================================================
which variable does the empty capture list can acess? global/local/outofscope?
empty capture list[]

empty lamda capture can access only the global vraiable:
cannot access the local variable
a
main()
{
	b
	{
		c[]
		{ 
		can access only the a global variable;
		}
	}
}


#include <iostream>

int globalVar = 42;

void exampleFunction() {
    int localVar = 10;

    // Lambda with an empty capture list can access both globalVar and localVar
    auto lambda = []() {
        std::cout << "Inside the lambda: globalVar = " << globalVar  "; //if you change the global variable it will imapact the other places also
		// std::cout <<localVar = " << localVar << std::endl; //error cannot access the local variable
    };

    lambda();
}

int main() {
    exampleFunction();
    std::cout << "Inside main: globalVar = " << globalVar << std::endl;
    return 0;
}
============================================================
amiguity in the class member variable :
void setValue(int value) {
        // Ambiguity: 'value' could refer to the parameter or the class variable
        // Use 'this' to explicitly refer to the class variable
        this->value = value;
    }
================================================================
ambiguit in the class methods:
#include <iostream>

class Base {
public:
    int value = 5;
    void display() {
        std::cout << "Base class display()" << std::endl;
    }
};

class Derived : public Base {
public:
    int value = 10;
    void display() {
        std::cout << "Derived class display()" << std::endl;
    }
};

int main() {
    Derived obj;
    
    // Accessing the variable 'value' from the Base class
    std::cout << "Base class value: " << obj.Base::value << std::endl;

    // Calling the function 'display()' from the Derived class
    obj.display();  // Outputs "Derived class display()"

    // Calling the function 'display()' from the Base class
    obj.Base::display();  // Outputs "Base class display()"

    return 0;
}
===========================
ambiguity in global method?
#include <iostream>

namespace First {
    int value = 5;
    void display() {
        std::cout << "First namespace display()" << std::endl;
    }
}

namespace Second {
    int value = 10;
    void display() {
        std::cout << "Second namespace display()" << std::endl;
    }
}

int main() {
    // Accessing the variable 'value' from the First namespace
    std::cout << "First namespace value: " << First::value << std::endl;

    // Calling the function 'display()' from the Second namespace
    Second::display();  // Outputs "Second namespace display()"

    return 0;
}
========================================
if you want to capture all the elements then put 
 auto lambda = [&]() //reference
 
#include <iostream>
#include <iostream>

int main() {
    int x = 42;
    int y = 77;

    // Capture all variables by reference
    auto lambda = [&x, y]() { //here x is reference and y is pass by value
        std::cout << "Captured x by reference: " << x << std::endl;
        std::cout << "Captured y by reference: " << y << std::endl;
    };

    lambda();

    // Modify the original variables
    x = 99;
    y = 88;

    // Call the lambda again
    lambda();

    return 0;
}
Captured x by reference: 42
Captured y by reference: 77
Captured x by reference: 99
Captured y by reference: 77
=============================================
================================================================
message queue header files.
if you are using the conditional variable when you will unlock it?
thread sleep
inserting the element into the queue, reading and erasing?
consumer waits for ever?
cv.wait. can access the the global variable?
cv.wait will have the return ?
you need the unlock after cv.wait
thread creation for producer and consumer
conditin wait will work on the which lock?
consumer thread also has to unlock?

#include <iostream>
#include <queue>
#include <mutex>
#include <thread>
#include <condition_variable>

std::queue<int> messageQueue;
std::mutex mtx;
std::condition_variable cv;
condition wait access the global vraible?
cv wait return?

void producer() {
    for (int i = 0; i < 10; ++i) {
        std::unique_lock<std::mutex> lock(mtx);
        messageQueue.push(i);
        lock.unlock();
        cv.notify_all();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

void consumer() {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [] { return !messageQueue.empty(); });
        int msg = messageQueue.front();
        messageQueue.pop();
        lock.unlock();
        std::cout << "Received message: " << msg << std::endl;
    }
}

int main() {
    std::thread producerThread(producer);
    std::thread consumerThread(consumer);
    producerThread.join();
    consumerThread.join();
    return 0;
}

here the producer thread after finishing the consumer thread will keep waiting for ever.
Received message: 0
Received message: 1
Received message: 2
Received message: 3
Received message: 4
Received message: 5
Received message: 6
Received message: 7
Received message: 8
Received message: 9
consumer thread waits forever
================================================
if the lamda function is not taking any argument []() can be changed to []
list of header files required?
consumer thread no waiting
condition wait access the global vraible?
different ways to initilize the atomic variable?
thread  join
does the consumer thread needs to unlock?

std::atomic<bool> producerDone(false); 
std::atomic<bool> producerDone=(false); 
std::atomic<bool> producerDone{false}; 
std::atomic<bool> producerDone={false}; 
std::atomic<bool> producerDone=false;

#include <iostream>
#include <queue>
#include <mutex>
#include <thread>
#include <condition_variable>
#include <atomic>

std::queue<int> messageQueue;
std::mutex mtx;
std::condition_variable cv;
std::atomic<bool> producerDone(false); // Shared flag variable

void producer() {
    for (int i = 0; i < 10; ++i) {
        std::unique_lock<std::mutex> lock(mtx);
        messageQueue.push(i);
        lock.unlock();
        cv.notify_all();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    // After producer finishes its work
    producerDone = true;
    cv.notify_all(); // Notify consumer thread to exit the loop
}
//lamda can access the global variable outside the main and modify it
//but cannot access the the local vraible when []
void consumer() {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [] { return !messageQueue.empty() || producerDone; });

        // Check if the producer is done and the queue is empty
        if (producerDone && messageQueue.empty()) {
            lock.unlock();
            break; // Exit the loop if producer is done and queue is empty
        }

        // Process the message
        int msg = messageQueue.front();
        messageQueue.pop();
        lock.unlock();
        std::cout << "Received message: " << msg << std::endl;
    }
}

int main() {
    std::thread producerThread(producer);
    std::thread consumerThread(consumer);
    producerThread.join();
    consumerThread.join();
    return 0;
}
Received message: 0
Received message: 1
Received message: 2
Received message: 3
Received message: 4
Received message: 5
Received message: 6
Received message: 7
Received message: 8
Received message: 9
==============================================================================
cv wait using the class member function
call the class member function and object in the thread creation
if the lamda has no member argument , you needn't use the argument paranthesis [this](){} to [this] {}
which thread variable class member takes?
if the lamda is used in the class member function then this is must?
unique_lock is is local variable?

mutex and the condition variable?

#include <iostream>
#include <queue>
#include <mutex>
#include <thread>
#include <condition_variable>

class MyClass {
public:
    MyClass() : messageQueue(), mtx(), cv() {}

    void producer() {
        for (int i = 0; i < 10; ++i) {
            std::unique_lock<std::mutex> lock(mtx);
            messageQueue.push(i);
            lock.unlock();
            cv.notify_all();
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    }

    void consumer() {
        while (true) {
            std::unique_lock<std::mutex> lock(mtx);
            cv.wait(lock, [this] { return !messageQueue.empty(); }); // Using a member function as the condition
            int msg = messageQueue.front();
            messageQueue.pop();
            lock.unlock();
            std::cout << "Received message: " << msg << std::endl;
        }
    }

private:
    std::queue<int> messageQueue;
    std::mutex mtx;
    std::condition_variable cv;
};

int main() {
    MyClass myClass;

    std::thread producerThread(&MyClass::producer, &myClass);
    std::thread consumerThread(&MyClass::consumer, &myClass);

    producerThread.join();
    consumerThread.join();

    return 0;
}
===================================================
replace unique_lock with lock_guard
what happens if we notify without releasing the lock?

//it is not recommended to notify before releasing the lock. When you notify without releasing the lock, the consumer thread might wake
// up immediately, but since the lock is still held by the producer thread, the consumer thread won't be able to proceed until the lock is released.
void producer() {
    for (int i = 0; i < 10; ++i) {
        std::lock_guard<std::mutex> lock(mtx); // Acquires the lock
        messageQueue.push(i);
        cv.notify_all();
        // lock automatically released when it goes out of scope
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    // After producer finishes its work
    producerDone = true;
    cv.notify_all(); // Notify consumer thread to exit the loop
}
===============================
fill the element with consequitive increasing order?
header files required
std::iota is a standard C++ algorithm available in the <numeric> header that is used to fill a range of elements with consecutive values.

The std::iota function is typically used to fill a range with incrementing values. 
#include <iostream>
#include <algorithm>
#include <numeric> // for std::iota and accumulate

int main() {
    const int arraySize = 10; // Change the size according to your requirement
    int myArray[arraySize];

    // Fill the array with increasing values using std::iota
    std::iota(myArray, myArray + arraySize, 0);

    // Print the array
    std::cout << "Array elements: ";
    for (int i = 0; i < arraySize; ++i) {
        std::cout << myArray[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
insert the number in increasing oreder
0 1 2 3 4 5 6 7 8 9
=========================================================
fill the element in the vector with a number in increasing order in single line;
header file required?

std::vector<int> myVector(5); // Create a vector of size 5

    int initialValue = 10;
    std::iota(myVector.begin(), myVector.end(), initialValue);
====================================================
iota cannot incrment the value interms of 2 . what we will do in that case?

#include <iostream>
#include <numeric>
#include <vector>

int main() {
    std::vector<int> numbers(5);  // Create a vector with 5 elements

    int startValue = 1;
    int step = 2;

    std::iota(numbers.begin(), numbers.end(), startValue);
    
    // Manually increment by 2
    for (auto& number : numbers) {
        number *= step;
    }

    for (const auto& number : numbers) {
        std::cout << number << " ";
    }

    return 0;
}

=============================
create the array with decreasing order of values?

#include <iostream>
#include <algorithm>
#include <numeric> // for std::iota

int main() {
    const int arraySize = 10; // Change the size according to your requirement
    int myArray[arraySize];

    // Fill the array with increasing values using std::iota
    std::iota(myArray, myArray + arraySize, 0);

    // Reverse the array to get decreasing order
    std::reverse(myArray, myArray + arraySize);

    // Print the array
    std::cout << "Array elements in decreasing order: ";
    for (int i = 0; i < arraySize; ++i) {
        std::cout << myArray[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
output:
9876543210
=====================================
============================================
a number to string (float, integer)
#include <iostream>
#include <string>

int main() {
    int num = 42;
    std::string str = std::to_string(num); //num can be number or float
    std::cout << "Integer converted to string: " << str << std::endl;
    return 0;
}
==============================================

can you provide me a c++ function template takes 2 integer argument and 2 float argument?


#include <iostream>

template <typename T1, typename T2>
void myFunction(T1 intArg1, T1 intArg2, T2 floatArg1, T2 floatArg2) {
    // Do something with the arguments
    std::cout << "Integer Argument 1: " << intArg1 << std::endl;
    std::cout << "Integer Argument 2: " << intArg2 << std::endl;
    std::cout << "Float Argument 1: " << floatArg1 << std::endl;
    std::cout << "Float Argument 2: " << floatArg2 << std::endl;
}

int main() {
    int intVal1 = 10;
    int intVal2 = 20;
    float floatVal1 = 3.14;
    float floatVal2 = 2.718;

    myFunction(intVal1, intVal2, floatVal1, floatVal2);

    return 0;
}

============================================
How to launch a thread using function objects and function pointer?
a. create the thread with functor taking the int argument
b. what happen if we are not joining the thread .
c.why thread join is must?
terminate called without an active exception. when we use the thread you are expected to have join doesn't matter whether the child thread 
//terminate or not . else you will get the terminate called execption

c. can  i pass & for functor?
d. sleep the thread

seconds not second ?
this_thread::sleep_for(chrono::milliseconds(6));
this_thread::sleep_for(chrono::seconds(6));
Answer:
Using function object –

#include <csignal>
#include <iostream>
#include<thread>
  
using namespace std;
class fn_object_class {
 public: 
void operator () (int params)
{
}
};
int main()
{
    int params = 10;
std::thread thread_object(fn_object_class(), params); //std::thread thread_object(&fn_object_class(), params); //error & not allowed
thread_object.join();
return 0;
}
===============================
headerfile for thread?
can i pass & for the global function?
how to create the thread with with global function and argument
thread taking functor() and argument
important point in exit of thread

Std:: thread thread_object(fn_class_object(), params)
Using function pointer –

void foo(param)
{
}
std::thread thread_obj (foo, params); // or std::thread thread_obj (&foo, params);
if (thread_obj.joinable())
{
   thread_obj.join()
}
=======================================

==============================
c+14 feature?
a. binary literal
b. generalized lamda function
c. variable template
d. relaxed constexpr
e. decltype(auto)

decltype ,auto and constexpr are the part of c++ language hence doesn't require the special header


#include <iostream>
#include <vector>

// Example of binary literals
int binaryLiteral = 0b101010;

// Example of generic lambda
auto genericLambda = [](auto x, auto y) { //in c+11 it is auto genericLambda = [](int x, int y)
    return x + y;
};

// Example of variable template
template<typename T>
constexpr T pi = T(3.1415926535897932385);

// Example of relaxed constexpr function
constexpr int factorial(int n) {
    int result = 1;
    for (int i = 2; i <= n; ++i) {
        result *= i;
    }
    return result;
}

int main() {
    // Using binary literal
    std::cout << "Binary Literal: " << binaryLiteral << std::endl;

    // Using generic lambda
    std::cout << "Generic Lambda: " << genericLambda(10, 20) << std::endl;

    // Using variable template
    std::cout << "Pi: " << pi<double> << std::endl;

    // Using relaxed constexpr function
    int num = 5;
    std::cout << "Factorial of " << num << " is: " << factorial(num) << std::endl;

    return 0;
}

======================================
features in c++14?

variable template usuage:

template and constexpr is required

variable template example: (c+14)
#include <iostream>

// Variable template for π (pi) constant
template <typename T>
constexpr T pi = T(3.1415926535897932385);

// Function to calculate the circumference of a circle
template <typename T>
T circleCircumference(T radius) {
    return 2 * pi<T> * radius;
}

int main() {
    double radius_double = 2.5;
    float radius_float = 1.8;

    // Calculate circumference for double and float types
    double circumference_double = circleCircumference(radius_double);
    float circumference_float = circleCircumference(radius_float);

    std::cout << "Circumference of circle with radius " << radius_double << " (double): " << circumference_double << std::endl;
    std::cout << "Circumference of circle with radius " << radius_float << " (float): " << circumference_float << std::endl;

    return 0;
}

========================================
c++14
declaring the variable type to be th return reference , double reference
why we need the auto& in the return type?

// C++14 program to illustrate return
// type deduction using auto&
#include <iostream>
using namespace std;

// Function to increment the value
// of a and return the updated value
auto& increase(int& a) // if no & will return the error since it is an integer and you need the const before the variable in the caller.
{
	a++;
	return a;
}

// Driver Code
int main()
{
	int b = 10;

	// Function Call
	int& c = increase(b);
	cout << b << '\n'
		<< c;

	return 0;
}
============================
declaring the variable type to be th return reference , double reference
why we cannot change the && reference
in which version of c++ it is introduced?

c+14 decl(auto)
#include <iostream>
#include <vector>

// Function returning an lvalue reference
int& getLvalue() {
    static int value = 42;
    return value;
}

// Function returning an rvalue reference
int&& getRvalue() {
    return 99;
}

int main() {
    // Using decltype(auto) with lvalue reference
    decltype(auto) lvalueRef = getLvalue();
    lvalueRef++; // Modifying the referenced value
    std::cout << "Value after modification: " << getLvalue() << std::endl;

    // Using decltype(auto) with rvalue reference
    decltype(auto) rvalueRef = getRvalue();
    std::cout << "Value obtained from rvalue reference: " << rvalueRef << std::endl;
	 // rvalueRef++; // This would be an error Rvalues are temporary values that do not have a persistent memory location, and attempting to modify them directly is 
	 //not allowed.it typically returns a temporary value, and you should treat it as read-only

    return 0;
}
Lvalue Reference: The getLvalue function returns an lvalue reference to a static variable. We use decltype(auto) to deduce the type of the reference returned by getLvalue. The lvalueRef variable is deduced as an int&, 
allowing us to modify the referenced value. We increment lvalueRef and print the modified value.

Rvalue Reference: The getRvalue function returns an rvalue reference to an integer literal. Again, we use decltype(auto) to deduce the type of the reference returned by getRvalue. The rvalueRef variable is deduced as an 
int&&, allowing us to obtain and print the value from the rvalue reference.
=====================================================
=======================================
===========================

===============================


 ========================

=======================================

=====================================


=============================
enum
unscoped
scoped
forward or opaque

conversion enum to integer;

how to determine the size of the class having the emum bit foeld?

forward declaration enum value?

unscoped enum:
assigning enum to integer
assigning to int after doing the enum value increment

unscoped enumeration:
enum color { black, blue, green, cyan, red, magenta, yellow, white };
int c1{yellow};
color c2{ color(c1 + 1) };
color c3{ static_cast<color>(c2 + 1) };

bit field can apply only for the member variable;
sizeof will not work on bitfield
static variable cannot have bitfield
needn't specify the size; compiler will automatically detect the size
bit field for enum?

enum color { black, red, green, yellow, blue, magenta, cyan, white };
class demo {
 color okay : 3; // big enough
 color small : 2; // oops, not enough bits, but valid C++ //make sure log2(N) = 3 bits . N represent the enum value
};

class demo {
    color okay : 3;  // Requires 3 bits
    color small : 3; // Sufficient bits for all 8 enumerators
};

//sizeof the demo will 6bits so routed to the nearest 4 bytes 

scoped enumeration:
scoped enum will have the class keyword in the enum declaration

enum class sign : char { negative, positive };
here the negative and positive is of the char type. here char is called underlying type. if you ommit the :char it become theinteger type

int main() {
    //enum sign : char { negative =516, positive }; //error negative can take the max value of char
	enum class sign : char { negative, positive };
    std::cout <<sizeof (sign); //1
    return 0;
}
============================

forward declaration of enum or opaque declaration:
enum class deferred : short;
enum class deferred : short { example, of, forward, declared, enumeration };

class demo {
 enum hidden : unsigned;
 ...
};

#ifndef MY_CLASS_H
#define MY_CLASS_H

class MyClass {
public:
    // Opaque declaration of the nested enum
    enum class MyEnum: char;

    void setEnumValue(MyEnum value);
    void printEnumValue();

private:
    MyEnum enumValue;
};

#endif // MY_CLASS_H
#include "my_class.h"

// Definition of the nested enum and its enumerators
enum class MyClass::MyEnum: char {
    Value1, //enumeration value
    Value2,
    Value3
};
int main() {
    MyClass obj; //here the enum MyClass obj; 3
    obj.setEnumValue(MyClass::MyEnum::Value1);
}

=========
both declaration and deffinition should have the same underlying type (char). if the char is not there in the declaration then definition also
should not have definition
enum class MyEnum:char;
// Definition of the nested enum and its enumerators
enum class MyEnum: char {
    Value1,
    Value2,
    Value3
};
===========================================================
what is the advantage of the scoped enum over the unscoped

#include <iostream>

enum class ColorClass { black, red, green, yellow, blue, magenta, cyan, white }; //scoped enum
enum ColorEnum { black, red, green, yellow, blue, magenta, cyan, white }; //unscoped enum

int main() {
    // Scoped enumeration
    ColorClass classColor = ColorClass::red;
    // classColor = 1; // Error: Cannot assign an integer value to a scoped enumerator . even static_cast cannot convert
    //int iy = (Color::RED); but you can use static_cast<int> to convert
	//enum color { black, blue, green, cyan, red, magenta, yellow, white };
    // int c1{yellow}; allowed
    // Unscoped enumeration
    ColorEnum enumColor = red;
    enumColor = 1; // Okay: Enumerators can be implicitly used as integers

    // Comparison
    if (classColor == ColorClass::red) {
        std::cout << "Scoped enumeration: It's red!" << std::endl;
    }

    if (enumColor == red) {
        std::cout << "Unscoped enumeration: It's red!" << std::endl;
    }

    return 0;
}

=============================================================
if the unscoped enum is declared/defined inside the class it become the scoped enum

iterare over enum using integer
#include <iostream>

enum class Color {
    RED, GREEN, BLUE
};

int main() {
    // Iterate over enum values
    for (int i = static_cast<int>(Color::RED); i <= static_cast<int>(Color::BLUE); i++) {
        Color color = static_cast<Color>(i);
        // Do something with the color
        switch (color) {
            case Color::RED:
                std::cout << "RED" << std::endl;
                break;
            case Color::GREEN:
                std::cout << "GREEN" << std::endl;
                break;
            case Color::BLUE:
                std::cout << "BLUE" << std::endl;
                break;
        }
    }

    return 0;
}

#include <iostream>

enum class Color {
    RED, GREEN, BLUE
};

int main() {
    // Iterate over enum values using range-based for loop
    for (auto& color : {Color::RED, Color::GREEN, Color::BLUE}) {
        // Do something with the color
        switch (color) {
            case Color::RED:
                std::cout << "RED" << std::endl;
                break;
            case Color::GREEN:
                std::cout << "GREEN" << std::endl;
                break;
            case Color::BLUE:
                std::cout << "BLUE" << std::endl;
                break;
        }
    }

    return 0;
}
===================================================
#include <iostream>

int main() {
    int a[] = {1, 2, 3, 4}; // Removed the extra comma

    for (auto i : a) {
        std::cout << i << " ";
    }

    return 0;
}
1 2 3 4
====================================
to declare the array for the enum?

#include <iostream>

enum class Color {
    RED, GREEN, BLUE
};

int main() {
    // Create an array or initializer list with enum values
    Color colors[] = {Color::RED, Color::GREEN, Color::BLUE};

    // Iterate over enum values using range-based for loop
    for (auto& color : colors) {
        // Do something with the color
        switch (color) {
            case Color::RED:
                std::cout << "RED" << std::endl;
                break;
            case Color::GREEN:
                std::cout << "GREEN" << std::endl;
                break;
            case Color::BLUE:
                std::cout << "BLUE" << std::endl;
                break;
        }
    }

    return 0;
}

===============================================================
2 enum can have the same value
enum Color {
    RED = 1,
    GREEN = 1,
    BLUE = 3,
    WHITE = 4,
    BLACK = 4, // Both BLACK and WHITE have the same value (4)
};
====================================
if you define the enum inside class it is called scoped enum
class MyClass {
public:
    enum MyEnum {
        Value1,
        Value2,
        Value3
    };
};

int main() {
    MyClass::MyEnum enumValue = MyClass::Value2;
    // ...
    return 0;
}

==============================================
Coverting the enum value to integer?

cast to integer and then increment it.

we can directly covert in the case of the unscoped enum. no static_cats is required.

#include <iostream>

// Define an enum for enum-like behavior
enum MyEnum {
    ENUM_VALUE_1 = 1,
    ENUM_VALUE_2 = 2,
};

// Function to increment the enum-like value
void incrementEnum(MyEnum& value) {
    value = static_cast<MyEnum>(static_cast<int>(value) + 1);
}

int main() {
    MyEnum enumValue1 = ENUM_VALUE_1;
    MyEnum enumValue2 = ENUM_VALUE_2;

    std::cout << "Initial values:" << std::endl;
    std::cout << "Enum Value 1: " << enumValue1 << std::endl; // Output: 1
    std::cout << "Enum Value 2: " << enumValue2 << std::endl; // Output: 2

    // Increment the enum-like values
    incrementEnum(enumValue1);
    incrementEnum(enumValue2);

    std::cout << "\nAfter increment:" << std::endl;
    std::cout << "Enum Value 1: " << enumValue1 << std::endl; // Output: 2
    std::cout << "Enum Value 2: " << enumValue2 << std::endl; // Output: 3

    return 0;
}

=========================================================
enum value with or operation

#include <iostream>

enum class Color : unsigned int {
    RED = 1,
    GREEN = 2,
    BLUE = 4,
    YELLOW = RED | GREEN,
    MAGENTA = RED | BLUE,
    CYAN = GREEN | BLUE,
    WHITE = RED | GREEN | BLUE,
};

class ColorDemo {
public:
    ColorDemo() : colorBits(0) {}

    void setColor(Color color) {
        colorBits |= static_cast<unsigned int>(color);
    }

    void unsetColor(Color color) {
        colorBits &= ~static_cast<unsigned int>(color);
    }

    bool hasColor(Color color) const {
        return (colorBits & static_cast<unsigned int>(color)) != 0;
    }

    void printColors() const {
        std::cout << "Current Colors: ";
        if (hasColor(Color::RED)) std::cout << "RED ";
        if (hasColor(Color::GREEN)) std::cout << "GREEN ";
        if (hasColor(Color::BLUE)) std::cout << "BLUE ";
        std::cout << std::endl;
    }

private:
    unsigned int colorBits;
};

int main() {
    ColorDemo demo;

    demo.setColor(Color::RED);
    demo.setColor(Color::GREEN);
    demo.setColor(Color::BLUE);

    demo.printColors();

    demo.unsetColor(Color::GREEN);
    demo.printColors();

    return 0;
}

========================================================================
===========================================================================
iterator comparsion:
iterator subraction
header file

#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> myVector = {1, 2, 3, 4, 5};

    // Swap elements using iterators
    auto it1 = myVector.begin();  // Iterator to the first element
    auto it2 = myVector.end() - 1;  // Iterator to the last element

    if (it1 < it2) {
        std::iter_swap(it1, it2);
    }

    // Output the vector after the swap
    for (const auto& element : myVector) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    return 0;
}
52341
=================================

different ways to find whether the key is present or not?
bool t= (myMap.count(3) ;

 auto it = myMap.find(3);

    if (it != myMap.end()) { "not found"
	}
===========
not unorder it is unordered
print the map? using pair?
to find the key present in map?

std::unordered_map to create a hash table with keys of type int and values of type std::string
#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    // Create an unordered_map with keys of type int and values of type std::string
    std::unordered_map<int, std::string> myMap;

    // Insert key-value pairs into the unordered_map
    myMap.insert({1, "apple"});
    myMap.insert({2, "banana"});
    myMap.insert({3, "orange"});

    // Access elements using their keys
    std::cout << "Value at key 2: " << myMap[2] << std::endl;

    // Check if a key exists in the unordered_map
    if (myMap.count(3) > 0) { //return true or false
        std::cout << "Key 3 exists!" << std::endl;
    } else {
        std::cout << "Key 3 does not exist!" << std::endl;
    }

    // Modify the value associated with a key
    myMap[1] = "kiwi";

    // Print all key-value pairs in the unordered_map
    std::cout << "All elements in the unordered_map:" << std::endl;
    for (const auto& pair : myMap) {
        std::cout << "Key: " << pair.first << ", Value: " << pair.second << std::endl;
    }

    return 0;
}

====================================================================
how to insert the class object inside the vector?

optimized version for the vector containing the class?

osstream_iterator
to print the content from the vector
to print the content from the vector of class object
to update the vector int and print the content

insert the class object into the vector?

 std::vector<Point> points;
    points.emplace_back(1, 2);
    points.emplace_back(3, 4);
    points.emplace_back(5, 6);
	
std::vector<Point> points = {Point(1, 2), Point(3, 4), Point(5, 6)};
===================================================================================   
ostream_iterator present in c++98:

write iterator move forward only
std::ostream_iterator is an output iterator in C++ that allows you to write data to a specified output stream.

std::ostream_iterator<T> out{std::ostream_type, delimiter};

#include <iostream>
#include <iterator>
#include <vector>
int main()
{
 std::vector<int> data{ 10, 42 };
 // Create an ostream_iterator that writes integers to std::cout 
 std::ostream_iterator<int> out{ std::ostream_iterator<int>(std::cout, " ") }; // 10 42
 std::copy(data.begin(), data.end(), out);
 //--out; error
}

#include <iostream>
#include <vector>
#include <iterator>

// Sample user-defined class
class Point {
public:
    Point(int x, int y) : x_(x), y_(y) {}

    // Define the operator<< to enable output of Point objects
    friend std::ostream& operator<<(std::ostream& os, const Point& point) {
        os << "(" << point.x_ << ", " << point.y_ << ")";
        return os;
    }

private:
    int x_;
    int y_;
};

int main() {
    std::vector<Point> points = {Point(1, 2), Point(3, 4), Point(5, 6)};

    // Create an ostream_iterator to output Point objects to std::cout with a newline delimiter
    std::ostream_iterator<Point> out{std::cout, "\n"};

    // Use std::copy with the ostream_iterator to output the Point objects from the vector
    std::copy(points.begin(), points.end(), out);

    return 0;
}

========================================================================
explicit keyword:
#include <iostream>

class MyClass {
public:
    // Regular constructor
    explicit MyClass(int x) : value(x) {}

    int getValue() const { return value; }

private:
    int value;
};

int main() {
    MyClass obj1(42); // Direct initialization, allowed with explicit constructor
    std::cout << "obj1 value: " << obj1.getValue() << std::endl;

    // Uncommenting the line below would result in a compilation error
    // MyClass obj2 = 10; // Error: Implicit conversion not allowed due to 'explicit'

    return 0;
}
======================================
friend class
//cout taking object and the std::endl;
here the std::endl is not passed to the friend function
#include <iostream>

class MyClass {
public:
    MyClass(int x) : value(x) {}

    // This function is a friend of MyClass and can access private members directly
    friend std::ostream& operator<<(std::ostream& os, const MyClass& obj) {
        os << "Value: " << obj.value; // Custom output formatting
        return os;
    }

private:
    int value;
};

int main() {
    MyClass obj(42);

    // Using the overloaded << operator to print the object
    std::cout << obj << std::endl;

    return 0;
}
Value: 42
==========================================================================================
itertator comparsion in swapping the element of the vector.

#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>
int main()
{
 std::vector<int> data{};
 int x{};
 while (std::cin >> x)
 data.push_back(x);
 for (std::vector<int>::iterator start{data.begin()}, end{data.end()};
 start != end;
 /*empty*/)
 {
 --end;
 if (start != end)
 {
 std::iter_swap(start, end);
 ++start;
 }
 }
 std::copy(data.begin(), data.end(), std::ostream_iterator<int>(std::cout, "\n"));

}
1 2 3 4 5 6 7 8 q
8 
7
 6
 5 
 4 
 3 
 2 
 1
================================================
alternative for &&

    token for and?
itertator comparsion in swapping the element of the vector.
header file required?
print the data to the output screen using the ostream_iterator

#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>
int main()
{
 std::vector<int> data{};
 int x{};
 while (std::cin >> x)
 data.push_back(x);
 for (std::vector<int>::iterator start{data.begin()}, end{data.end()};
 start != end and start != --end;
 ++start)
 {
 std::iter_swap(start, end);
 }
 std::copy(data.begin(), data.end(), std::ostream_iterator<int>(std::cout, "\n"));
}
===================================================
different ways to insert the element into the vector
vector.inert(vector.end(),)
for loop
back_inserter

istream to get the input for the vector and reverse and print using ostream
header file required?

#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>

int main()
{  
 std::vector<int> data{};//{}
 // Read integers from the standard input, and append them to the end of data.
 data.insert(data.end(), std::istream_iterator<int>(std::cin), std::istream_iterator<int>());
 // Reverse the order of the contents of data.
 std::reverse(data.begin(), data.end());
 // Print data, one number per line.
 std::copy(data.begin(), data.end(), std::ostream_iterator<int>(std::cout, "h"));
}
1 2 3 4 5 6 q
6 h5 h4h 3h 2h 1h
==========================================
read the element from the screen and keep inserting into the vector of class object?
function has to friend

To use istream_iterator with a user-defined class myclass, you need to define the extraction operator operator>> 
for myclass so that the istream_iterator knows how to read objects of myclass
#include <iostream>
#include <iterator>
#include <vector>

class myclass {
public:
    int value;

    // Define the extraction operator for myclass
    friend std::istream& operator>>(std::istream& is, myclass& obj) {
        return is >> obj.value;
    }
};

int main() {
    std::vector<myclass> data;
    myclass x;

    // Read data from the user using istream_iterator
    std::copy(
        std::istream_iterator<myclass>(std::cin),
        std::istream_iterator<myclass>(),
        std::back_inserter(data)
    );

    // Print the data in the vector
    for (const auto& obj : data) {
        std::cout << obj.value << " ";
    }
    std::cout << std::endl;

    return 0;
}
10 20 30 q
10 20 30
=========
read the element from the screen and keep inserting into the vector in single line using copy.
header file required


istream_iterator for vector
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> data{};

    // Read data from the user using istream_iterator
    std::copy(
        std::istream_iterator<int>(std::cin),
        std::istream_iterator<int>(),
        std::back_inserter(data)
    );

    // Print the data in the vector
    for (const auto& num : data) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
=============================================
read the data from the string and insert into the vector using vector

header file required?


#include <iostream>
#include <iterator>
#include <sstream>
#include <vector>

int main() {
    std::string inputString = "10 20 30 40 50";
    std::istringstream iss(inputString);

    // Create an istream_iterator<int> to read integers from the string stream
    std::istream_iterator<int> begin(iss);
    std::istream_iterator<int> end; //std::istream_iterator is useful when we want to construct an iterator that represents the end of the input stream.

    // Store the integers in a vector
    std::vector<int> numbers(begin, end); //or  std::vector<int> numbers(begin, std::istream_iterator<int>());

    // Print the numbers
    for (const auto& num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}

input 10 20 qBuf 30
output 10 20 

input 10     20   20
output 10 20 20

=============================================
read the data from the string and insert into the vector using copy

#include <iostream>
#include <iterator>
#include <sstream>
#include <vector>

int main() {
    std::string input = "10 20 30 40 50";
    std::istringstream iss(input); // Create an input stream from a string

    // Use std::istream_iterator to read integers from the input stream
    std::vector<int> numbers;
    std::copy(
        std::istream_iterator<int>(iss), // Begin iterator: reads from 'iss'
        std::istream_iterator<int>(),    // End iterator: stops when end of stream is reached, default constructor
        std::back_inserter(numbers)      // Output iterator: inserts into 'numbers'
//std::back_inserter is an iterator adapter provided by the C++ Standard Library. It is used to insert elements at the end of a
// container using the std::copy algorithm or other algorithms that accept iterators.
    );

    // Print the numbers in the vector
    for (int num : numbers) {
        std::cout << num << " ";
    }

    return 0;
}

=============================================
read the data from the file and write into the vector

Assume you have a file named "input.txt" with the following content:
10 20 30 40 50
#include <iostream>
#include <fstream>
#include <iterator>
#include <vector>

int main() {
    std::ifstream inputFile("input.txt");
    if (!inputFile.is_open()) {
        std::cerr << "Failed to open the file." << std::endl;
        return 1;
    }

    std::vector<int> data;

    // Read data from the file using istream_iterator
    std::copy(
        std::istream_iterator<int>(inputFile),
        std::istream_iterator<int>(),
        std::back_inserter(data) 
//std::back_inserter is an iterator adapter provided by the C++ Standard Library. It is used to insert elements at the end of a
// container using the std::copy algorithm or other algorithms that accept iterators.
    );

    // Print the data in the vector
    for (const auto& num : data) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}

10 20 30 40 50

if the input file contain 10 a 20 30

output will be 10
========================================================
factors to be considered while working with file?

ofstream_iterator to write the vector data into the file

#include <iostream>
#include <fstream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> data = {10, 20, 30, 40, 50};

    // Open the output file
    std::ofstream outputFile("output.txt");
    if (!outputFile.is_open()) {
        std::cerr << "Failed to open the output file." << std::endl;
        return 1;
    }

    // Write data to the file using ostream_iterator
    std::copy(
        data.begin(),
        data.end(),
        std::ostream_iterator<int>(outputFile, " ")// temp object will be created
    );

    // Close the output file
    outputFile.close();

    return 0;
}
=============================================
std::ostringstream allows us to concatenate different data types into a single string in a convenient way, making it useful for various 
formatting and string construction tasks.

#include <iostream>
#include <sstream>
#include <string>

int main() {
    // Create an ostringstream object
    std::ostringstream oss;

    // Build the string using the ostringstream
    int num1 = 42;
    double num2 = 3.14;
    std::string str = "Hello";

    oss << "This is a sample output: " << num1 << ", " << num2 << ", " << str;

    // Get the constructed string using str() method
    std::string result = oss.str();

    // Output the constructed string
    std::cout << result << std::endl;

    return 0;
}
This is a sample output: 42, 3.14, Hello
====================================
header file required?
raed the int, douuble and string from the string in single line and  print the content?

#include <iostream>
#include <sstream>
#include <string>

int main() {
    std::string data = "42 3.14 Hello";

    // Create an istringstream object with the input data
    std::istringstream iss(data);

    // Read values from the istringstream
    int num1;
    double num2;
    std::string str;

    (iss >> num1 >> num2 >> str); // if success return true

    // Output the extracted values
    std::cout << "num1: " << num1 << std::endl;
    std::cout << "num2: " << num2 << std::endl;
    std::cout << "str: " << str << std::endl;

    return 0;
}
================================
header file required?
raed the numbers from the string and multiply the number and store it in the string?

#include <iostream>
#include <sstream>
#include <string>

int main() {
    std::string data = "1 2 3 4 5";
    std::istringstream iss(data);
    std::ostringstream oss; // or  std::stringstream oss;

    int num;
    while (iss >> num) {
        // Process the data (e.g., perform some calculations)
        num = num * 2;

        // Write the processed data to ostringstream
        oss << num << " ";
    }

    std::string result = oss.str();
    std::cout << "Processed data: " << result << std::endl;

    return 0;
}
Processed data: 2 4 6 8 10
==================================================
std::cin (which is an instance of std::istream)

istream_iterator:
The std::istream_iterator is a useful tool for reading data from an input stream while utilizing the iterator interface. It can be employed in various 
scenarios, such as reading data from files, processing user input, or parsing input streams with well-defined formats.
std::vector<int> numbers{
	std::istream_iterator<int>(std::cin), // Begin iterator (reads from cin)
	std::istream_iterator<int>()          // End iterator (signals the end of input)
};
====
writing my own logic to add the elements from the istream_iterator into the vector in the declaration?
   // Create istream iterators from std::cin
    std::istream_iterator<int> begin(std::cin);
    std::istream_iterator<int> end;

    // Store the integers in a vector
    std::vector<int> numbers(begin, end);
====
     writing my own logic to add the elements from the istream_iterator into the vector using for loop
    std::vector<int> numbers;

    // Read integers from standard input using istream_iterator
    std::cout << "Enter integers (Enter a non-integer to stop): ";
    std::istream_iterator<int> iter(std::cin);
    std::istream_iterator<int> end;

    while (iter != end) {
        numbers.push_back(*iter);
        ++iter;
    }
===============
=======================================================================
double result = 0.0 / 0.0; //NAN
double result = std::sqrt(-1.0); //NAN
#include <iostream>
#include <cmath>
#include <limits>

int main() {
    double nanValue = std::numeric_limits<double>::quiet_NaN();
    double validValue = 42.0;

    if (std::isnan(nanValue)) {
        std::cout << "nanValue is NaN." << std::endl;
    } else {
        std::cout << "nanValue is not NaN." << std::endl;
    }

    if (std::isnan(validValue)) {
        std::cout << "validValue is NaN." << std::endl;
    } else {
        std::cout << "validValue is not NaN." << std::endl;
    }

    return 0;
}
======================================================
========================================================
isstream passing to the accumulate	

#include <iostream>
#include <iterator>
#include <algorithm>

int main() {
    // Read integers from std::cin (standard input) and find their sum
    std::cout << "Enter a sequence of integers (Ctrl+Z or Ctrl+D to end input): ";
    std::istream_iterator<int> inputBegin(std::cin);  // Iterator for the beginning of input // get only one number
    std::istream_iterator<int> inputEnd;              // Default-constructed end-of-stream iterator

    int sum1 = 0;
    // Use accumulate algorithm to find the sum of the input values
    sum1 = std::accumulate(inputBegin, inputEnd, sum1); /// accumulate will keep reading 2nd, 3rd..integers are read one after the other

    // Output the sum of the input values
    std::cout << "Sum of the input values: " << sum1 << std::endl;

    return 0;
}
======
writing my own accumulate logic for isstring_stream to use accumulate?
a += b; //see where is the + sign
which header file accumulate is present?

move to the next element in cin and read?

#include <iostream>
#include <iterator>
#include <algorithm>
#include <numeric>

int main() {
    // Read integers from std::cin (standard input) and find their sum
    std::cout << "Enter a sequence of integers (Ctrl+Z or Ctrl+D to end input): ";
    std::istream_iterator<int> inputBegin(std::cin);  // Iterator for the beginning of input
    std::istream_iterator<int> inputEnd;              // Default-constructed end-of-stream iterator

    int sum = 0;
    // Use a loop to read and accumulate integers until end-of-stream is encountered
    while (inputBegin != inputEnd) {
        sum += *inputBegin;
        ++inputBegin; // Move to the next element in the input stream and read the character
    }

    // Output the sum of the input values
    std::cout << "Sum of the input values: " << sum << std::endl;

    return 0;
}

Enter a sequence of integers (Ctrl+Z or Ctrl+D to end input): 1 2 3dc 5
Sum of the input values: 6

================================ 
what std::ostream_iterator do?
 std::ostream_iterator, which is used for writing data to an output stream (e.g., std::cout, std::ofstream)
 writing to the vector data to the osstream object?
 how to interate through all the elements of the vector?
 increamenting the osstream and assigning the value?
 
 #include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    // Write data to standard output (console)
    std::cout << "Numbers in the vector: ";
    std::ostream_iterator<int> output(std::cout, " ");
    for (const auto& num : numbers) {
        *output++ = num;
    }
    std::cout << std::endl;

    return 0;
}
=====
int main() {
    //std::vector<char> numbers = {1, 2, 3, 4, 5};
    std::string numbers = "viswa";
    // Write data to standard output (console)
    std::cout << "Numbers in the vector: ";
    std::ostream_iterator<int> output(std::cout, " "); //108 115 ...
    for (const auto& num : numbers) {
        *output++ = num;
    }
    std::cout << std::endl;

    return 0;
}
====================================================
creating the class member vaiable as reference:
Thread Termination: When the std::thread object threadObj goes out of scope without being joined or detached, it will terminate the 
program by calling std::terminate(). In your code, you have commented out the threadObj.detach() line, which means the thread is 
not detached. However, you haven't explicitly joined the thread either.
It's important to manage threads appropriately based on your application's requirements. Detaching a thread is useful when you 
don't need to synchronize or wait for its completion. 
Joining a thread is helpful when you want to synchronize and obtain the result of a thread's execution
class ThreadRAII
{
    std::thread & m_thread;
    public:
        ThreadRAII(std::thread  & threadObj) : m_thread(threadObj)
        {
            
        }
        ~ThreadRAII()
        {
            // Check if thread is joinable then detach the thread
            if(m_thread.joinable())
            {
                m_thread.detach();
            }
        }
};
void thread_function()
{
    for(int i = 0; i < 10000; i++);
        std::cout<<"thread_function Executing"<<std::endl;
}
 
int main()  
{
    std::thread threadObj(thread_function);
    //threadObj.detach();
    // If we comment this Line, then program will crash
    //ThreadRAII wrapperObj(threadObj);
    std::cout << "viswa" <<std::endl;
    return 0;
}

====================================
assigning the lamda function to a lamda function which is return by another lamda function:
#include<functional>
#include<iostream>
std::function<float(float, float)> returnLambda()
{
    return [](float a, float b) {
        return a + b;
    };
}
int main()
{
    auto lmbda = returnLambda();
    std::cout << lmbda(8.2, 6.4) << std::endl;
}
====================
c++11 has the unordered_mutimap and unordered_multiset;
int val [] { 2, 4, 6 };
============
template <typename T>
class MyContainer {
public:
    std::vector<std::vector<T>> data; // Issue in C++11 without space
    // std::vector<std::vector<T> > data; // Correct usage with a space
};

int main() {
    MyContainer<int> container;
    container.data.resize(5);
    container.data[0].push_back(42);

    std::cout << container.data[0][0] << std::endl;

    return 0;
}

===
MovableClass&& operator=(MovableClass&&); 
==============================
weak_ptr;

Driver.h
#ifndef DRIVER_H
#define DRIVER_H

#include <string>
#include <memory>

class Car;

class Driver {
public:
    Driver(const std::string& name);
    void assignCar(std::shared_ptr<Car> car);
    void showCar();
    std::string getName() const;

private:
    std::string name;
    std::weak_ptr<Car> assignedCar;
};

#endif
Driver.cpp:
#include "Driver.h"
#include "Car.h"
#include <iostream>

Driver::Driver(const std::string& name) : name(name) {}

void Driver::assignCar(std::shared_ptr<Car> car) {
    assignedCar = car;
}

void Driver::showCar() {
    if (auto car = assignedCar.lock()) {
        std::cout << name << " is driving a " << car->getName() << "." << std::endl;
    } else {
        std::cout << name << " doesn't have a car." << std::endl;
    }
}

std::string Driver::getName() const {
    return name;
}
====
car.had#ifndef CAR_H
#define CAR_H

#include <string>
#include <memory>

class Driver;

class Car {
public:
    Car(const std::string& make);
    void showDriver();
    std::string getName() const;
    void assignDriver(std::shared_ptr<Driver> driver);

private:
    std::string make;
    std::weak_ptr<Driver> assignedDriver;
};

#endif
====
#include "Car.h"
#include "Driver.h"
#include <iostream>

Car::Car(const std::string& make) : make(make) {}

void Car::showDriver() {
    if (auto driver = assignedDriver.lock()) { //careful it return the shared pointer
        std::cout << "This " << make << " is driven by " << driver->getName() << "." << std::endl;
    } else {
        std::cout << "This " << make << " doesn't have a driver." << std::endl;
    }
}

std::string Car::getName() const {
    return make;
}

void Car::assignDriver(std::shared_ptr<Driver> driver) {
    assignedDriver = driver;
}
=====
main.cpp:
#include "Driver.h"
#include "Car.h"
#include <memory>

int main() {
    std::shared_ptr<Car> car = std::make_shared<Car>("Toyota");
    std::shared_ptr<Driver> driver = std::make_shared<Driver>("Alice");

    car->assignDriver(driver);
    driver->assignCar(car);

    driver->showCar();
    car->showDriver();

    return 0;
}
====
Converting a std::weak_ptr to a std::shared_ptr through lock() temporarily increases the reference count of the resource. 
This ensures that the resource remains alive while you're using it, even if the original std::shared_ptr has gone out of scope.
std::shared_ptr<T> sharedPtr = weakPtr.lock();

if (sharedPtr) {
    // Access and use the managed object using sharedPtr
} else {
    // The resource is no longer available
}
In summary, using lock() on a std::weak_ptr ensures safe access to the managed object by temporarily acquiring shared ownership,
 preventing memory issues and allowing the resource to be safely used even if the original owner has released it.
======================================
attribute:

#include <iostream>

// Deprecated attribute
[[deprecated("This function is deprecated. Use anotherFunction instead.")]]
void deprecatedFunction() {
    std::cout << "This function is deprecated." << std::endl;
}

// Nodiscard attribute
[[nodiscard]]
int getImportantValue() {
    return 42;
}

int main() {
    //during compilation This function is deprecated. Use anotherFunction instead
    deprecatedFunction(); // Generates a warning due to the deprecated attribute
    // if you are not storing the int:warning: ignoring return value of ‘int getImportantValue()’, declared with attribute ‘nodiscard’ [-Wunused-result] 
    int value = getImportantValue();
    std::cout << "Important value: " << value << std::endl;

    return 0;
}

===========================
#include <iostream>
#include <thread>
#include <mutex>
#include <shared_mutex>

std::shared_mutex mutex;
int sharedResource = 0;

void reader() {
    std::shared_lock<std::shared_mutex> lock(mutex);
    std::cout << "Reader: Shared Resource Value: " << sharedResource << std::endl;
}

void writer() {
    std::unique_lock<std::shared_mutex> lock(mutex);
    sharedResource += 10;
    std::cout << "Writer: Shared Resource Value Updated" << std::endl;
}

int main() {
    std::thread readers[3];
    std::thread writerThread;

    for (int i = 0; i < 3; ++i) {
        readers[i] = std::thread(reader);
    }

    writerThread = std::thread(writer);

    for (int i = 0; i < 3; ++i) {
        readers[i].join();
    }

    writerThread.join();

    return 0;
}
Reader: Shared Resource Value: 0
Writer: Shared Resource Value Updated
Reader: Shared Resource Value: 10
Reader: Shared Resource Value: 10
========================

char16_t and char32_t, long long new data type in c++
wchar_t wideChar = L'a';

    wcout << "Wide character: " << wideChar << endl;
========================
#include <iostream>
#include <thread>
#include <vector>

// Define a thread-local variable
thread_local int threadSpecificValue = 0;

void threadFunction(int id) {
    // Modify the thread-local variable
    threadSpecificValue = id;

    // Display the thread-specific value
    std::cout << "Thread " << id << " has thread-specific value: " << threadSpecificValue << std::endl;
}

int main() {
    std::vector<std::thread> threads;

    // Launch multiple threads
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(threadFunction, i);
    }

    // Wait for all threads to finish
    for (auto& thread : threads) {
        thread.join();
    }

    return 0;
}
Thread 0 has thread-specific value: 0
Thread 1 has thread-specific value: 1
Thread 2 has thread-specific value: 2
Thread 3 has thread-specific value: 3
Thread 4 has thread-specific value: 4
=============================================================
the operator that cannot be overloaded are 
. Member selection operator
.* Member selection through pointer to member operator
?:
::
=================
when the class is derived it inherrit
constructor , destructor, assignment, copy constructor, overloading and all public member function
============================
When you assign a std::shared_ptr to a std::weak_ptr, it doesn't increment the reference count of the managed object. 
A std::weak_ptr is designed to provide a non-owning observer of the object, and it does not contribute to the ownership of the object. 
Therefore, the assignment itself doesn't affect the reference count of the underlying object.
========================================
inheritated constructor:
#include <iostream>
#include <string>

class Base {
public:
    Base(const std::string& message) : msg(message) {}

    void printMessage() {
        std::cout << "Base Message: " << msg << std::endl;
    }

private:
    std::string msg;
};

class DerivedUsingUsing : public Base {
public:
    using Base::Base; // Inherit the constructor from Base => DerivedUsingUsing(const std::string& message) : Base(message) {}
};

class DerivedNormal : public Base {
public:
    DerivedNormal(const std::string& message) : Base(message) {}
};

int main() {
    DerivedUsingUsing derivedUsingUsing("Hello using using");
    derivedUsingUsing.printMessage();

    DerivedNormal derivedNormal("Hello normal");
    derivedNormal.printMessage();

    return 0;
}
==================================================
inderived class if the use the below line then ther is no use of the using Base::Base;
//derived class constructor will call the empty base class
    using Base::Base; // Inherit constructor from Base class
    Derived(int x)  {
        cout << "Base constructor called with value: " << endl;
    }
=========================
class Base {
public:
    Base() {
        std::cout << "Base constructor called with message1: " << std::endl;
    }
    Base(const std::string& message) {
        std::cout << "Base constructor called with message2: " << message << std::endl;
    }
};

class DerivedUsingUsing : public Base {
public:
    using Base::Base; // Inherit the constructor from Base
    DerivedUsingUsing(const std::string& message) {
        std::cout << "derived constructor called with message: " << std::endl;
    }
};

int main() {
    // Creating an object of DerivedUsingUsing class
    DerivedUsingUsing derivedObject("nj");

    return 0;
}
Base constructor called with message1: 
derived constructor called with message: 
==================================


trailing return Type: Trailing return types in C++ allow you to specify the return type of a function after its parameter list.
This is particularly useful when the return type is dependent on the function's parameters or involves complex type calculations.

#include <iostream>
#include <type_traits>

// Regular function with a return type
int add(int a, int b) {
    return a + b;
}

// Same function using trailing return type
auto add_trailing(int a, int b) -> int {
    return a + b;
}

// Using trailing return type with decltype
template <typename T, typename U>
auto multiply(T a, U b) -> decltype(a * b) {
    return a * b;
}

int main() {
    int result1 = add(3, 5);
    int result2 = add_trailing(3, 5);

    std::cout << "Regular Add: " << result1 << std::endl;
    std::cout << "Trailing Add: " << result2 << std::endl;

    double result3 = multiply(2.5, 3);
    std::cout << "Multiplication: " << result3 << std::endl;

    return 0;
}
========================================================
generalized non trival uninon:
#include <iostream>
#include <variant>
#include <string>

int main() {
    std::variant<int, double, std::string> myVariant;

    // Assigning an integer value
    myVariant = 42;
    if (std::holds_alternative<int>(myVariant)) {
        std::cout << "Value is an integer: " << std::get<int>(myVariant) << std::endl;
    }

    // Assigning a double value
    myVariant = 3.14;
    if (std::holds_alternative<double>(myVariant)) {
        std::cout << "Value is a double: " << std::get<double>(myVariant) << std::endl;
    }

    // Assigning a string value
    myVariant = "Hello, variant!";
    if (std::holds_alternative<std::string>(myVariant)) {
        std::cout << "Value is a string: " << std::get<std::string>(myVariant) << std::endl;
    }

    return 0;
}

//if there is if condition and there is wrong data type access?
 catch (const std::bad_variant_access& e) {
        std::cout << "Exception: " << e.what() << std::endl;

=============================================
union can have the constructor and destructir and it will be called when the object is created?
=============
f members of a union are classes with user-defined constructors and destructors, 
to switch the active member, explicit destructor and
 placement new are generally needed:

Run this code
#include <iostream>
#include <string>
#include <vector>
 
union S
{
    std::string str;
    std::vector<int> vec;
    ~S() {} // needs to know which member is active, only possible in union-like class 
};          // the whole union occupies max(sizeof(string), sizeof(vector<int>))
 
int main()
{
    S s = {"Hello, world"};
    // at this point, reading from s.vec is undefined behavior
    std::cout << "s.str = " << s.str << '\n';
    s.str.~basic_string();
    new (&s.vec) std::vector<int>; //or new (&s.vec) std::vector<int>();
    // now, s.vec is the active member of the union
    s.vec.push_back(10);
    std::cout << s.vec.size() << '\n';
    s.vec.~vector();
}
Output:

s.str = Hello, world
1
=====================================================
================================================

#include <iostream>
#include <vector>

template <typename T>
class MyContainer {
public:
    std::vector<std::vector<T>> data; // Issue in C++11 without space
    // std::vector<std::vector<T> > data; // Correct usage with a space
};

int main() {
    MyContainer<int> container;
    container.data.resize(5);
    container.data[0].push_back(42);

    std::cout << container.data[0][0] << std::endl;

    return 0;
}
===========================

=====================================
==============================
to check whether the user is string is email id or not?
how to check if the word is present or not?
how to print all the word in the string?
how to iterate over all the element in the word?
print the word?

#include <iostream>
#include <regex>
#include <string>

int main() {
    // Input text containing email addresses
    std::string text = "Please contact support@example.com or john.doe@gmail.com for assistance.";

    // Define a regular expression pattern for matching email addresses
    std::regex emailPattern(R"(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}\b)");

    // Use std::sregex_iterator to find all email addresses in the text
    std::sregex_iterator iterator(text.begin(), text.end(), emailPattern);
    std::sregex_iterator end;

    // Iterate through matches and print each email address
    while (iterator != end) {
        std::cout << "Found email: " << iterator->str() << std::endl;
        ++iterator;
    }

    return 0;
}
===============================
Search with beging and ending word?
Search word is of what data type?
how to check if the word is present or not?
how to print all the word in the string?
how to iterate over all the element in the word?

#include <iostream>
#include <regex>
#include <string>

int main() {
    // Input string
    std::string text = "a The quick, brown fox jumps over the lazy dog.";

    // Define a regular expression pattern
    std::regex pattern("quick.*lazy");

    // Search for the regular expression pattern in the input text
    if (std::regex_search(text, pattern)) {
        std::cout << "Pattern found in the text." << std::endl;
    } else {
        std::cout << "Pattern a not, found in the text." << std::endl;
    }

    // Match regular expression with iterator
    std::regex word_pattern("\\b\\w+\\b"); // Matches words

    // Create an iterator for matching words in the text
    std::sregex_iterator iterator(text.begin(), text.end(), word_pattern);
    std::sregex_iterator end;

    // Iterate through matches and print them
    while (iterator != end) {
        std::cout << iterator->str() << std::endl;
        ++iterator;
    }

    return 0;
}
=================================

regex_replace : 
<> : will replace only <>
<?>: will remove the <> and >
<.*>: all match character from < to the end. so here starting from < and till the end of the line >

#include <iostream>
#include <regex>

std::string removeXmlTags(const std::string &xmlString) {
    // Regular expression to match XML tags
    std::regex tagsRegex("<.?>");

    // Use regex_replace to remove tags
    return std::regex_replace(xmlString, tagsRegex, "");
}

int main() {
    // Example XML string with tags
    std::string xmlString = "<><root><element1>Value 1</element1><element2>Value 2</element2></root>";

    // Remove XML tags
    std::string result = removeXmlTags(xmlString);

    // Display the result
    std::cout << "Original XML:\n" << xmlString << "\n\n";
    std::cout << "After removing tags:\n" << result << "\n";

    return 0;
}

===============================
weak_ptr on lock
int array , variable and vector for {}
stream_iterator?
header file for iota and accumulate?
header file for pair?
header file for Nan?
continously get the data for user in vector?
calling the base constructor using
variant
header file required for function<>?
incrment the array by one element
incrment the array by entire array element
function pointer assignement and calling in different ways
bind taking the argument value ?
difference between the set and unorder_set:
file ioperation.
capture list taking the function argument:
when nonconst object will use mutuable?
random
find_if return type?
throw the runtime error
RAII
fill header?
.begin() and .end() header?
assignement operator return type
capture list: for global variable
capture list to copy all reference
capture list to take one variable reference and once variable by value
ambiguit in the class member variable, class method and global method
detachable thread and thread using lamda
[=]: which function is called?
back_inserter and back_insert_iterator
vector initialization using the individual element
static_assert
copy by value in the capture list
move the tuple in the capture lists
get the individaul element in the tupele

apply the tuple variable to the function argument
alias for the function pointer
global variable as the value and local variable as agrument in the captur list:
copy the string to character array in different ways:
back_inserter examples:
capturelist[x] and [x=100] difference
copy_in for string vector
regex search
regex replace
regex iterator
regext match
R" and ("\\
////////////
map insertion is success or not?
multiple insert in map after the declaration
find and replace in string?
file opened success or not?
read the line from file and convert isstring stream?
set with user defined function
map with user defined function

map<int,string>::iterator UOIT
pair<UOIT,bool> result = mymap.insert({1,"hi"})
result.second = true only when the insertion is completed
===
mymap.insert({{1,"hi"},{2,""west}});
=================
    size_t pos = line.find(findWord);
    while (pos != std::string::npos) {
        line.replace(pos, findWord.length(), replaceWord);
        pos = line.find(findWord, pos + replaceWord.length());
    }
===============
    if (!outputFile) { //outputFile.is_open()
        cout << "Failed to open the file." << endl;
        return 1;
    }
================
getline(inputFile,linestring)
    while (inputFile >> num) {
        cout << num << " ";
    }
================
    std::string line;
    while (std::getline(inputFile, line))
    {
        std::istringstream iss(line);
        std::string word;
        while (iss >> word)
=============
map with fuctor function and class object:
 std::unordered_set<Person, PersonHash> people; //person is the class name and PersonHash is the functor;
 people.insert(Person("Alice", 25));
===============================
    std::unordered_set<std::string> setOfStrs;
    // Insert strings to the set
    setOfStrs.insert("First");
==================
  // Declaring a set of tuples
  set<tuple<int, int, 
            int>, cmp> setOfTuples;
			
for_each
find_if
count_if
sort
unique
copy_if
remove_copy_if
transform(
======================================
regex:
std::regex word_pattern("\\b\\w+\\b"); 
sregex_ierator iterator(s.begin(),s.end(), pattern)
iterator->str()
string xmlString
tagsRegex :regex pattern
""to replace"
std::regex_replace(xmlString, tagsRegex, "");
std::regex pattern("\\b(\\w+fox)\\b"); //std::regex pattern(R"(\b(\w+fox)\b)");

// std::smatch to store matched results
std::smatch matchResults;

// Use std::regex_search with std::smatch to find the first match and capture groups
if (std::regex_search(text, matchResults, pattern)) {
// Access the entire match
std::cout << "Full match: " << matchResults[0] << std::endl;

std::regex pattern("<.*?>");

// std::smatch to store matched results
std::smatch matchResults;

// Use std::regex_search with std::smatch to find all matches
while (std::regex_search(text, matchResults, pattern)) // to print only between the <*> 
==========================================

weak_ptr => we use lock which return the shared_ptr and this pointer is used to access the other class function.
int a {}; int a[]{}; vector <int> v{}
iota and accumulate : numeric header
nan : cmath and limits
pair : utility
istream need the <int>
istream_iterator can use istringstream write data to  vector
istream_iterator can use inputfile write data to  vector
ostream_iterator can use output file to write the data to the file
contiously push the data into the vector
while(cin>>a) {
v.push_back(a)
}

using Base::Base
holds_alternative

functional header file for function. functional<int> f() { return [](int) { return a }}
incrment the array by one element
int *p=(&array[0]+1)
int *p=(array+1)
incrment the array by entire array element
int *p=(&array+1)

funtionpointer = &functionname
funtionpointer = functionname
funtionpointer()
(*funtionpointer)()

auto binding = std::bing(&class::publicfunc, &object, value)
then no need to call binding(23); //23 has no use 
set will store theelement in the ascending order and the performance will be higher in search, deletion, insertion
when the file is opened is it needs to closed

lamda=[this, newvalue]() //no need to specify the type of the variable here.
non const object accessing the const function needs the mutuable variable to modify it in the const function.
random rd;
mt19937 gen(rd())
g=uniform_int_distribution di(1.3)
int y=g(gen)

find_if return the iterator
runtime_error("fdshgfjshdg")

Resources acquastition is initialization
fill require ->algorithm
.begin(),.end() requires: iterator

sample& operator=(sample&obj) { return *this) }

if the global varaible is modified in the capture list it will imapact in other places also (empty, reference and pass by value cases)
capture list to copy all variable by reference
auto l=[&]()
capture list to take one variable reference and once variable by value
auto l=[&x, y]()

ambiguity in the class member variable, class method and global method
this->value=value
obj.classname::functionanme()
namespace namespacename {
functionname()
}

detachable thread and thread using lamda:
threadf(globalfunction).detach()
thread([](){})

[=]: which function is called?
affect the global variabledoesn't affect the global or local object since the objects are copied by calling the copy constructor.

back_insert_iterator:
    // Using OutputIterator to add elements to the vector
    for (int i = 1; i <= 5; ++i) {
        std::back_insert_iterator<std::vector<int>> it(vec);
        *it = i;
    }
	
back_inserter:	
    // Read data from the user using istream_iterator
    std::copy(
        std::istream_iterator<myclass>(std::cin),
        std::istream_iterator<myclass>(),
        std::back_inserter(data)
    );
	
inserter:
    // Using std::inserter to add elements to the map
    std::inserter(myMap, myMap.end()) = std::make_pair(3, "three"); //no begin here
	
we cannot initialize the vector using the (1,2,3,4)	
 std::vector<int> v = std::vector<int>{1, 2, 3, 4, 5};
  std::vector<int> v (5,0) //fill the vector with 5 element with 0
  
  
static_assert(is_arithmetic_v<T>,"not matched");
move and cpy in the caputre list:
auto p=[obj=object]{} //hre the global and the local objects are different
auto p = [obj=move(object)](){} //onership is removed after the move

apply(functionname, tuplevariable) //this function will extract and apply the tuple to each invidual argument
get<0>(tuplevariable) ;// get the first element of tuple

alias:
using T = void(*)(int)
T fun = myfunction
T &fun = myfunction
const T &func =&myfunction
==================
int main() {
           auto boundFunction = [x=100](){ //no error
            std::cout << x <<"  ";
        };
        boundFunction();


    return 0;
}

int main() {
           auto boundFunction = [x](){ //x is not declared
            std::cout << x <<"  ";
        };
        boundFunction();


    return 0;
}
=============
numeric header file is required for iota , transform and accumulate?